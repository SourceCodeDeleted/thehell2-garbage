
char InitalChurchWallScheme[ 80 ][ 80 ];
char ChurchWallFlagMap[ 40 ][ 40 ];
int IsFirstBigChurchHallPlaced;
int IsSecondBigChurchHallPlaced;
int IsThirdBigChurchHallPlaced;
int IsFirstBigChurchHallPlaced2;
int IsSecondBigChurchHallPlaced2;
int IsThirdBigChurchHallPlaced2;
char* DUNFilePtr;
int IsChurchHallDUNFileLoaded;

uchar UberRoomPattern[] = {
	4, 6, 
	115, 130, 6, 13, 129, 108, 
	1,	13, 1,	107, 103, 13,	
	146, 106, 102, 13, 129, 168, 
	1, 	13, 7, 2, 3, 13
};

uchar CornerstoneRoomPattern[] = {
	5, 5, 
	4, 2, 2, 2, 6, 
	1, 111, 172, 0, 1, 
	1,	172, 0, 0,	25, 
	1, 0, 0, 0, 1, 
	7,	2, 2, 2, 3
};

uchar ChurchOrientedWallsAndCorner[16] = {
	CHR_WAFM_22_BEYOND,CHR_WAFM_13_FLOOR,CHR_WAFM_1_SWALL_UNM_MIDDLE,CHR_WAFM_13_FLOOR, 
	CHR_WAFM_2_SWALL_M_MIDLE,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR, 
	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,CHR_WAFM_13_FLOOR,CHR_WAFM_1_SWALL_UNM_MIDDLE,CHR_WAFM_13_FLOOR, 
	CHR_WAFM_2_SWALL_M_MIDLE,CHR_WAFM_13_FLOOR,CHR_WAFM_16_WALL_LD_END,CHR_WAFM_13_FLOOR 
};

uchar SomeChurchShadowsTable2[7*37] = {
	CHR_WAFM_7_SWALL_LU_END,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_144_TILE_WITH_SHADOW_6,	0,	CHR_WAFM_142_TILE_WITH_SHADOW_4,
	CHR_WAFM_16_WALL_LD_END,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_144_TILE_WITH_SHADOW_6,	0,	CHR_WAFM_142_TILE_WITH_SHADOW_4,
	CHR_WAFM_15_PILLAR,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_145_TILE_WITH_SHADOW_7,	0,	CHR_WAFM_142_TILE_WITH_SHADOW_4,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_152_TILE_WITH_SHADOW_14,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_143_TILE_WITH_SHADOW_5,	CHR_WAFM_146_TILE_WITH_SHADOW_8,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_143_TILE_WITH_SHADOW_5,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	CHR_WAFM_148_TILE_WITH_SHADOW_10,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	0,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	0,	CHR_WAFM_146_TILE_WITH_SHADOW_8,	CHR_WAFM_148_TILE_WITH_SHADOW_10,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_143_TILE_WITH_SHADOW_5,	CHR_WAFM_147_TILE_WITH_SHADOW_9,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_143_TILE_WITH_SHADOW_5,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	CHR_WAFM_149_TILE_WITH_SHADOW_11,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_150_TILE_WITH_SHADOW_12,	CHR_WAFM_147_TILE_WITH_SHADOW_9,	CHR_WAFM_149_TILE_WITH_SHADOW_11,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_143_TILE_WITH_SHADOW_5,	CHR_WAFM_146_TILE_WITH_SHADOW_8,	CHR_WAFM_149_TILE_WITH_SHADOW_11,
	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_143_TILE_WITH_SHADOW_5,	CHR_WAFM_147_TILE_WITH_SHADOW_9,	CHR_WAFM_148_TILE_WITH_SHADOW_10,
	CHR_WAFM_9_ARCH_LU_END,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_144_TILE_WITH_SHADOW_6,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	CHR_WAFM_142_TILE_WITH_SHADOW_4,
	CHR_WAFM_9_ARCH_LU_END,	CHR_WAFM_13_FLOOR,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_144_TILE_WITH_SHADOW_6,	CHR_WAFM_146_TILE_WITH_SHADOW_8,	CHR_WAFM_142_TILE_WITH_SHADOW_4,
	CHR_WAFM_9_ARCH_LU_END,	CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_151_TILE_WITH_SHADOW_13,	CHR_WAFM_147_TILE_WITH_SHADOW_9,	CHR_WAFM_142_TILE_WITH_SHADOW_4,
	CHR_WAFM_8_ARCH_RU_END,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_144_TILE_WITH_SHADOW_6,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_8_ARCH_RU_END,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_143_TILE_WITH_SHADOW_5,	0,	CHR_WAFM_149_TILE_WITH_SHADOW_11,
	CHR_WAFM_8_ARCH_RU_END,	0,	0,	CHR_WAFM_2_SWALL_M_MIDLE,	0,	0,	CHR_WAFM_148_TILE_WITH_SHADOW_10,
	CHR_WAFM_11_UNM_ARCH_MIDDLE,	0,	0,	CHR_WAFM_13_FLOOR,	0,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_139_TILE_WITH_SHADOW_1,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_148_TILE_WITH_SHADOW_10,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_149_TILE_WITH_SHADOW_11,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_139_TILE_WITH_SHADOW_1,	0,	CHR_WAFM_149_TILE_WITH_SHADOW_11,
	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	0,	0,	CHR_WAFM_13_FLOOR,	0,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_139_TILE_WITH_SHADOW_1,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	CHR_WAFM_2_SWALL_M_MIDLE,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_148_TILE_WITH_SHADOW_10,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	CHR_WAFM_12_M_ARCH_MIDDLE,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_149_TILE_WITH_SHADOW_11,	0,	CHR_WAFM_139_TILE_WITH_SHADOW_1,
	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_139_TILE_WITH_SHADOW_1,	0,	CHR_WAFM_149_TILE_WITH_SHADOW_11,
	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	0,	CHR_WAFM_13_FLOOR,	0,	0,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	0,
	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	0,
	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	0,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	0,	0,	CHR_WAFM_146_TILE_WITH_SHADOW_8,	0,
	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	0,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	CHR_WAFM_147_TILE_WITH_SHADOW_9,	0,
	CHR_WAFM_12_M_ARCH_MIDDLE,	0,	CHR_WAFM_13_FLOOR,	0,	0,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	0,
	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	0,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	0,
	CHR_WAFM_12_M_ARCH_MIDDLE,	0,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	0,	0,	CHR_WAFM_146_TILE_WITH_SHADOW_8,	0,
	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	0,	CHR_WAFM_140_TILE_WITH_SHADOW_2,	CHR_WAFM_147_TILE_WITH_SHADOW_9,	0,
	CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH ,CHR_WAFM_13_FLOOR,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_150_TILE_WITH_SHADOW_12,	0,	0,
};

// uchar ConstByteArray11[]
uchar SomeChurchShadowsTable[208] = { 
	0,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_6_SWALL_RU_END,	CHR_WAFM_7_SWALL_LU_END,	CHR_WAFM_8_ARCH_RU_END,	CHR_WAFM_9_ARCH_LU_END,	
	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	CHR_WAFM_15_PILLAR,	CHR_WAFM_16_WALL_LD_END,	CHR_WAFM_17_WALL_RD_END,	0,	0,	
	0,	0,	0,	0,	0,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	
	CHR_WAFM_6_SWALL_RU_END,	CHR_WAFM_7_SWALL_LU_END,	CHR_WAFM_8_ARCH_RU_END,	CHR_WAFM_9_ARCH_LU_END,	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	
	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	
	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_6_SWALL_RU_END,	CHR_WAFM_7_SWALL_LU_END,	CHR_WAFM_16_WALL_LD_END,	CHR_WAFM_17_WALL_RD_END,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	
	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	
	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	
	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	0,	
	0,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_13_FLOOR,	0,	0,	0,	0,	
	0,	0,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	
	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	
	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	
	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_2_SWALL_M_MIDLE,	
	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR,	CHR_WAFM_26_M_MIDDLE_CLOSED_DOOR,	CHR_WAFM_28_CORNER_BETWEEN_LU_CDOOR_AND_RU_CDOOR,	CHR_WAFM_30_CDOOR_RU_END,	CHR_WAFM_31_CDOOR_LU_END,	
	CHR_WAFM_41_CORNER_BETWEEN_LU_CDOOR_AND_RU_CWALL,	CHR_WAFM_43_CORNER_BETWEEN_LU_CWALL_AND_RU_CDOOR,	CHR_WAFM_40_CORNER_BETWEEN_LU_CDOOR_AND_RU_ARCH,	CHR_WAFM_41_CORNER_BETWEEN_LU_CDOOR_AND_RU_CWALL,	CHR_WAFM_42_CORNER_BETWEEN_LU_ARCH_AND_RU_CDOOR,	CHR_WAFM_43_CORNER_BETWEEN_LU_CWALL_AND_RU_CDOOR,	CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR,	CHR_WAFM_41_CORNER_BETWEEN_LU_CDOOR_AND_RU_CWALL,	CHR_WAFM_43_CORNER_BETWEEN_LU_CWALL_AND_RU_CDOOR,	CHR_WAFM_28_CORNER_BETWEEN_LU_CDOOR_AND_RU_CDOOR,	
	CHR_WAFM_28_CORNER_BETWEEN_LU_CDOOR_AND_RU_CDOOR,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR,	CHR_WAFM_26_M_MIDDLE_CLOSED_DOOR,	CHR_WAFM_22_BEYOND,	CHR_WAFM_22_BEYOND,	CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR,	CHR_WAFM_26_M_MIDDLE_CLOSED_DOOR,	0,	
	0,	0,	0,	0,	0,	0,	0,	0
};
// uchar ConstByteArray12[]
uchar ChurchTilesVariationsTable[208] = {
	0,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH,	CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL,	CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH,	CHR_WAFM_6_SWALL_RU_END,	CHR_WAFM_7_SWALL_LU_END,	CHR_WAFM_8_ARCH_RU_END,	CHR_WAFM_9_ARCH_LU_END,	
	CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	CHR_WAFM_13_FLOOR,	CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL,	CHR_WAFM_15_PILLAR,	CHR_WAFM_16_WALL_LD_END,	CHR_WAFM_17_WALL_RD_END,	0,	0,	
	0,	0,	0,	0,	0,	CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR,	CHR_WAFM_26_M_MIDDLE_CLOSED_DOOR,	0,	CHR_WAFM_28_CORNER_BETWEEN_LU_CDOOR_AND_RU_CDOOR,	0,	
	CHR_WAFM_30_CDOOR_RU_END,	CHR_WAFM_31_CDOOR_LU_END,	0,	0,	0,	0,	0,	0,	0,	0,	
	CHR_WAFM_40_CORNER_BETWEEN_LU_CDOOR_AND_RU_ARCH,	CHR_WAFM_41_CORNER_BETWEEN_LU_CDOOR_AND_RU_CWALL,	CHR_WAFM_42_CORNER_BETWEEN_LU_ARCH_AND_RU_CDOOR,	CHR_WAFM_43_CORNER_BETWEEN_LU_CWALL_AND_RU_CDOOR,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	CHR_WAFM_79_HALL_OF_HEROS_1,	
	CHR_WAFM_80_HALL_OF_HEROS_2,	0,	CHR_WAFM_82_HALL_OF_HEROS_4,	0,	0,	0,	0,	0,	0,	CHR_WAFM_79_HALL_OF_HEROS_1,	
	0,	CHR_WAFM_80_HALL_OF_HEROS_2,	0,	0,	CHR_WAFM_79_HALL_OF_HEROS_1,	CHR_WAFM_80_HALL_OF_HEROS_2,	0,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	
	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	
	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_2_SWALL_M_MIDLE,	CHR_WAFM_12_M_ARCH_MIDDLE,	0,	
	0,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_11_UNM_ARCH_MIDDLE,	CHR_WAFM_1_SWALL_UNM_MIDDLE,	CHR_WAFM_13_FLOOR,	0,	0,	0,	0,	
	0,	0,	0,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	CHR_WAFM_13_FLOOR,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0
};

// uchar PatMap4x4[]
uchar PatMap4x4_ChurchPassageUp[34] = {
	4, 4, 

	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_2_SWALL_M_MIDLE,CHR_WAFM_2_SWALL_M_MIDLE,CHR_WAFM_2_SWALL_M_MIDLE,CHR_WAFM_2_SWALL_M_MIDLE, 
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,

	0,CHR_WAFM_66_CHURCH_LEDDER_TO_UP_4,	CHR_WAFM_6_SWALL_RU_END, 0, 
	CHR_WAFM_63_CHURCH_LEDDER_TO_UP_1,CHR_WAFM_64_CHURCH_LEDDER_TO_UP_2,CHR_WAFM_65_CHURCH_LEDDER_TO_UP_3, 0, 
	0,CHR_WAFM_67_CHURCH_LEDDER_TO_UP_5,CHR_WAFM_68_CHURCH_LEDDER_TO_UP_6, 0, 
	0, 0, 0, 0
};
// uchar PatMap4x5[]
uchar PatMap4x5_CryptPassageUp[48] = {
	4, 5, 
	22, 22, 22, 22, 
	22, 22, 22, 22, 
	2, 2, 2, 2, 13, 
	13, 13, 13, 13, 
	13, 13, 13, 0, 

	54, 23, 0, 0,
	53, 18, 0, 55,
	56, 57, 0, 58,
	59, 60, 0, 0,
	0, 0, 0, 0,				0, 0, 0, 0, 0		// 37
};
// uchar PatMap4x3[]
uchar PatMap4x3_ChurchPassageDown[27] = {
	4, 3, 
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,

	CHR_WAFM_62_CHURCH_LEDDER_TO_DOWN_6,CHR_WAFM_57_CHURCH_LEDDER_TO_DOWN_1,CHR_WAFM_58_CHURCH_LEDDER_TO_DOWN_2, 0, 
	CHR_WAFM_61_CHURCH_LEDDER_TO_DOWN_5,CHR_WAFM_59_CHURCH_LEDDER_TO_DOWN_3,CHR_WAFM_60_CHURCH_LEDDER_TO_DOWN_4, 0, 
	0, 0, 0, 0, 0
};
// uchar Pat2Map4x5[]
uchar Pat2Map4x5_CryptPassageDown[48] = {
	4, 5, 13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13, 0, 0, 52, 0, 0,	48, 51// 0 // ...
	, 0, 0, 47, 50, 0, 45, 46, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0// 29
};
// uchar Pat3Map4x5[]
uchar Pat3Map4x5_CryptPassageToTown[48] = {
	4, 5, 22, 22, 22, 22, 22, 22, 22, 22, 2, 2, 2, 2, 13, 13, 13, 13, 13, 13, 13, 13, 0, 62, 23//	0 // ...
	, 0, 0, 61, 18, 0, 63, 64, 65, 0, 66, 67, 68// 25
	, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0		// 37
};
uchar PatMap2x2_ChurchOnFloorTorch[10] = { 
	2, 2, 
	CHR_WAFM_13_FLOOR, 0, 
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR, 
	CHR_WAFM_129_ON_FLOOR_TORCH_SHADOW_1, 0, 
	CHR_WAFM_130_ON_FLOOR_TORCH_SHADOW_2,CHR_WAFM_128_ON_FLOOR_TORCH
};

// uchar PatMap6x6[]
uchar PatMap6x6_WaterSupplyEnter[76] = {
	6, 6, 
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,
	CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,CHR_WAFM_13_FLOOR,

	0, 0, 0, 0, 0, 0, 0, 
	CHR_WAFM_202_BEYOND,CHR_WAFM_200_BEYOND,CHR_WAFM_200_BEYOND,CHR_WAFM_84_HALL_OF_HEROS_6, 0, 0, 
	CHR_WAFM_199_BEYOND,CHR_WAFM_203_BEYOND,CHR_WAFM_203_BEYOND,CHR_WAFM_83_HALL_OF_HEROS_5, 0, 0, 
	CHR_WAFM_85_HALL_OF_HEROS_7,CHR_WAFM_206_POISON_WELL_ENTER,CHR_WAFM_80_HALL_OF_HEROS_2,CHR_WAFM_81_HALL_OF_HEROS_3, 0, 0, 
	0,CHR_WAFM_134_FLOOR_WITH_CRUSHED_ROCK_2,CHR_WAFM_135_FLOOR_WITH_CRUSHED_ROCK_3, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0// 58
};
uchar PatMap1x1[4] = {1, 1, 11, 95	};
uchar Pat2Map1x1[8] = {1, 1, 12, 96, 0, 0, 0, 0};
uchar PatMap1x3[8] = {1, 3, 1, 1, 1, 91,	90, 89};
uchar Pat2Map1x3[8] = {3, 1, 2, 2, 2, 94,	93, 92};
uchar Pat3Map1x1[4] = {1, 1, 13, 97	};
uchar Pat4Map1x1[4] = {1, 1, 13, 98	};
uchar Pat5Map1x1[4] = {1, 1, 13, 99	};
uchar Pat6Map1x1[4] = {1, 1, 13, 100	};
uchar PatMap3x3[20] = {3, 3, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0, 0, 0, 0, 101, 0, 0, 0, 0};
uchar PatMap1x1a[4] = {1, 1, 11, 185	};
uchar PatMap1x1s[4] = {1, 1, 11, 186	};
uchar PatMap1x1d[4] = {1, 1, 12, 187	};
uchar PatMap1x1f[4] = {1, 1, 12, 188	};
uchar PatMap1x1g[4] = {1, 1, 89, 173	};
uchar PatMap1x1h[4] = {1, 1, 89, 174	};
uchar PatMap1x1j[4] = {1, 1, 90, 175	};
uchar PatMap1x1k[4] = {1, 1, 90, 176	};
uchar PatMap1x1l[4] = {1, 1, 91, 177	};
uchar PatMap1x1z[4] = {1, 1, 91, 178	};
uchar PatMap1x1x[4] = {1, 1, 92, 179	};
uchar PatMap1x1c[4] = {1, 1, 92, 180	};
uchar PatMap1x1v[4] = {1, 1, 92, 181	};
uchar PatMap1x1b[4] = {1, 1, 92, 182	};
uchar PatMap1x1n[4] = {1, 1, 92, 183	};
uchar PatMap1x1m[4] = {1, 1, 92, 184	};
uchar PatMap1x1q[4] = {1, 1, 98, 189	};
uchar PatMap1x1w[4] = {1, 1, 98, 190	};
uchar PatMap1x1e[4] = {1, 1, 97, 191	};
uchar PatMap1x1r[4] = {1, 1, 15, 192	};
uchar PatMap1x1t[4] = {1, 1, 99, 193	};
uchar PatMap1x1y[4] = {1, 1, 99, 194	};
uchar PatMap1x1u[4] = {1, 1, 100, 195	};
uchar PatMap1x1i[4] = {1, 1, 101, 196	};
uchar PatMap1x1o[4] = {1, 1, 101, 197	};
uchar PatMap1x1p[8] = {1, 1, 101, 198, 0, 0, 0, 0};
uchar PatMap3x3q[24] = {3, 3, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0};
uchar PatMap3x3w[24] = {3, 3, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0};
uchar PatMap3x3e[24] = {3, 3, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0, 0, 0, 0, 169, 0, 0, 0, 0, 0, 0, 0, 0};
uchar PatMap3x3r[24] = {3, 3, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0, 0, 0, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0};
uchar PatMap3x3t[24] = {3, 3, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0};
uchar PatMap3x3y[20] = {3, 3, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0, 0, 0, 0, 172, 0, 0, 0, 0};
uchar PatMap1x1p1[4] = {1, 1, 13, 163	};
uchar PatMap1x1p2[4] = {1, 1, 13, 164	};
uchar PatMap1x1p3[4] = {1, 1, 13, 165	};
uchar PatMap1x1p4[4] = {1, 1, 13, 166	};
uchar PatMap1x1p5[4] = {1, 1, 1, 112	};
uchar PatMap1x1p6[4] = {1, 1, 2,	113	};
uchar PatMap1x1p7[4] = {1, 1, 3,	114	};
uchar PatMap1x1p8[4] = {1, 1, 4,	115	};
uchar PatMap1x1p9[4] = {1, 1, 5,	116	};
uchar PatMap1x1q1[4] = {1, 1, 6,	117	};
uchar PatMap1x1q2[4] = {1, 1, 7,	118	};
uchar PatMap1x1q3[4] = {1, 1, 8,	119	};
uchar PatMap1x1q4[4] = {1, 1, 9,	120	};
uchar PatMap1x1q5[4] = {1, 1, 10, 121	};
uchar PatMap1x1q6[4] = {1, 1, 11, 122	};
uchar PatMap1x1q7[4] = {1, 1, 12, 123	};
uchar PatMap1x1q8[4] = {1, 1, 13, 124	};
uchar PatMap1x1q9[4] = {1, 1, 14, 125	};
uchar PatMap1x1w1[4] = {1, 1, 15, 126	};
uchar PatMap1x1w2[4] = {1, 1, 16, 127	};
uchar PatMap1x1w3[4] = {1, 1, 17, 128	};
uchar PatMap1x1w4[4] = {1, 1, 1, 129	};
uchar PatMap1x1w5[4] = {1, 1, 2,	130	};
uchar PatMap1x1w6[4] = {1, 1, 3,	131	};
uchar PatMap1x1_48A34C[4] = {1, 1, 4, 132	 };
uchar PatMap1x1_48A350[4] = {1, 1, 5, 133	 };
uchar PatMap1x1_48A354[4] = {1, 1, 6, 134	 };
uchar PatMap1x1_48A358[4] = {1, 1, 7, 135	 };
uchar PatMap1x1_48A35C[4] = {1, 1, 8, 136	 };
uchar PatMap1x1_48A360[4] = {1, 1, 9, 137	 };
uchar PatMap1x1_48A364[4] = {1, 1, 10, 138	 };
uchar PatMap1x1_48A368[4] = {1, 1, 11, 139	 };
uchar PatMap1x1_48A36C[4] = {1, 1, 12, 140	 };
uchar PatMap1x1_48A370[4] = {1, 1, 13, 141	 };
uchar PatMap1x1_48A374[4] = {1, 1, 14, 142	 };
uchar PatMap1x1_48A378[4] = {1, 1, 15, 143	 };
uchar PatMap1x1_48A37C[4] = {1, 1, 16, 144	 };
uchar PatMap1x1_48A380[4] = {1, 1, 17, 145	 };
uchar PatMap1x1_48A384[4] = {1, 1, 1, 146	 };
uchar PatMap1x1_48A388[4] = {1, 1, 2, 147	 };
uchar PatMap1x1_48A38C[4] = {1, 1, 3, 148	 };
uchar PatMap1x1_48A390[4] = {1, 1, 4, 149	 };
uchar PatMap1x1_48A394[4] = {1, 1, 5, 150	 };
uchar PatMap1x1_48A398[4] = {1, 1, 6, 151	 };
uchar PatMap1x1_48A39C[4] = {1, 1, 7, 152	 };
uchar PatMap1x1_48A3A0[4] = {1, 1, 8, 153	 };
uchar PatMap1x1_48A3A4[4] = {1, 1, 9, 154	 };
uchar PatMap1x1_48A3A8[4] = {1, 1, 10, 155	 };
uchar PatMap1x1_48A3AC[4] = {1, 1, 11, 156	 };
uchar PatMap1x1_48A3B0[4] = {1, 1, 12, 157	 };
uchar PatMap1x1_48A3B4[4] = {1, 1, 13, 158	 };
uchar PatMap1x1_48A3B8[4] = {1, 1, 14, 159	 };
uchar PatMap1x1_48A3BC[4] = {1, 1, 15, 160	 };
uchar PatMap1x1_48A3C0[4] = {1, 1, 16, 161	 };
uchar PatMap1x1_48A3C4[4] = {1, 1, 17, 162	 };
uchar PatMap1x1_48A3C8[4] = {1, 1, 1, 199	 };
uchar PatMap1x1_48A3CC[4] = {1, 1, 1, 201	 };
uchar PatMap1x1_48A3D0[4] = {1, 1, 2, 200	 };
uchar PatMap1x1_48A3D4[4] = {1, 1, 2, 202	 };
//====================================================
int CataQuestRoomStartRow;
int CataQuestRoomEndRow;
int CataQuestRoomStartCol;
int CataQuestRoomEndCol;

CataPassageQueue* CataPassageQueuePtr;
uchar CatacombMapAdvance[ 40 ][ 40 ];
int CataHallsCount;
CataHall CataHalls[80];

StrangeCataPattern StrangeCataPatterns[2] = {
	{6, 3, 0, 3, CATA_WAFM_48, 0, CATA_WAFM_50}, 
	{9, 3, 0, 3, CATA_WAFM_48, 0, CATA_WAFM_50}
};

char CataTilesVariationsTable[161] = {// может даже 160
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9,// 0 
	0, 0, 0, 0, 0, 0, 0, 17, 18, 1, // 10
	1, 2, 2, 1, 1, 1, 1, 1, 1, 2, // 20
	2, 2, 2, 2, 0, 0, 0, 0, 8, 0, // 30
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 50
	0, 0, 0, 0, 0, 0, 0, 0,	1, 1, // 60
	1, 0, 0, 2, 2, 2, 0, 0, 0, 1, // 70
	0, 0, 0, 0, 0, 0, 0, 0,	3, 3, // 80 88-91
	3, 3, 0, 0, 0, 0, 0, 0, 0, 0, // 90
	0, 0, 0, 0, 0, 3, 3, 3, 0, 3, // 100 105-107 109 111
	0, 3, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

char SomeCataTilesTypes[161] = {// может даже 160
	0, 1, 2, 3, 0, 0, 6, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
	2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 6, 6, 6, 9,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 1, 1, 1, 0, 0, 2, 2, 2, 0, 0, 0,
	1, 1, 1, 1, 6, 2, 2, 2, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	1, 1, 2, 2, 3, 3, 3, 3, 1, 1, 2, 2, 3, 3, 3, 3,
	1, 1, 3, 3, 2, 2, 3, 3, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

int SomeCataPatternMaps10x100 [] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, CATA_WAFM_3_FLOOR, 
	0, 0, 0, 0, 2, 0, 0, 0, 0, CATA_WAFM_3_FLOOR,
	0, 7, 0, 0, 1, 0, 0, 5, 0, CATA_WAFM_2_RU_WALL, 
	0, 5, 0, 0, 1, 0, 0, 7, 0, CATA_WAFM_2_RU_WALL, 
	0, 0, 0, 7, 1, 5, 0, 0, 0, CATA_WAFM_1_LU_WALL, 
	0, 0, 0, 5, 1, 7, 0, 0, 0, CATA_WAFM_1_LU_WALL, 
	0, 1, 0, 0, 3, 0, 0, 1, 0, CATA_WAFM_4_LU_ODOOR, 
	0, 0, 0, 1, 3, 1, 0, 0, 0, CATA_WAFM_5_RU_ODOOR, 
	0, 6, 0, 6, 1, 0, 0, 0, 0, CATA_WAFM_6_CORNER, 
	0, 6, 0, 0, 1, 6, 0, 0, 0, CATA_WAFM_9_CORNER, 
	0, 0, 0, 6, 1, 0, 0, 6, 0, CATA_WAFM_7_CORNER,
	0, 0, 0, 0, 1, 6, 0, 6, 0, CATA_WAFM_8_CORNER, 
	0, 6, 0, 6, 6, 0, 8, 6, 0, CATA_WAFM_7_CORNER, 
	0, 6, 8, 6, 6, 6, 0, 0, 0, CATA_WAFM_9_CORNER, 
	0, 6, 0, 0, 6, 6, 0, 6, 8, CATA_WAFM_8_CORNER, 
	6, 6, 6, 6, 6, 6, 0, 6, 0, CATA_WAFM_8_CORNER,
	2, 6, 6, 6, 6, 6, 0, 6, 0, CATA_WAFM_8_CORNER, 
	7, 7, 7, 6, 6, 6, 0, 6, 0, CATA_WAFM_8_CORNER, 
	6, 6, 2, 6, 6, 6, 0, 6, 0, CATA_WAFM_8_CORNER, 
	6, 2, 6, 6, 6, 6, 0, 6, 0, CATA_WAFM_8_CORNER, 
	2, 6, 6, 6, 6, 6, 0, 6, 0, CATA_WAFM_8_CORNER,
	6, 7, 7, 6, 6, 6, 0, 6, 0, CATA_WAFM_8_CORNER,
	4, 4, 6, 6, 6, 6, 2, 6, 2, CATA_WAFM_8_CORNER, 
	2, 2, 2, 2, 6, 2, 2, 6, 2, CATA_WAFM_7_CORNER, 
	2, 2, 2, 2, 6, 2, 6, 6, 6, CATA_WAFM_7_CORNER, 
	2, 2, 6, 2, 6, 6, 2, 2, 6, CATA_WAFM_9_CORNER, 
	2, 6, 2, 2, 6, 2, 2, 2, 2, CATA_WAFM_6_CORNER, 
	2, 2, 2, 2, 6, 6, 2, 2, 2, CATA_WAFM_9_CORNER, 
	2, 2, 2, 6, 6, 2, 2, 2, 2, CATA_WAFM_6_CORNER, 
	2, 2, 0, 2, 6, 6, 2, 2, 0, CATA_WAFM_9_CORNER, 
	0, 0, 0, 0, 4, 0, 0, 0, 0, CATA_WAFM_12_BEYOND, 
	0, 1, 0, 0, 1, 4, 0, 1, 0, CATA_WAFM_10_RD_WALL, 
	0, 0, 0, 1, 1, 1, 0, 4, 0, CATA_WAFM_11_LD_WALL,
	0, 0, 0, 6, 1, 4, 0, 1, 0, CATA_WAFM_14_CORNER,
	0, 6, 0, 1, 1, 0, 0, 4, 0, CATA_WAFM_16_CORNER,
	0, 6, 0, 0, 1, 1, 0, 4, 0, CATA_WAFM_15_CORNER, 
	0, 0, 0, 0, 1, 1, 0, 1, 4, CATA_WAFM_13_CORNER, 
	8, 8, 8, 8, 1, 1, 0, 1, 1, CATA_WAFM_13_CORNER,
	8, 8, 4, 8, 1, 1, 0, 1, 1, CATA_WAFM_10_RD_WALL, 
	0, 0, 0, 1, 1, 1, 1, 1, 1, CATA_WAFM_11_LD_WALL, 
	1, 1, 1, 1, 1, 1, 2, 2, 8, CATA_WAFM_2_RU_WALL, 
	0, 1, 0, 1, 1, 4, 1, 1,	0, CATA_WAFM_16_CORNER, 
	0, 0, 0, 1, 1, 1, 1, 1, 4, CATA_WAFM_11_LD_WALL,
	1, 1, 4, 1, 1, 1, 0, 2, 2, CATA_WAFM_2_RU_WALL,
	1, 1, 1, 1, 1, 1, 6, 2, 6, CATA_WAFM_2_RU_WALL,
	4, 1, 1, 1, 1, 1, 6, 2, 6, CATA_WAFM_2_RU_WALL, 
	2, 2, 2, 1, 1, 1, 4, 1, 1, CATA_WAFM_11_LD_WALL, 
	4, 1, 1, 1, 1, 1, 2, 2, 2, CATA_WAFM_2_RU_WALL, 
	1, 1, 4, 1, 1, 1, 2, 2, 1, CATA_WAFM_2_RU_WALL, 
	4, 1, 1, 1, 1, 1, 1, 2, 2, CATA_WAFM_2_RU_WALL, 
	2, 2, 6, 1, 1, 1, 4, 1, 1, CATA_WAFM_11_LD_WALL, 
	4, 1, 1, 1, 1, 1, 2, 2, 6, CATA_WAFM_2_RU_WALL, 
	1, 2, 2, 1, 1, 1, 4, 1, 1, CATA_WAFM_11_LD_WALL, 
	0, 1, 1, 0, 1, 1, 0, 1, 1, CATA_WAFM_10_RD_WALL,	
	2, 1, 1, 3, 1, 1, 2, 1, 1, CATA_WAFM_14_CORNER, 
	1, 1, 0, 1, 1, 2, 1, 1, 0, CATA_WAFM_1_LU_WALL, 
	0, 4, 0, 1, 1, 1, 0, 1, 1, CATA_WAFM_14_CORNER,
	4, 1, 0, 1, 1, 0, 1, 1, 0, CATA_WAFM_1_LU_WALL,
	0, 1, 0, 4, 1, 1, 0, 1, 1, CATA_WAFM_15_CORNER, 
	1, 1, 1, 1, 1, 1, 0, 2, 2, CATA_WAFM_2_RU_WALL, 
	0, 1, 1, 2, 1, 1, 2, 1, 4, CATA_WAFM_10_RD_WALL,
	2, 1, 1, 1, 1, 1, 0, 4, 0, CATA_WAFM_16_CORNER,
	1, 1, 4, 1, 1, 2, 0, 1, 2, CATA_WAFM_1_LU_WALL,
	2, 1, 1, 2, 1, 1, 1, 1, 4, CATA_WAFM_10_RD_WALL, 
	1, 1, 2, 1, 1, 2, 4, 1, 8, CATA_WAFM_1_LU_WALL, 
	2, 1, 4, 1, 1, 1, 4, 4, 1, CATA_WAFM_16_CORNER, 
	2, 1, 1, 1, 1, 1, 1, 1, 1, CATA_WAFM_16_CORNER, 
	1, 1, 2, 1, 1, 1, 1, 1, 1, CATA_WAFM_15_CORNER, 
	1, 1, 1, 1, 1, 1, 2, 1, 1, CATA_WAFM_14_CORNER, 
	4, 1, 1, 1, 1, 1, 2, 1, 1, CATA_WAFM_14_CORNER, 
	1, 1, 1, 1, 1, 1, 1, 1, 2, CATA_WAFM_8_CORNER, 
	0, 0, 0, 0, 255};

uchar PatMap2x4[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_7_CORNER, 

	CATA_WAFM_48, 0,
	CATA_WAFM_51, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_0[] = {
	2, 4,

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_8_CORNER, 

	CATA_WAFM_48, 0, 
	CATA_WAFM_51, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_1[] = {
	2, 4,

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_6_CORNER, 

	CATA_WAFM_48, 0, 
	CATA_WAFM_51, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_2[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_9_CORNER,

	CATA_WAFM_48, 0, 
	CATA_WAFM_51, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_3[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR,
	0, CATA_WAFM_14_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_4[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_13_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_5[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_16_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_6[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR,
	0, CATA_WAFM_15_CORNER, 

	CATA_WAFM_48,	0,
	CATA_WAFM_51,	CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_7[] = {
	2, 4,

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_7_CORNER, 

	CATA_WAFM_48, 0, 
	CATA_WAFM_51, CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_8[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_8_CORNER, 

	CATA_WAFM_48, 0, 
	CATA_WAFM_51, CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_9[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_6_CORNER, 

	CATA_WAFM_48, 0, 
	CATA_WAFM_51, CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_10[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_9_CORNER, 

	CATA_WAFM_48, 0,
	CATA_WAFM_51, CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_11[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER,
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_14_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_42,
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_12[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_13_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_13[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_16_CORNER,

	CATA_WAFM_48,	0,
	CATA_WAFM_51,	CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_14[] = {
	2, 4,

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_15_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x3[] = {
	2, 3, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	0,	CATA_WAFM_7_CORNER, 

	CATA_WAFM_141, CATA_WAFM_39,
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x3_0[] = {
	2, 3, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	0,	CATA_WAFM_8_CORNER, 

	CATA_WAFM_141,	CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x3_1[] = {
	2, 3, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR,
	0,	CATA_WAFM_6_CORNER, 

	CATA_WAFM_141, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x3_2[] = {
	2, 3, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	0,	CATA_WAFM_9_CORNER,

	CATA_WAFM_141, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x3_3[] = {
	2, 3, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	0,	CATA_WAFM_14_CORNER, 

	CATA_WAFM_141, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x3_4[] = {
	2, 3, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR,
	0,	CATA_WAFM_13_CORNER,

	CATA_WAFM_141, CATA_WAFM_39,
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x3_5[] = {
	2, 3, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	0,	CATA_WAFM_16_CORNER, 

	CATA_WAFM_141, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x3_6[] = {
	2, 3, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	0,	CATA_WAFM_15_CORNER, 

	CATA_WAFM_141, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x4_15[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_1_LU_WALL, 
	0, CATA_WAFM_7_CORNER, 

	CATA_WAFM_48, 0, 
	CATA_WAFM_51, CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_16[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_1_LU_WALL, 
	0, CATA_WAFM_8_CORNER, 

	CATA_WAFM_48, 0,
	CATA_WAFM_51, CATA_WAFM_39,
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x4_17[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_1_LU_WALL, 
	0, CATA_WAFM_6_CORNER, 

	CATA_WAFM_48, 0,
	CATA_WAFM_51, CATA_WAFM_39,
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x4_18[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_1_LU_WALL, 
	0, CATA_WAFM_9_CORNER, 

	CATA_WAFM_48, 0,
	CATA_WAFM_51, CATA_WAFM_39,
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x4_19[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_1_LU_WALL,
	0, CATA_WAFM_14_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_39, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_20[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_1_LU_WALL, 
	0, CATA_WAFM_13_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_39,
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_21[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_1_LU_WALL, 
	0, CATA_WAFM_16_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_39,
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x4_22[] = {
	2, 4, 

	CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_4_LU_ODOOR, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_1_LU_WALL, 
	0, CATA_WAFM_15_CORNER, 

	CATA_WAFM_48,	0, 
	CATA_WAFM_51,	CATA_WAFM_39,
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_23[] = {
	2, 4, 

	CATA_WAFM_2_RU_WALL, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_7_CORNER, 

	CATA_WAFM_142, 0, 
	CATA_WAFM_51, CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_24[] = {
	2, 4, 

	CATA_WAFM_2_RU_WALL, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR,
	0, CATA_WAFM_8_CORNER, 

	CATA_WAFM_142, 0, 
	CATA_WAFM_51, CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_25[] = {
	2, 4, 

	CATA_WAFM_2_RU_WALL, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_6_CORNER, 

	CATA_WAFM_142, 0,
	CATA_WAFM_51, CATA_WAFM_42,
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_26[] = {
	2, 4, 

	CATA_WAFM_2_RU_WALL, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_9_CORNER, 

	CATA_WAFM_142, 0, 
	CATA_WAFM_51, CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_27[] = {
	2, 4, 

	CATA_WAFM_2_RU_WALL, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_14_CORNER, 

	CATA_WAFM_142, 0, 
	CATA_WAFM_51,	CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_28[] = {
	2, 4, 

	CATA_WAFM_2_RU_WALL, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_13_CORNER, 

	CATA_WAFM_142, 0, 
	CATA_WAFM_51,	CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44,
	0, 0};
uchar PatMap2x4_29[] = {
	2, 4, 

	CATA_WAFM_2_RU_WALL, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_16_CORNER, 

	CATA_WAFM_142, 0,
	CATA_WAFM_51,	CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap2x4_30[] = {
	2, 4, 

	CATA_WAFM_2_RU_WALL, 0, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_8_CORNER, 
	CATA_WAFM_3_FLOOR,	CATA_WAFM_4_LU_ODOOR, 
	0, CATA_WAFM_15_CORNER, 

	CATA_WAFM_142, 0, 
	CATA_WAFM_51,	CATA_WAFM_42, 
	CATA_WAFM_47, CATA_WAFM_44, 
	0, 0};
uchar PatMap3x2[] = {
	3, 2, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_2_RU_WALL, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_9_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_40,	CATA_WAFM_45, 0};
uchar PatMap3x2_0[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_2_RU_WALL, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_6_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_1[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_2_RU_WALL, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_8_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_2[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_2_RU_WALL, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_7_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_3[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0,
	CATA_WAFM_2_RU_WALL, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_15_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_4[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_2_RU_WALL, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_16_CORNER,

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_5[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0,
	CATA_WAFM_2_RU_WALL, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_13_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_6[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_2_RU_WALL, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_14_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_7[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_9_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46,	0, 
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_8[] = {
	3, 2, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_6_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_9[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_8_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_10[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_7_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_11[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_15_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_12[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_16_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_13[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0,
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_13_CORNER,

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_14[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR, CATA_WAFM_14_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_15[] = {
	3, 2, 

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_9_CORNER,

	CATA_WAFM_140,	CATA_WAFM_46, 0,
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_16[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_6_CORNER,

	CATA_WAFM_140,	CATA_WAFM_46, 0,
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_17[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_8_CORNER, 

	CATA_WAFM_140,	CATA_WAFM_46, 0,	
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_18[] = {
	3, 2, 

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_7_CORNER, 

	CATA_WAFM_140,	CATA_WAFM_46, 0,
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_19[] = {
	3, 2, 

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_15_CORNER, 

	CATA_WAFM_140, CATA_WAFM_46, 0,
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_20[] = {
	3, 2, 

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_16_CORNER, 

	CATA_WAFM_140, CATA_WAFM_46, 0, 
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_21[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_13_CORNER, 

	CATA_WAFM_140, CATA_WAFM_46, 0,
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_22[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_8_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_14_CORNER,

	CATA_WAFM_140, CATA_WAFM_46, 0,
	CATA_WAFM_43, CATA_WAFM_45, 0};
uchar PatMap3x2_23[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_5_RU_ODOOR, CATA_WAFM_2_RU_WALL, CATA_WAFM_9_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_24[] = {
	3, 2, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_5_RU_ODOOR, CATA_WAFM_2_RU_WALL, CATA_WAFM_6_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_25[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_5_RU_ODOOR, CATA_WAFM_2_RU_WALL, CATA_WAFM_8_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0, 
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_26[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_5_RU_ODOOR, CATA_WAFM_2_RU_WALL, CATA_WAFM_7_CORNER, 

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_27[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0,
	CATA_WAFM_5_RU_ODOOR, CATA_WAFM_2_RU_WALL, CATA_WAFM_15_CORNER,

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_28[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_5_RU_ODOOR, CATA_WAFM_2_RU_WALL, CATA_WAFM_16_CORNER,

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_29[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0,
	CATA_WAFM_5_RU_ODOOR, CATA_WAFM_2_RU_WALL, CATA_WAFM_13_CORNER,

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_30[] = {
	3, 2,  

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 0,
	CATA_WAFM_5_RU_ODOOR, CATA_WAFM_2_RU_WALL, CATA_WAFM_14_CORNER,

	CATA_WAFM_49, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_31[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_9_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_9_CORNER, 

	CATA_WAFM_140,	CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_32[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_9_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_6_CORNER, 

	CATA_WAFM_140,	CATA_WAFM_46, 0,	
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_33[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_9_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_8_CORNER, 

	CATA_WAFM_140,	CATA_WAFM_46, 0,	
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_34[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0,
	CATA_WAFM_9_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_7_CORNER, 

	CATA_WAFM_140,	CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_35[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_9_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_15_CORNER, 

	CATA_WAFM_140, CATA_WAFM_46, 0, 
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_36[] = {
	3, 2, 

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_9_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_16_CORNER, 

	CATA_WAFM_140, CATA_WAFM_46, 0, 
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_37[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_9_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_13_CORNER, 

	CATA_WAFM_140, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar PatMap3x2_38[] = {
	3, 2,  

	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 0, 
	CATA_WAFM_9_CORNER, CATA_WAFM_5_RU_ODOOR,	CATA_WAFM_14_CORNER,

	CATA_WAFM_140, CATA_WAFM_46, 0,
	CATA_WAFM_40, CATA_WAFM_45, 0};
uchar CataDungeonEnterToUp[] = {
	4, 4,

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	0, 0, 0, 0, 
	0, CATA_WAFM_72,	CATA_WAFM_77, 0, 
	0, CATA_WAFM_76, 0, 0, 
	0, 0, 0, 0};
uchar CataDungeonEnterToDown[] = {
	4, 4, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR,
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	0, 0, 0, 0, 
	0, CATA_WAFM_48,	CATA_WAFM_71, 0, 
	0, CATA_WAFM_50,	CATA_WAFM_78, 0, 
	0, 0, 0, 0};
uchar CataDungeonEnterToTown[] = {
	4, 4, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	0, 0, 0, 0,
	0, CATA_WAFM_158,	CATA_WAFM_160, 0, 
	0, CATA_WAFM_159, 0, 0, 
	0, 0, 0, 0};
uchar PatMap3x3_0[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR,
	CATA_WAFM_2_RU_WALL, CATA_WAFM_6_CORNER, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	0, 0, 0,
	0, CATA_WAFM_83, 0, 
	0, 0, 0};
uchar PatMap2x2_0[] = {
	2, 2, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	CATA_WAFM_113, 0, 
	CATA_WAFM_112, 0};
uchar PatMap2x2_1[] = {
	2, 2, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	CATA_WAFM_114, CATA_WAFM_115, 
	0, 0};
uchar PatMap1x2[] = {
	1, 2, 

	CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_1_LU_WALL,

	CATA_WAFM_117,	
	CATA_WAFM_116};
uchar PatMap2x1[] = {
	2, 1, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_2_RU_WALL, 

	CATA_WAFM_118,	CATA_WAFM_119};
uchar PatMap2x2_2[] = {
	2, 2, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	CATA_WAFM_120, CATA_WAFM_122, 
	CATA_WAFM_121, CATA_WAFM_123};
uchar PatMap1x2_0[] = {
	1, 2, 

	CATA_WAFM_1_LU_WALL, 
	CATA_WAFM_1_LU_WALL, 

	CATA_WAFM_125,	
	CATA_WAFM_124};
uchar PatMap2x1_0[] = {
	2, 1, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_2_RU_WALL, 

	CATA_WAFM_126,	CATA_WAFM_127};
uchar PatMap2x2_3[] = {
	2, 2, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	CATA_WAFM_128, CATA_WAFM_130, 
	CATA_WAFM_129, CATA_WAFM_131};
uchar PatMap2x2_4[] = {
	2, 2, 

	CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	CATA_WAFM_1_LU_WALL, CATA_WAFM_3_FLOOR, 

	CATA_WAFM_133, CATA_WAFM_135, 
	CATA_WAFM_132,	CATA_WAFM_134};
uchar PatMap2x2_5[] = {
	2, 2, 

	CATA_WAFM_2_RU_WALL, CATA_WAFM_2_RU_WALL, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	CATA_WAFM_136, CATA_WAFM_137,
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR};
uchar PatMap1x1_0[] = {1, 1, CATA_WAFM_1_LU_WALL, CATA_WAFM_80	};
uchar PatMap1x1_1[] = {1, 1, CATA_WAFM_1_LU_WALL, CATA_WAFM_81	};
uchar PatMap1x1_2[] = {1, 1, CATA_WAFM_1_LU_WALL, CATA_WAFM_82	};
uchar PatMap1x1_3[] = {1, 1, CATA_WAFM_2_RU_WALL,	CATA_WAFM_84	};
uchar PatMap1x1_4[] = {1, 1, CATA_WAFM_2_RU_WALL,	CATA_WAFM_85	};
uchar PatMap1x1_5[] = {1, 1, CATA_WAFM_2_RU_WALL,	CATA_WAFM_86	};
uchar PatMap1x1_6[] = {1, 1, CATA_WAFM_8_CORNER,	CATA_WAFM_87	};
uchar PatMap5x3[] = {
	5, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	0, 0, 0, 0, 0, 
	0, 0, CATA_WAFM_108, 0, 0, 
	0, 0, 0, 0, 0};
uchar PatMap5x3_0[] = {
	5, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 
	CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, CATA_WAFM_3_FLOOR, 

	0, 0, 0, 0, 0, 
	0, 0, CATA_WAFM_110, 0, 0, 
	0, 0, 0, 0, 0};
uchar PatMap3x3_1[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_9_CORNER, 0, 

	0,	CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_1_LU_WALL, 0, 
	0, 0, 0};
uchar PatMap3x3_2[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_8_CORNER, 0, 

	0,	CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_1_LU_WALL, 0,
	0, 0, 0};
uchar PatMap3x3_3[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_6_CORNER, 0, 

	0,	CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_1_LU_WALL, 0, 
	0, 0, 0};
uchar PatMap3x3_4[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_7_CORNER, 0, 

	0,	CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_1_LU_WALL, 0, 
	0, 0, 0};
uchar PatMap3x3_5[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_15_CORNER, 0, 

	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_1_LU_WALL, 0, 
	0, 0, 0};
uchar PatMap3x3_6[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_13_CORNER, 0, 

	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_1_LU_WALL, 0, 
	0, 0, 0};
uchar PatMap3x3_7[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_16_CORNER, 0, 

	0, CATA_WAFM_4_LU_ODOOR, 0,
	0, CATA_WAFM_1_LU_WALL, 0, 
	0, 0, 0};
uchar PatMap3x3_8[] = {
	3, 3, 

	CATA_WAFM_3_FLOOR, CATA_WAFM_1_LU_WALL,	CATA_WAFM_3_FLOOR, 
	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_14_CORNER, 0, 

	0, CATA_WAFM_4_LU_ODOOR, 0, 
	0, CATA_WAFM_1_LU_WALL, 0, 
	0, 0, 0};

int MinCataHallSize = 2;
int BigCataHallSize	= 10;
int MediumCataHallSize	= 4;
int SomeRowArray[5] = {0, 0, 1, 0,-1};
int SomeColArray[5] = {0,-1, 0, 1, 0};
//================================================================
char CaveLinkedFloorCheckMap[ 40 ][ 40 ];
int LinkedFloorTilesCount;// временная карта используемая для проверки связанности бинарного паттерна
char MaybeHasLavaTiles;
int MapSize;// только присваивается 112, но не используется

uchar CaveOrientedWallsAndCorner[] = {
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_11_CORNER_IN_UP, CAVE_WAFM_3_CORNER_IN_RIGHT, CAVE_WAFM_10_SWALL_M_MIDLE, 
	CAVE_WAFM_1_CORNER_IN_LEFT, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_12_CORNER_IN_UP, CAVE_WAFM_12_CORNER_IN_UP, 
	CAVE_WAFM_6_CORNER_IN_DOWN, CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_4_WALL_IN_RD, CAVE_WAFM_13_CORNER_IN_RIGHT, 
	CAVE_WAFM_2_WALL_IN_LD, CAVE_WAFM_14_CORNER_IN_LEFT,	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_7_FLOOR};
uchar PatMap3x3_48A3E8_CaveDungeonEnterToUp[] = {
	3, 3, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_8_BEYOND,	0, 
	CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_10_SWALL_M_MIDLE, 0, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 0, 
	
	CAVE_WAFM_51_ENTER_TO_UP, CAVE_WAFM_50_ENTER_TO_UP,	0, 
	CAVE_WAFM_48_ENTER_TO_UP, CAVE_WAFM_49_ENTER_TO_UP, 0, 
	0, 0, 0};
uchar PatMap3x3_48A400_AbyssDungeonEnterToUp[] = {
	3, 3, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_8_BEYOND,	0, 
	CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_10_SWALL_M_MIDLE, 0, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 0, 
	
	CAVE_WAFM_20_LAVA_RIVER_CORNER, CAVE_WAFM_19_LAVA_RIVER_CORNER,	0, 
	CAVE_WAFM_17_LAVA_RIVER_HORIZ_1,	CAVE_WAFM_18_LAVA_RIVER_HORIZ_2, 0, 
	0, 0, 0};
uchar PatMap3x3_48A418_CaveDungeonEnterToDown[] = {
	3, 3, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_7_FLOOR, 
	0, 0, 0, 

	0, CAVE_WAFM_47_ENTER_TO_DOWN, 0, 
	0, CAVE_WAFM_46_ENTER_TO_DOWN, 0, 
	0, 0, 0};
uchar PatMap3x3_48A430_AbyssDungeonEnterToDown[] = {
	CAVE_WAFM_3_CORNER_IN_RIGHT, CAVE_WAFM_3_CORNER_IN_RIGHT, CAVE_WAFM_8_BEYOND, 
	CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_7_FLOOR, CAVE_WAFM_8_BEYOND, 
	CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_7_FLOOR, 0, 
	
	0, 0, 0, 
	16, 0, 0, 
	15, 0, 0};
uchar PatMap3x3_48A448_CaveDungeonEnterToTown[] = {
	3, 3, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_8_BEYOND,	0, 
	CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_10_SWALL_M_MIDLE, 0, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 0, 
	
	CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER, CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER, 0, 
	CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER, CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER, 0, 
	0, 0, 0};
uchar PatMap3x3_48A460_AbyssDungeonEnterToTown[] = {
	3, 3, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_8_BEYOND,	0, 
	CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_10_SWALL_M_MIDLE, 0,
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 0, 
	
	CAVE_WAFM_24_LAVA_FROM_WALL, CAVE_WAFM_23_LAVA_FROM_WALL,	0, 
	CAVE_WAFM_21_LAVA_RIVER_CORNER,	CAVE_WAFM_22_LAVA_RIVER_CORNER, 0, 
	0, 0, 0};
uchar PatMap11x11_48A678_AnvilOfFuryPattern[] = {
	11, 11, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,

	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0, 
	0,	0,	CAVE_WAFM_29_LAVA,	CAVE_WAFM_26_LAVA,	CAVE_WAFM_26_LAVA,	CAVE_WAFM_26_LAVA,	CAVE_WAFM_26_LAVA,	CAVE_WAFM_26_LAVA,	CAVE_WAFM_30_LAVA,	0,	0,	
	0,	CAVE_WAFM_29_LAVA,	CAVE_WAFM_34_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_37_LAVA,	CAVE_WAFM_36_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_35_LAVA,	CAVE_WAFM_30_LAVA,	0,	
	0,	CAVE_WAFM_25_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_37_LAVA,	CAVE_WAFM_27_LAVA,	CAVE_WAFM_32_LAVA,	CAVE_WAFM_31_LAVA,	CAVE_WAFM_36_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_28_LAVA,	0,	
	0,	CAVE_WAFM_25_LAVA,	CAVE_WAFM_37_LAVA,	CAVE_WAFM_32_LAVA,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_31_LAVA,	CAVE_WAFM_27_LAVA,	CAVE_WAFM_32_LAVA,	0,	
	0,	CAVE_WAFM_25_LAVA,	CAVE_WAFM_28_LAVA,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_2_WALL_IN_LD,	CAVE_WAFM_2_WALL_IN_LD,	CAVE_WAFM_2_WALL_IN_LD,	0,	
	0,	CAVE_WAFM_25_LAVA,	CAVE_WAFM_35_LAVA,	CAVE_WAFM_30_LAVA,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_7_FLOOR,	CAVE_WAFM_29_LAVA,	CAVE_WAFM_26_LAVA,	CAVE_WAFM_30_LAVA,	0,	
	0,	CAVE_WAFM_25_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_35_LAVA,	CAVE_WAFM_26_LAVA,	CAVE_WAFM_30_LAVA,	CAVE_WAFM_29_LAVA,	CAVE_WAFM_34_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_28_LAVA,	0,	
	0,	CAVE_WAFM_31_LAVA,	CAVE_WAFM_36_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_35_LAVA,	CAVE_WAFM_34_LAVA,	CAVE_WAFM_33_LAVA,	CAVE_WAFM_37_LAVA,	CAVE_WAFM_32_LAVA,	0,	
	0,	0,	CAVE_WAFM_31_LAVA,	CAVE_WAFM_27_LAVA,	CAVE_WAFM_27_LAVA,	CAVE_WAFM_27_LAVA,	CAVE_WAFM_27_LAVA,	CAVE_WAFM_27_LAVA,	CAVE_WAFM_32_LAVA,	0,	0,	
	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0
};

uchar PatMap9x9_IzualPattern[] = {
	9, 9, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 
	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 	7, 

	0, 	0, 	0, 	0, 	0, 	0, 	0, 	0, 	0, 
	0, 	5, 	2, 	2, 	2, 	2, 	2, 	14, 	0, 
	0, 	4, 	11, 	40, 	42, 	39, 	3, 	9, 	0, 
	0, 	4, 	16, 	0, 	0, 	0, 	4, 	34, 	0, 
	0, 	4, 	15, 	0, 	142, 	0, 	4, 	37, 	0, 
	0, 	4, 	36, 	0, 	0, 	0, 	13, 	12, 	0, 
	0, 	4, 	1, 	2, 	2, 	14, 	0, 	0, 	0, 
	0, 	13, 	40, 	41, 	47, 	12, 	0, 	143, 	0, 
	0, 	0, 	141, 	0, 	0, 	0, 	0, 	0, 	0
};

uchar PatMap4x4_48A478_STALAGMIT_1[] = {
	4, 4, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 0, 
	0, CAVE_WAFM_57_STALAGMIT_1, CAVE_WAFM_58_STALAGMIT_1, 0, 
	0, CAVE_WAFM_56_STALAGMIT_1,	CAVE_WAFM_55_STALAGMIT_1, 0, 
	0, 0, 0, 0, 0};
uchar PatMap4x4_48A4A0_STALAGNAT_1[] = {
	4, 4, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 0, 
	0, CAVE_WAFM_61_STALAGNAT_1, CAVE_WAFM_62_STALAGNAT_1, 0, 
	0, CAVE_WAFM_60_STALAGNAT_1,	CAVE_WAFM_59_STALAGNAT_1, 0, 
	0, 0, 0, 0, 0};
uchar PatMap4x4_48A4C8_STALAGNAT_2[] = {
	4, 4, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 0, 
	0, CAVE_WAFM_65_STALAGNAT_2, CAVE_WAFM_66_STALAGNAT_2, 0, 
	0, CAVE_WAFM_64_STALAGNAT_2,	CAVE_WAFM_63_STALAGNAT_2, 0, 
	0, 0, 0, 0, 0};
uchar PatMap5x4_48A4F0_STALAGNAT_3[] = {
	5, 4, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,0,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,0,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 0, 0, 
	0, CAVE_WAFM_77_STALAGNAT_3,	CAVE_WAFM_78_STALAGNAT_3, 0, 0, 
	0, CAVE_WAFM_76_STALAGNAT_3, CAVE_WAFM_74_STALAGNAT_3, CAVE_WAFM_75_STALAGNAT_3, 0, 
	0, 0, 0, 0, 0};
uchar PatMap4x5_48A520_STALAGNAT_4[] = {
	4, 5, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,0,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 0, 
	0, CAVE_WAFM_83_STALAGNAT_4, 0, 0, 
	0, CAVE_WAFM_82_STALAGNAT_4,	CAVE_WAFM_80_STALAGNAT_4, 0, 
	0, CAVE_WAFM_81_STALAGNAT_4, CAVE_WAFM_79_STALAGNAT_4, 0, 
	0, 0, 0, 0};
uchar PatMap3x3_48A550_STALAGMIT_2[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 
	0, CAVE_WAFM_52_STALAGMIT_2, 0, 
	0, 0, 0};
uchar PatMap3x3_48A568_STALAGMIT_3[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR, 
	
	0, 0, 0, 
	0, CAVE_WAFM_53_STALAGMIT_3, 0, 
	0, 0, 0};
uchar PatMap3x3_48A580_STALAGMIT_4[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 
	0, CAVE_WAFM_54_STALAGMIT_4, 0, 
	0, 0, 0};
uchar PatMap3x3_48A598_STALAGMIT_5[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 
	0, CAVE_WAFM_67_STALAGMIT_5, 0, 
	0, 0, 0};
uchar PatMap2x1_48A5B0_STALAGNAT_ON_WALL_1[] = {
	2, 1, 
	CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_7_FLOOR,	

	CAVE_WAFM_68_STALAGNAT_ON_WALL_1, 0};
uchar PatMap1x2_48A5B8_STALAGNAT_ON_WALL_2[] = {
	1, 2, 
	CAVE_WAFM_10_SWALL_M_MIDLE, 
	CAVE_WAFM_7_FLOOR, 
	
	CAVE_WAFM_69_STALAGNAT_ON_WALL_2, 
	0};
uchar PatMap2x1_48A5C0_CRACK_IN_WALL_1[] = {
	2, 1, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_7_FLOOR,	
	
	CAVE_WAFM_84_CRACK_IN_WALL_1, CAVE_WAFM_85_CRACK_IN_WALL_1};
uchar PatMap2x1_48A5C8_CRACK_IN_WALL_2[] = {
	2, 1, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_11_CORNER_IN_UP, 
	
	CAVE_WAFM_86_CRACK_IN_WALL_2, CAVE_WAFM_87_CRACK_IN_WALL_2};
uchar PatMap1x2_48A5D0_CRACK_IN_WALL_3[] = {
	1, 2, 
	CAVE_WAFM_8_BEYOND,
	CAVE_WAFM_10_SWALL_M_MIDLE, 
	
	CAVE_WAFM_89_CRACK_IN_WALL_3, 
	CAVE_WAFM_88_CRACK_IN_WALL_3};
uchar PatMap2x1_48A5D8_CRACK_IN_WALL_4[] = {
	2, 1, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_7_FLOOR,

	CAVE_WAFM_90_CRACK_IN_WALL_4, CAVE_WAFM_91_CRACK_IN_WALL_4};
uchar PatMap1x2_48A5E0_CRACK_IN_WALL_5[] = {
	1, 2, 
	CAVE_WAFM_8_BEYOND, 
	CAVE_WAFM_11_CORNER_IN_UP, 
	
	CAVE_WAFM_92_CRACK_IN_WALL_5, 
	CAVE_WAFM_93_CRACK_IN_WALL_5};
uchar PatMap1x2_48A5E8_CRACK_IN_WALL_6[] = {
	1, 2, 
	CAVE_WAFM_8_BEYOND, 
	CAVE_WAFM_10_SWALL_M_MIDLE, 
	
	CAVE_WAFM_95_CRACK_IN_WALL_6,
	CAVE_WAFM_94_CRACK_IN_WALL_6};
uchar PatMap2x1_48A5F0_CRACK_IN_WALL_7[] = {
	2, 1, 
	CAVE_WAFM_8_BEYOND, CAVE_WAFM_7_FLOOR,	

	CAVE_WAFM_96_CRACK_IN_WALL_7, CAVE_WAFM_101_CRACK_IN_WALL_7};
uchar PatMap1x2_48A5F8_CRACK_IN_WALL_8[] = {
	1, 2, 
	CAVE_WAFM_2_WALL_IN_LD, 
	CAVE_WAFM_8_BEYOND, 
	
	CAVE_WAFM_102_CRACK_IN_WALL_8, 
	CAVE_WAFM_97_CRACK_IN_WALL_8};
uchar PatMap2x1_48A600_CRACK_IN_WALL_9[] = {
	2, 1, 
	CAVE_WAFM_3_CORNER_IN_RIGHT, CAVE_WAFM_8_BEYOND,	
	
	CAVE_WAFM_103_CRACK_IN_WALL_9, CAVE_WAFM_98_CRACK_IN_WALL_9};
uchar PatMap2x1_48A608_CRACK_IN_WALL_10[] = {
	2, 1, 
	CAVE_WAFM_4_WALL_IN_RD, CAVE_WAFM_8_BEYOND,	
	
	CAVE_WAFM_104_CRACK_IN_WALL_10, CAVE_WAFM_99_CRACK_IN_WALL_10};
uchar PatMap1x2_48A610_CRACK_IN_WALL_11[] = {
	1, 2, 
	CAVE_WAFM_6_CORNER_IN_DOWN, 
	CAVE_WAFM_8_BEYOND,	
	
	CAVE_WAFM_105_CRACK_IN_WALL_11, 
	CAVE_WAFM_100_CRACK_IN_WALL_11};
uchar PatMap2x3_48A618[] = {
	2, 3, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_4_WALL_IN_RD, 	CAVE_WAFM_9_SWALL_UNM_MIDDLE,	
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_12_CORNER_IN_UP, 
	
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR};
uchar PatMap3x2_48A628[] = {
	3, 2, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_2_WALL_IN_LD,	CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_12_CORNER_IN_UP, 
	
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR};
uchar PatMap2x3_48A638[] = {
	2, 3, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_4_WALL_IN_RD, CAVE_WAFM_9_SWALL_UNM_MIDDLE,	
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_12_CORNER_IN_UP, 
	
	CAVE_WAFM_29_LAVA, CAVE_WAFM_30_LAVA, 
	CAVE_WAFM_25_LAVA, CAVE_WAFM_28_LAVA, 
	CAVE_WAFM_31_LAVA, CAVE_WAFM_32_LAVA};
uchar PatMap3x2_48A648[] = {
	3, 2, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_2_WALL_IN_LD,	CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_12_CORNER_IN_UP, 
	
	CAVE_WAFM_29_LAVA, CAVE_WAFM_26_LAVA, CAVE_WAFM_30_LAVA, 
	CAVE_WAFM_31_LAVA, CAVE_WAFM_27_LAVA,	CAVE_WAFM_32_LAVA};
uchar PatMap2x2_48A658[] = {
	2, 2, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_12_CORNER_IN_UP, 
	
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR};
uchar PatMap1x1_48A664_FLOOR_VARIATION_1[] = {1, 1, CAVE_WAFM_7_FLOOR, CAVE_WAFM_106_FLOOR_VARIATION_1	 };
uchar PatMap1x1_48A668_FLOOR_VARIATION_2[] = {1, 1, CAVE_WAFM_7_FLOOR, CAVE_WAFM_107_FLOOR_VARIATION_2	 };
uchar PatMap1x1_48A66C_FLOOR_VARIATION_3[] = {1, 1, CAVE_WAFM_7_FLOOR, CAVE_WAFM_108_FLOOR_VARIATION_3	 };
uchar PatMap1x1_48A670_SWALL_UNM_MIDDLE_VARIATION[] = {1, 1, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_109_SWALL_UNM_MIDDLE_VARIATION	 };
uchar PatMap1x1_48A674_SWALL_M_MIDLE_VARIATION[] = {1, 1, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_110_SWALL_M_MIDLE_VARIATION	 };

// дальше бездновые шаблоны

uchar PatMap1x1_48A76C_ABYSS[] = {1, 1, CAVE_WAFM_8_BEYOND, CAVE_WAFM_25_LAVA	 };
uchar PatMap1x1_48A770_ABYSS[] = {1, 1, CAVE_WAFM_8_BEYOND, CAVE_WAFM_26_LAVA	 };
uchar PatMap1x1_48A774_ABYSS[] = {1, 1, CAVE_WAFM_8_BEYOND, CAVE_WAFM_27_LAVA	 };
uchar PatMap1x1_48A778_ABYSS[] = {1, 1, CAVE_WAFM_8_BEYOND, CAVE_WAFM_28_LAVA	 };
uchar PatMap1x1_48A77C_ABYSS[] = {1, 1, CAVE_WAFM_7_FLOOR, CAVE_WAFM_29_LAVA	 };
uchar PatMap1x1_48A780_ABYSS[] = {1, 1, CAVE_WAFM_7_FLOOR, CAVE_WAFM_30_LAVA	 };
uchar PatMap1x1_48A784_ABYSS[] = {1, 1, CAVE_WAFM_7_FLOOR, CAVE_WAFM_31_LAVA	 };
uchar PatMap1x1_48A788_ABYSS[] = {1, 1, CAVE_WAFM_7_FLOOR, CAVE_WAFM_32_LAVA	};
uchar PatMap3x3_48A790_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	0, 0, 0, 
	0, CAVE_WAFM_126_M_STONE_WITH_WOOD_MIDDLE, 0, 
	0, 0, 0};
uchar PatMap3x3_48A7A8_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR, 
	
	0, 0, 0, 
	0, CAVE_WAFM_124_UNM_STONE_WITH_WOOD_MIDDLE_BROKEN, 0, 
	0, 0, 0};
uchar PatMap1x1_48A7BC_ABYSS[] = {1, 1, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_33_LAVA	 };
uchar PatMap1x1_48A7C0_ABYSS[] = {1, 1, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_34_LAVA	 };
uchar PatMap1x1_48A7C4_ABYSS[] = {1, 1, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_35_LAVA	 };
uchar PatMap1x1_48A7C8_ABYSS[] = {1, 1, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_36_LAVA	 };
uchar PatMap1x1_48A7CC_ABYSS[] = {1, 1, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_37_LAVA	 };
uchar PatMap1x1_48A7D0_ABYSS[] = {1, 1, CAVE_WAFM_11_CORNER_IN_UP, CAVE_WAFM_38_LAVA	 };
uchar PatMap1x1_48A7D4_ABYSS[] = {1, 1, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_39_LAVA	 };
uchar PatMap1x1_48A7D8_ABYSS[] = {1, 1, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_40_LAVA	 };
uchar PatMap1x1_48A7DC_ABYSS[] = {1, 1, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_41_LAVA	 };
uchar PatMap1x1_48A7E0_ABYSS[] = {1, 1, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_42_LAVA_FROM_WALL	 };
uchar PatMap1x1_48A7E4_ABYSS[] = {1, 1, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_43_LAVA_FROM_WALL	 };
uchar PatMap1x1_48A7E8_ABYSS[] = {1, 1, CAVE_WAFM_11_CORNER_IN_UP, CAVE_WAFM_44_LAVA_RIVER_VERT_PASSING	 };
uchar PatMap1x1_48A7EC_ABYSS[] = {1, 1, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_45_LAVA_RIVER_HORIZ_PASSING	 };
uchar PatMap1x1_48A7F0_ABYSS[] = {1, 1, CAVE_WAFM_9_SWALL_UNM_MIDDLE, CAVE_WAFM_46_ENTER_TO_DOWN	 };
uchar PatMap1x1_48A7F4_ABYSS[] = {1, 1, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_47_ENTER_TO_DOWN	 };
uchar PatMap1x1_48A7F8_ABYSS[] = {1, 1, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_48_ENTER_TO_UP	 };
uchar PatMap1x1_48A7FC_ABYSS[] = {1, 1, CAVE_WAFM_11_CORNER_IN_UP, CAVE_WAFM_49_ENTER_TO_UP	 };
uchar PatMap1x1_48A800_ABYSS[] = {1, 1, CAVE_WAFM_11_CORNER_IN_UP, CAVE_WAFM_50_ENTER_TO_UP};
uchar PatMap3x3_48A808_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,

	67, 0, 0,
	66, 51, 0,
	0, 0, 0};
uchar PatMap3x3_48A820_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,	
	
	69, 0, 0, 
	68, 52, 0, 
	0, 0, 0};
uchar PatMap3x3_48A838_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,	
	
	70, 0, 0, 
	71, 53, 0, 
	0, 0, 0};
uchar PatMap3x3_48A850_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,	
	
	73, 0, 0, 
	72, 54, 0, 
	0, 0, 0};
uchar PatMap3x3_48A868_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,	
	
	75, 0, 0, 
	74, 55, 0,
	0, 0, 0};
uchar PatMap3x3_48A880_ABYSS[] = {3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,	
	
	77, 0, 0,
	76, 56, 0, 
	0, 0, 0};
uchar PatMap3x3_48A898_ABYSS[] = {
	3, 3,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,	
	
	79, 0, 0, 
	78, 57, 0, 
	0, 0, 0};
uchar PatMap3x3_48A8B0_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,	
	
	81, 0, 0,
	80, 58, 0, 
	0, 0, 0};
uchar PatMap3x3_48A8C8_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,	
	
	83, 0, 0, 
	82, 59, 0, 
	0, 0, 0};
uchar PatMap3x3_48A8E0_ABYSS[] = {
	3, 3, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	84, 0, 0, 
	85, 60, 0, 
	0, 0, 0};
uchar PatMap2x3_48A8F8_ABYSS[] = {
	2, 3, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_4_WALL_IN_RD, CAVE_WAFM_9_SWALL_UNM_MIDDLE,	
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_12_CORNER_IN_UP, 
	
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR};
uchar PatMap3x2_48A908_ABYSS[] = {
	3, 2, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_2_WALL_IN_LD,	CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_12_CORNER_IN_UP, 
	
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR};
uchar PatMap2x3_48A918_ABYSS[] = {
	2, 3, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_4_WALL_IN_RD, CAVE_WAFM_9_SWALL_UNM_MIDDLE,	
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_12_CORNER_IN_UP, 
	
	107, 115, 
	119, 122, 
	131, 123};
uchar PatMap3x2_48A928_ABYSS[] = {
	3, 2, 
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_2_WALL_IN_LD,	CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_10_SWALL_M_MIDLE, CAVE_WAFM_12_CORNER_IN_UP, 
	
	107, 120, 115, 
	131, 121,	123};
uchar PatMap2x2_48A938_ABYSS[] = {
	2, 2,
	CAVE_WAFM_5_CORNER_IN_DOWN, CAVE_WAFM_14_CORNER_IN_LEFT, 
	CAVE_WAFM_13_CORNER_IN_RIGHT, CAVE_WAFM_12_CORNER_IN_UP, 
	
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_7_FLOOR, CAVE_WAFM_7_FLOOR};
uchar PatMap4x4_48A948_ABYSS[] = {
	4, 4, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	7,7,7,7,
	7, 107, 115, 7, 
	7, 131, 123, 7, 
	7, 7, 7, 7};
uchar PatMap4x4_48A970_ABYSS[] = {
	4, 4, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	7,7,7,7,
	7,7, 108, 7, 
	7, 109, 112, 7, 
	7,7,7,7};
uchar PatMap4x5_48A998_ABYSS[] = {
	4, 5, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	7,7,7,7,
	7, 107, 115, 7, 
	7, 119, 122, 7, 
	7, 131,	123, 7, 
	7, 7, 7, 7};
uchar PatMap4x5_48A9C8_ABYSS[] = {
	4, 5, 
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,CAVE_WAFM_7_FLOOR,
	
	7,7,7,7,
	7, 126, 108, 7, 
	7, 7, 117, 7, 
	7, 109,	112, 7, 
	7,7,7,7};

// 0x0048A9F8
uchar CaveLavaFlags[] = {
	0, 
	BIT(2)|BIT(4), 
	BIT(1)|BIT(2)|BIT(7), 
	BIT(1)|BIT(3),
	BIT(3)|BIT(4)|BIT(6),
	BIT(2)|BIT(3), 
	BIT(1)|BIT(4),
	0, 
	0, 
	BIT(3)|BIT(4)|BIT(5),  
	BIT(1)|BIT(2)|BIT(8), 
	BIT(2)|BIT(3), 
	BIT(1)|BIT(4),
	BIT(2)|BIT(4),
	BIT(1)|BIT(3),
	0		
};

// 0x0048AA08
uchar CaveLavaFlags2[] = {
	0, 
	BIT(2)|BIT(4), 
	BIT(1)|BIT(2), 
	BIT(1)|BIT(3), 
	BIT(3)|BIT(4), 
	BIT(2)|BIT(3), 
	BIT(1)|BIT(4), 
	0, 
	0, 
	BIT(3)|BIT(4), 
	BIT(1)|BIT(2), 
	BIT(2)|BIT(3), 
	BIT(1)|BIT(4),
	BIT(2)|BIT(4), 
	BIT(1)|BIT(3), 
	0			
};

uchar CaveLavaMakingArray[] = {
	0, 
	CAVE_WAFM_35_LAVA, 
	CAVE_WAFM_26_LAVA, 
	CAVE_WAFM_36_LAVA, 
	CAVE_WAFM_25_LAVA, 
	CAVE_WAFM_29_LAVA,	
	CAVE_WAFM_34_LAVA, 
	CAVE_WAFM_7_FLOOR,	
	CAVE_WAFM_33_LAVA, 
	CAVE_WAFM_28_LAVA, 
	CAVE_WAFM_27_LAVA, 
	CAVE_WAFM_37_LAVA, 
	CAVE_WAFM_32_LAVA,	
	CAVE_WAFM_31_LAVA, 
	CAVE_WAFM_30_LAVA, 
	0, 
	0, 
	CAVE_WAFM_133_WOOD_WALL_CORNER_M_STONE_UNM_WOOD, 
	CAVE_WAFM_120, 
	CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER, 
	CAVE_WAFM_119,	
	CAVE_WAFM_107_FLOOR_VARIATION_2, 
	CAVE_WAFM_132_WOOD_WALL_CORNER_UNM_STONE_M_WOOD, 
	CAVE_WAFM_7_FLOOR, 
	CAVE_WAFM_134_WOOD_WALL_M_MIDDLE, 
	CAVE_WAFM_122_UNM_STONE_WITH_WOOD_DOWN_END,	
	CAVE_WAFM_121_UNM_STONE_WITH_WOOD_MIDDLE, 
	CAVE_WAFM_118, 
	CAVE_WAFM_123_UNM_STONE_WITH_WOOD_UP_END, 
	CAVE_WAFM_131_WOOD_WALL_CORNER_M_STONE_UNM_WOOD, 
	CAVE_WAFM_115, 
	0
};

//============================================================

uchar BinaryHellMap[ 20 ][ 20 ];
char InitalHellWallScheme[ 80 ][ 80 ];
int Map40x40gStartRow;
int Map40x40gEndRow;
int Map40x40gStartCol;
int Map40x40gEndCol;
int MapXOffset;
int MapYOffset;

uchar HellOrientedWallsAndCorner[] = {
	HELL_WAFM_30_BEYOND, HELL_WAFM_6_FLOOR, HELL_WAFM_1, HELL_WAFM_6_FLOOR, 
	HELL_WAFM_2, HELL_WAFM_6_FLOOR, HELL_WAFM_6_FLOOR, HELL_WAFM_6_FLOOR, 
	HELL_WAFM_9, HELL_WAFM_6_FLOOR, HELL_WAFM_1,	HELL_WAFM_6_FLOOR, 
	HELL_WAFM_2, HELL_WAFM_6_FLOOR, HELL_WAFM_3, HELL_WAFM_6_FLOOR};
uchar PatMap4x5_48AA48_HellDungeonEnterToUp[] = {
	4, 5, 
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,

	0, 0, 0, 0,	
	HELL_WAFM_36_ENTER_TO_UP, HELL_WAFM_38_ENTER_TO_UP, HELL_WAFM_35_ENTER_TO_UP, 0, 
	HELL_WAFM_37_ENTER_TO_UP, HELL_WAFM_34_ENTER_TO_UP, HELL_WAFM_33_ENTER_TO_UP,	HELL_WAFM_32_ENTER_TO_UP, 
	0, 0, HELL_WAFM_31_ENTER_TO_UP, 0, 
	0, 0, 0, 0};
uchar PatMap4x5_48AA78_HellDungeonEnterToTown[] = {
	4, 5, 
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR, 

	0, 0, 0, 0,	
	HELL_WAFM_134_ENTER_TO_TOWN, HELL_WAFM_136_ENTER_TO_TOWN, HELL_WAFM_133_ENTER_TO_TOWN, 0, 
	HELL_WAFM_135_ENTER_TO_TOWN, HELL_WAFM_132_ENTER_TO_TOWN, HELL_WAFM_131_ENTER_TO_TOWN,HELL_WAFM_130_ENTER_TO_TOWN,
	0, 0, HELL_WAFM_129_ENTER_TO_TOWN, 0, 
	0, 0, 0, 0};
uchar PatMap5x5_48AAA8_HellDungeonEnterToDown[] = {
	5, 5, 

	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR, 

	0, 0, 0, 0, 0, 
	0, 0, HELL_WAFM_45_ENTER_TO_DOWN, HELL_WAFM_41_ENTER_TO_DOWN, 0, 
	0, HELL_WAFM_44_ENTER_TO_DOWN,	HELL_WAFM_43_ENTER_TO_DOWN, HELL_WAFM_40_ENTER_TO_DOWN, 0, 
	0, 	HELL_WAFM_46_ENTER_TO_DOWN, HELL_WAFM_42_ENTER_TO_DOWN, HELL_WAFM_39_ENTER_TO_DOWN, 0, 
	0, 	0, 0, 0, 0};
uchar PatMap5x5_48AAE0_PandemiumEnterDesactivated[] = {
	5, 5, 
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR, 

	0, 0, 0, 0, 0, 
	0, HELL_WAFM_98_PANDEMIUM_ENTER_DEACTIVATED, HELL_WAFM_100_PANDEMIUM_ENTER_DEACTIVATED, HELL_WAFM_103_PANDEMIUM_ENTER_DEACTIVATED, 0, 
	0, HELL_WAFM_99_PANDEMIUM_ENTER_DEACTIVATED,	HELL_WAFM_102_PANDEMIUM_ENTER_DEACTIVATED, HELL_WAFM_105_PANDEMIUM_ENTER_DEACTIVATED, 0, 
	0, HELL_WAFM_101_PANDEMIUM_ENTER_DEACTIVATED, HELL_WAFM_104_PANDEMIUM_ENTER_DEACTIVATED, HELL_WAFM_106_PANDEMIUM_ENTER_DEACTIVATED, 0, 
	0, 0, 0, 0, 0};
uchar PatMap5x5_48AB18_PandemiumEnterActivated[] = {
	5, 5, 
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,
	HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR,HELL_WAFM_6_FLOOR, 

	0, 0, 0, 0, 0, 
	0, HELL_WAFM_107_PANDEMIUM_ENTER_ACTIVATED, HELL_WAFM_109_PANDEMIUM_ENTER_ACTIVATED, HELL_WAFM_112_PANDEMIUM_ENTER_ACTIVATED, 0, 
	0, HELL_WAFM_108_PANDEMIUM_ENTER_ACTIVATED,	HELL_WAFM_111_PANDEMIUM_ENTER_ACTIVATED, HELL_WAFM_114_PANDEMIUM_ENTER_ACTIVATED, 0, 
	0, HELL_WAFM_110_PANDEMIUM_ENTER_ACTIVATED, HELL_WAFM_113_PANDEMIUM_ENTER_ACTIVATED, HELL_WAFM_115_PANDEMIUM_ENTER_ACTIVATED, 0, 
	0, 0, 0, 0, 0};
uchar HellTilesVariationsTable[] = {
	0, HELL_WAFM_1, HELL_WAFM_2, HELL_WAFM_3,	HELL_WAFM_4, HELL_WAFM_5, HELL_WAFM_6_FLOOR, HELL_WAFM_7, HELL_WAFM_8, HELL_WAFM_9, HELL_WAFM_10, HELL_WAFM_11, HELL_WAFM_12, HELL_WAFM_13, HELL_WAFM_14
	, HELL_WAFM_15,	HELL_WAFM_16, HELL_WAFM_17, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, HELL_WAFM_6_FLOOR, HELL_WAFM_6_FLOOR, HELL_WAFM_6_FLOOR, 0, 0, 0, 0, 0, 0, 0, 0, 0, HELL_WAFM_1, HELL_WAFM_2
	, HELL_WAFM_1, HELL_WAFM_2, HELL_WAFM_1, HELL_WAFM_2, HELL_WAFM_1, HELL_WAFM_1, HELL_WAFM_2, HELL_WAFM_2, 0, 0, 0, 0, 0, 0, HELL_WAFM_15, HELL_WAFM_16
	, HELL_WAFM_9, HELL_WAFM_12, HELL_WAFM_4, HELL_WAFM_5, HELL_WAFM_7, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

// ╔═════════════════════════════════════════════════════════════════════════════╗
// ║                           jmp inline chunks                                 ║
// ╚═════════════════════════════════════════════════════════════════════════════╝

// новая функция для часто встречающейся проверки
__forceinline bool IsWoodWall(uchar wafm)
{
	return InSegment(wafm, CAVE_WAFM_130_WOOD_WALL_CORNER_UNM_STONE_M_WOOD, CAVE_WAFM_152_WOOD_WALL);
}

// новая функция. Для небольшого снижения дублирования кода
__forceinline bool IsMainDiagonalNearDoorTile(uchar wafm)
{
	return  wafm == CAVE_WAFM_130_WOOD_WALL_CORNER_UNM_STONE_M_WOOD
		|| wafm == CAVE_WAFM_132_WOOD_WALL_CORNER_UNM_STONE_M_WOOD
		|| wafm == CAVE_WAFM_133_WOOD_WALL_CORNER_M_STONE_UNM_WOOD
		|| wafm == CAVE_WAFM_134_WOOD_WALL_M_MIDDLE
		|| wafm == CAVE_WAFM_136_WOOD_WALL_M_MIDDLE_BROKEN
		|| wafm == CAVE_WAFM_138_WOOD_WALL_WOOD_CORNER
		|| wafm == CAVE_WAFM_140_WOOD_WALL_BROKEN_WOOD_CORNER;
}

// новая функция. Для небольшого снижения дублирования кода
__forceinline bool IsUnmainDiagonalNearDoorTile(uchar wafm)
{
	return  wafm == CAVE_WAFM_131_WOOD_WALL_CORNER_M_STONE_UNM_WOOD
		|| wafm == CAVE_WAFM_132_WOOD_WALL_CORNER_UNM_STONE_M_WOOD
		|| wafm == CAVE_WAFM_133_WOOD_WALL_CORNER_M_STONE_UNM_WOOD
		|| wafm == CAVE_WAFM_135_WOOD_WALL_UNM_MIDDLE
		|| wafm == CAVE_WAFM_137_WOOD_WALL_UNM_MIDDLE_BROKEN
		|| wafm == CAVE_WAFM_138_WOOD_WALL_WOOD_CORNER
		|| wafm == CAVE_WAFM_139_WOOD_WALL_BROKEN_WOOD_CORNER;
}

// ╔═════════════════════════════════════════════════════════════════════════════╗
// ║                           end of inline	                                 ║
// ╚═════════════════════════════════════════════════════════════════════════════╝

//----- (0040BA48) --------------------------------------------------------
void ClearObjectMaps()
{
	memset( FlagMap, 0, sizeof FlagMap );
	memset( PlayerMap, 0, sizeof PlayerMap );
	memset( MonsterMap, 0, sizeof MonsterMap );
	memset( DeathMonstersMap, 0, sizeof DeathMonstersMap );
	memset( ObjectsMap, 0, sizeof ObjectsMap );
	memset( ItemsOnGroundMap, 0, sizeof ItemsOnGroundMap );
	memset( MissilesMap, 0, sizeof MissilesMap );
	memset( ArchGraphicsMap, 0, sizeof ArchGraphicsMap );
	int darkLevel;
	if( FullLighting ){         //  полностью освещаем уровень
		darkLevel = 0;
	}else if( NormalLighting ){ // нормальное освещение
		darkLevel = 3;
	}else{                      // полная темнота
		darkLevel = 15;
	}
	memset( LightMap, darkLevel, sizeof LightMap );
}

//----- (0040BAFD) --------------------------------------------------------
void __fastcall LoadQuestDungeonMainMapChurch(char* dunFileName, int playerRowPos, int playerColPos)
{
	MapStartRow = 16;
	MapStartCol = 16;
	MapEndRow = 96;
	MapEndCol = 96;
	ClearWallsTransparency();
	int fileSize;
	ushort* dunData = (ushort*)LoadFile(dunFileName, &fileSize);

	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			ChurchWallFlagMap[ row ][ col ] = 0;
			Map[ row ][ col ] = CHR_WAFM_22_BEYOND;
		}
	}

	ushort rowSize = dunData[0];
	ushort colSize = dunData[1];
	ushort* dunArray = &dunData[2];

	for( int col = 0; col < colSize; col++ ){
		for( int row = 0; row < rowSize; row++ ){
			ushort wallAndFloorMapValue = dunArray[row + col * rowSize];
			if( wallAndFloorMapValue ){
				ChurchWallFlagMap[ row ][ col ] |= BIT(8);
				Map[ row ][ col ] = (uchar)wallAndFloorMapValue;
			}else{
				Map[ row ][ col ] = CHR_WAFM_13_FLOOR;
			}
		}
	}

	RandomizeChurchFloorTiles();
	PlayerRowPos = playerRowPos;
	PlayerColPos = playerColPos;
	InitChurchLevelTiles();
	ClearObjectMaps();
	if( DungeonLevel < 17 ){
		InitChurchArchs();
	}else{
		InitHellfireArchs();
	}
	AddQuestMonsters((ushort*)dunData, 0, 0);
	AddQuestItems((int)dunData, 0, 0);
	FreeMem((char*)dunData);
}

//----- (0040BBF3) --------------------------------------------------------
void RandomizeChurchFloorTiles()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			if( !ChurchWallFlagMap[ row ][ col ] && Map[ row ][ col ] == CHR_WAFM_13_FLOOR ){
				switch( RangeRND(0, 3) ){
					case 1:		Map[ row ][ col ] = CHR_WAFM_162_FLOOR_2;		break;
					case 2:		Map[ row ][ col ] = CHR_WAFM_163_FLOOR_3;		break;
				}
			}
		}
	}
}

//----- (0040BC41) --------------------------------------------------------
void InitChurchLevelTiles()
{
	int v11 = 21;
	int v7 = *((ushort*)CurrentLevelTilesFile + 84) + 1;
	int v12 = *((ushort*)CurrentLevelTilesFile + 84) + 1;
	LOWORD_IDA(v7) = *((ushort*)CurrentLevelTilesFile + 85);
	++v7;
	int v13 = v7;
	LOWORD_IDA(v7) = *((ushort*)CurrentLevelTilesFile + 86);
	++v7;
	int v14 = v7;
	LOWORD_IDA(v7) = *((ushort*)CurrentLevelTilesFile + 87);
	int v15 = v7 + 1;
	int v0 = (int)&FineMap[ 0 ][ 112 ];
	do{
		int v1 = v0;
		int v2 = 56;
		do{
			*(uint*)(v1 - 448) = v12;
			*(uint*)v1 = v13;
			*(uint*)(v1 - 444) = v14;
			*(uint*)(v1 + 4) = v15;
			v1 += 896;
			--v2;
		}while( v2 );
		v0 += 8;
	}while( v0 < (int)&FineMap[ 0 ][ 224 ] );
	int v3 = 0;
	int* v16 = &FineMap[ 0 ][ 1920 ];
	do{
		int* v5 = v16;
		uchar* v4 = (unsigned char*)&Map[ 0 ][ v3 ];
		int v17 = 40;
		do{
			v11 = *v4 - 1;
			char* v8 = &CurrentLevelTilesFile[8 * v11];
			int v9 = *(ushort*)v8;
			v8 += 2;
			++v9;
			v12 = v9;
			LOWORD_IDA(v9) = *(ushort*)v8;
			v8 += 2;
			++v9;
			v13 = v9;
			LOWORD_IDA(v9) = *(ushort*)v8;
			++v9;
			v14 = v9;
			LOWORD_IDA(v9) = *((ushort*)v8 + 1);
			v15 = v9 + 1;
			v4 += 40;
			*(v5 - 112) = v12;
			*v5 = v13;
			*(v5 - 111) = v14;
			*(v5 + 1) = v15;
			v5 += 224;
		}while( v17-- != 1 );
		v16 += 2;
		++v3;
	}while( v3 < 40 );
}

// 1-16 level
//----- (0040BD33) --------------------------------------------------------
void InitChurchArchs()
{
	for( int i = 0; i < 112*112; i++ ){
		switch( FineMap[ 0 ][ i ] ){
		case 12:
		case 71:
		case 211:
		case 321:
		case 341:
		case 418:
			ArchGraphicsMap[ 0 ][ i ] = 1;
			break;
		case 11:
		case 249:
		case 325:
		case 331:
		case 344:
		case 421:
			ArchGraphicsMap[ 0 ][ i ] = 2;
			break;
		case 255:
			ArchGraphicsMap[ 0 ][ i ] = 4;
			break;
		case 259:
			ArchGraphicsMap[ 0 ][ i ] = 5;
			break;
		}
	}
}

//----- (0040BDEE) --------------------------------------------------------
void __fastcall LoadQuestDungeonAltMapChurch( char* fileName, int a2, int a3 )
{
	MapStartRow = 16;
	MapStartCol = 16;
	MapEndRow = 96;
	MapEndCol = 96;


	ushort* dunData = (ushort*)LoadFile(fileName, NULL);

	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			ChurchWallFlagMap[ row ][ col ] = 0;
			Map[ row ][ col ] = CHR_WAFM_22_BEYOND;
		}
	}
	ushort rowSize = dunData[0];
	ushort colSize = dunData[1];
	ushort* dunArray = &dunData[2];

	for( int col = 0; col < colSize; col++ ){
		for( int row = 0; row < rowSize; row++ ){
			ushort wallAndFloorMapValue = dunArray[row + col * rowSize];
			if( wallAndFloorMapValue ){
				ChurchWallFlagMap[ row ][ col ] |= BIT(8);
				Map[ row ][ col ] = (uchar)wallAndFloorMapValue;
			}else{
				Map[ row ][ col ] = CHR_WAFM_13_FLOOR;
			}
		}
	}

	RandomizeChurchFloorTiles();

	//комприлятор сам оптимизирует такое в memcpy( AltMap, Map, sizeof Map )
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			AltMap[ row ][ col ] = Map[ row ][ col ];
		}
	}
	FreeMem((char*)dunData);
}

// loadingMode == 1 start new game
//----- (0040BEB8) --------------------------------------------------------
void __fastcall CreateChurchTypeLabyrinth(int levelRandomSeed, int loadingMode)
{
	InitRandomSeed(levelRandomSeed);
	// оптимизировать генерацию уровней можно всегда
	if( true /*IsExeValidating*/ && StartLevelSeed[ DungeonLevel ] == RandomSeed && MatchLevelSeed[ DungeonLevel ] ){
		RandomSeed = MatchLevelSeed[ DungeonLevel ];
	}else{
		StartLevelSeed[ DungeonLevel ] = RandomSeed;
		MatchLevelSeed[ DungeonLevel ] = 0;
	}
	MapStartRow = 16;
	MapStartCol = 16;
	MapEndRow = 96;
	MapEndCol = 96;
	UberRow = 0;
	UberCol = 0;
	IsUberRoomOpened = 0;
	SomeDword_64 = 0;
	UberLeverRow = 0;
	UberLeverCol = 0;
	IsUberLeverActivated = 0;
	UberDiabloMonsterIndex = 0;
	ClearWallsTransparency();
	ResetPatternMapPos();
	LoadChurchQuestMaps();

	ChurchLevelGeneration(loadingMode);
	InitChurchLevelTiles();
	FreeDungeonFilePtr();
	if( DungeonLevel >= 17 ){
		InitHellfireArchs();
	}else{
		InitChurchArchs();
	}
	MarkPatternPositionOnMap();
	for( int col = MapStartCol; col < MapEndCol; ++col ){
		for( int row = MapStartRow; row < MapEndRow; ++row ){
			int cell = FineMap[ row ][ col ];
			if( cell == 290 ){
				UberRow = row;
				UberCol = col;
			}
			if( cell == 317 ){
				RowOfCornerStone = row;
				ColOfCornerStone = col;
			}
		}
	}
}

//----- (0040BFA9) --------------------------------------------------------
void LoadChurchQuestMaps()
{
	IsChurchHallDUNFileLoaded = false;// Печально. На уровне возможен только один квестовый кусок
	if( IsQuestOnLevel(Q_6_THE_BUTCHER) ){
		DUNFilePtr = (char*)LoadFile("Levels\\L1Data\\rnd7.DUN", NULL);
		IsChurchHallDUNFileLoaded = true;
	}
	if( IsQuestOnLevel(Q_12_THE_CURSE_OF_KING_LEORIC) && MaxCountOfPlayersInGame == 1 ){
		DUNFilePtr = (char*)LoadFile("Levels\\L1Data\\SKngDO.DUN", NULL);
		IsChurchHallDUNFileLoaded = true;
	}
	if( IsQuestOnLevel(Q_16_HORAZON_S_DEMONS ) ){
		DUNFilePtr = (char*)LoadFile( "Levels\\L5Data\\HorazonEntr2.DUN", NULL );
		IsChurchHallDUNFileLoaded = true;
	}
	IsQuestOnLevel(Q_7_OGDENS_SIGN);
	if( IsDrebezOnLevel() ){
		DUNFilePtr = (char*) LoadFile( "Levels\\L1Data\\Dregbez.DUN", NULL );
		IsChurchHallDUNFileLoaded = true;
	}
	if( DungeonLevel == 24 ){
		DUNFilePtr = (char*) LoadFile( "levels\\l5data\\uberoom1.dun", 0 );
		IsChurchHallDUNFileLoaded = true;
	}
	if( IsQuestOnLevel(Q_7_OGDENS_SIGN) ){
		DUNFilePtr = (char*)LoadFile("Levels\\L1Data\\Banner2.DUN", NULL);
		IsChurchHallDUNFileLoaded = true;
	}
}

//----- (0040C027) --------------------------------------------------------
void FreeDungeonFilePtr()
{
	FreeMem(DUNFilePtr);
	DUNFilePtr = 0;
}

// 17+ (hellfire)
//----- (0040C039) --------------------------------------------------------
void InitHellfireArchs()
{
	for( int i = 0; i < 112*112; i++ ){
		if( FineMap[ 0 ][ i ] == 77 ){
			ArchGraphicsMap[ 0 ][ i ] = 1;
		}else if( FineMap[ 0 ][ i ] == 80 ){
			ArchGraphicsMap[ 0 ][ i ] = 2;
		}
	}
}

// новые массивы для оптимизации генерации уровня, их можно дополнительно сохранять в запись
// тогда полная генерация будет выполняться только один раз и "подходящий" seed будет запоминаться
// захардкоденные значения проверенны для тестовой записи вручную
int StartLevelSeed[ 25 ] = {
	/*  0 */ 0, 
	/*  1 */ 0, 
	/*  2 */ 0, 
	/*  3 */ 0, 
	/*  4 */ 0, 
	/*  5 */ 0, 
	/*  6 */ 0, 
	/*  7 */ 0, 
	/*  8 */ 0, 
	/*  9 */ 0, 
	/* 10 */ 0, 
	/* 11 */ 0, 
	/* 12 */ 0, 
	/* 13 */ 1988944515,
	/* 14 */ 0, 
	/* 15 */ 0, 
	/* 16 */ 0, 
	/* 17 */ 0, 
	/* 18 */ 0, 
	/* 19 */ 0, 
	/* 20 */ 0, 
	/* 21 */ 2031806629, 
	/* 22 */ 0, 
	/* 23 */ 0, 
	/* 24 */ 0
};
int MatchLevelSeed[ 25 ] = {
	/*  0 */ 0,
	/*  1 */ 0,
	/*  2 */ 0,
	/*  3 */ 0,
	/*  4 */ 0,
	/*  5 */ 0,
	/*  6 */ 0,
	/*  7 */ 0,
	/*  8 */ 0,
	/*  9 */ 0,
	/* 10 */ 0,
	/* 11 */ 0,
	/* 12 */ 0,
	/* 13 */ 1619672838,
	/* 14 */ 0,
	/* 15 */ 0,
	/* 16 */ 0,
	/* 17 */ 0,
	/* 18 */ 0,
	/* 19 */ 0,
	/* 20 */ 0,
	/* 21 */ 423469716,
	/* 22 */ 0,
	/* 23 */ 0,
	/* 24 */ 0
};

//----- (0040C07F) --------------------------------------------------------
void __fastcall ChurchLevelGeneration(int loadingMode)
{
	int isGenerationEnd;
	int maxLevelArea;
	switch( DungeonLevel ){ //Площадь подземелья зависит от этажа
	case 1:	maxLevelArea = 533; break;
	case 2:	maxLevelArea = 693;	break;
	default:maxLevelArea = 761;	break;
	}
	do{
		//Обнуляет значения в HallMap и TransparentModes, а также устанавливает WallTransparentIndex = 1
		ClearWallsTransparency();
		//Генерация бинарного паттерна подземелья (только стены(0) и пол(1))
		//Выполняется пока не будет достигнута нужная площадь (площадь равна сумме клеток со значением 1 (пол))
		int levelSeed = 0;
		do{
			levelSeed = RandomSeed;
			ClearWallFloorMap(); //заполняем нулями карту
			ConstructChurchRooms(); //строим бинарный паттерн
		}while( AreaOfLevelRoomsChurch() < maxLevelArea );
		if( ! MatchLevelSeed[ DungeonLevel ] && StartLevelSeed[ DungeonLevel ] ){
			MatchLevelSeed[ DungeonLevel ] = levelSeed;
		}
		//Копирует бинарный паттерн 40х40 в массив 80х80 (1 клетка исходного массива заполняет 4 клетки в целевом)
		CopyChurchInitalRoomsScheme();
		InitChurchWallAndFloorMapFromBynaryPattern();
		SetupChurchHallsPassagesAndPlaceSpecialPatternsInRandomHall();
		ConvertToChurchWalls();
		bool isAntibottleNeckOn = false;
		switch( Difficulty ){
		case DL_0_HORROR:		isAntibottleNeckOn = DungeonLevel == 24;	break;
		case DL_1_PURGATORY:	isAntibottleNeckOn = DungeonLevel > 4;		break;
		case DL_2_DOOM:			isAntibottleNeckOn = true;					break;
		}
		if( !isAntibottleNeckOn ){
			ChurchMakeSomeCrossWalls();
		}
		//DumpMap((uchar*)Map, 40);
		ClearWallFlagMapBit7();
		InitChurchWallsTransparency();
		//DumpMap((uchar*)HallMap, 112);
		//ниже GeneratePatternObject расставляет специфические тайлы или целые паттерны этих тайлов, которые являются объектами:
		//лестницы между этажами, различные декорации вроде факелов и проломов в стенах и так далее.
		isGenerationEnd = 1;
		//-------Квест об отравленном источнике-------------------------------------
		if( IsQuestOnLevel(Q_13_POISONED_WATER_SUPPLY) ){
			if( loadingMode ){
				if( GenerateChurchPatternObject(PatMap6x6_WaterSupplyEnter, 1, 1, 0, 0, 0, -1, 0) < 0 ){ //вход в отравленный источник
					isGenerationEnd = 0;
				}
				--PlayerColPos;
			}else{
				if( GenerateChurchPatternObject(PatMap6x6_WaterSupplyEnter, 1, 1, 0, 0, 1, -1, 0) < 0 ){
					isGenerationEnd = 0;
				}
			}
		}
		//-------Квест об украденном знаке таверны Огдена-------------------------------------
		if( IsQuestOnLevel(Q_7_OGDENS_SIGN) ){
			if( loadingMode == 0 ){
				if( GenerateChurchPatternObject(PatMap4x4_ChurchPassageUp, 1, 1, 0, 0, 1, -1, 0) < 0 ){
					isGenerationEnd = 0;
				}
				MatchLevelSeed[ DungeonLevel ] = 0;
				continue;
			}
			if( GenerateChurchPatternObject(PatMap4x4_ChurchPassageUp, 1, 1, 0, 0, 0, -1, 0) < 0 ){
				isGenerationEnd = 0;
			}
			if( loadingMode == 1 ){
				PlayerRowPos = 2 * StartPatternRow40 + 20;
				PlayerColPos = 2 * StartPatternCol40 + 28;
				MatchLevelSeed[ DungeonLevel ] = 0;
				continue;
			}
			--PlayerColPos;
			MatchLevelSeed[ DungeonLevel ] = 0;
			continue;
		}
		bool goFromUp = loadingMode == 0;
		bool goFromDown = loadingMode == 1;
		bool goFromTown = loadingMode > 1;
		if( DungeonLevel == 21 ){
			if( GenerateChurchPatternObject(Pat3Map4x5_CryptPassageToTown, 1, 1, 0, 0, goFromTown, -1, 6) < 0 ){
				isGenerationEnd = 0;
			}
		}
		if( DungeonLevel >= 17 ){
			if( GenerateChurchPatternObject(PatMap4x5_CryptPassageUp, 1, 1, 0, 0, goFromUp || goFromDown || DungeonLevel != 21, -1, 0) < 0 ){
				isGenerationEnd = 0;
			}
		}else{
			if( GenerateChurchPatternObject(PatMap4x4_ChurchPassageUp, 1, 1, 0, 0, DungeonLevel < 21 && goFromUp, -1, 0) < 0 ){
				isGenerationEnd = 0;
			}
		}
		if( DungeonLevel >= 17 ){
			if( DungeonLevel < 24 ){
				if( GenerateChurchPatternObject(Pat2Map4x5_CryptPassageDown, 1, 1, 0, 0, goFromDown, -1, 1) < 0 ){
					isGenerationEnd = 0;
				}
			}
		}else{
			if( GenerateChurchPatternObject(PatMap4x3_ChurchPassageDown, 1, 1, 0, 0, goFromDown, -1, 1) < 0 ){
				isGenerationEnd = 0;
			}
		}
		if( ! isGenerationEnd ){
			MatchLevelSeed[ DungeonLevel ] = 0;
		}
		if( DungeonLevel > 20 ){
			if( goFromDown ) PlayerColPos += 3;
			if( goFromUp ) PlayerColPos += 1;
		}else{
			if( goFromDown ) --PlayerColPos;
		}
	}while( !isGenerationEnd ); // End of room map generation
	
	// если клетка CHR_WAFM_64_CHURCH_LEDDER_TO_UP_2 то копируется принадлежность комнате на соседние клетки
	// breakpoint для сверки после успешной генерации карты уровня
	// точка сверки без оптимизации MatchLevelSeed - 10592019, c оптимизацией - 46909
	for( int col40 = 0; col40 < 40; col40++ ){
		for( int row40 = 0; row40 < 40; row40++ ){
			if( Map[ row40 ][ col40 ] == CHR_WAFM_64_CHURCH_LEDDER_TO_UP_2 ){
				int col112 = Convert40to112(col40);
				int row112 = Convert40to112(row40);
				CopyCellTransparency(row112, col112 + 1, row112, col112);//shift transparency to right(row upper)
				CopyCellTransparency(row112 + 1, col112 + 1, row112 + 1, col112);//shift transparency to right (row downer)
			}
		}
	}
	//опять авто тайлинг продолжается
	ChurchSetAdditionalWallsTransparency();// изменить принадлежность Beyond тайлов примыкающих к комнате на принадлежность к комнате
	SomeConvertChurchAndCryptWalls();
	SomeMoreChurchWallsConvert(); // осталась не переписанной. За 20+ генераций не разу не выполнились все её условия. 
	//А так как она ничего не меняет, её невозможно тестировать. 
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			if( ChurchWallFlagMap[ row ][ col ] & 0x7F ){// проверить последние 7 бит
				ChurchPlaceDoorTiles(row, col);// поставить тайлы с дверями
			}
		}
	}
	if( DungeonLevel < 21 ){//Diablo Original
		ChurchTilesVariationsChange();// у тех тайлов у которых есть несколько вариантов есть 25 на случайное изменение
		InitChurchStaticShadows();// расставить статические тени
		GenerateChurchPatternObject(PatMap2x2_ChurchOnFloorTorch, 5, 10, 0, 0, 0, -1, 4);// всё ясно и без комментария. Поставить от 5 до 10 лампочек
		RandomizeChurchFloorTiles(); // все клетки которые всё ещё остались полом проходятся и каждой выбирается 1 из 3х вариаций
	}else{ //Hellfire
		//расстановка объектов и декорация для уровней Хэлфайера
		if( DungeonLevel >= 21 ){ // crypt
			PlaceSomeCryptPatterns_1(10);
			PlaceCryptPatternOnMap(PatMap1x1, 95);
			PlaceCryptPatternOnMap(Pat2Map1x1, 95);
			PlaceCryptPatternOnMap(PatMap1x3, 100);
			PlaceCryptPatternOnMap(Pat2Map1x3, 100);
			PlaceCryptPatternOnMap(PatMap3x3, 60);
			InitSomeCryptLavaFloorCells();
			if( DungeonLevel == 21 ){
				PlaceSomeCryptPatterns_2(30);
				PlaceSomeCryptPatterns_3(15);
				PlaceSomeCryptPatterns_4(5);
				InitSomeCryptLavaFloorCells();
				PlaceSomeCryptPatterns_6(10);
				PlaceSomeCryptPatterns_7(5);
				PlaceSomeCryptPatterns_5(20);
			}else if( DungeonLevel == 22 ){
				PlaceSomeCryptPatterns_6(10);
				PlaceSomeCryptPatterns_7(10);
				PlaceSomeCryptPatterns_5(20);
				PlaceSomeCryptPatterns_2(30);
				PlaceSomeCryptPatterns_3(20);
				PlaceSomeCryptPatterns_4(10);
				InitSomeCryptLavaFloorCells();
			}else if( DungeonLevel == 23 ){
				PlaceSomeCryptPatterns_6(10);
				PlaceSomeCryptPatterns_7(15);
				PlaceSomeCryptPatterns_5(30);
				PlaceSomeCryptPatterns_2(30);
				PlaceSomeCryptPatterns_3(20);
				PlaceSomeCryptPatterns_4(15);
				InitSomeCryptLavaFloorCells();
			}else if( DungeonLevel == 24 ){
				PlaceSomeCryptPatterns_6(10);
				PlaceSomeCryptPatterns_7(20);
				PlaceSomeCryptPatterns_5(30);
				PlaceSomeCryptPatterns_2(30);
				PlaceSomeCryptPatterns_3(20);
				PlaceSomeCryptPatterns_4(20);
				InitSomeCryptLavaFloorCells();
			}
		}
	}
	for( int i = 0; i < 40*40; i++ ){
		AltMap[ 0 ][ i ] = Map[ 0 ][ i ];
	}
	ClearObjectMaps();//чистимся
	AddDungeonQuestPatternToWallMap(StartPatternRow40, StartPatternCol40);//судя по названию тоже ставится какой-то объект на карту, связанный с квестом, но не проверял
	if( DungeonLevel == 24){
		ApplyUberAltDun(StartPatternRow40, StartPatternCol40);
	}
}

//----- (0071C250) --------------------------------------------------------
void __fastcall ApplyUberAltDun(int row, int col)
{
	ushort* dunFilePtr = (ushort*) LoadFile( "levels\\l5data\\uberoom2.dun", NULL );
	StartPatternRow40 = row;
	StartPatternCol40 = col;
	ushort patternMapRows = dunFilePtr[ 0 ];
	ushort patternMapCols = dunFilePtr[ 1 ];
	PatternMapRows = patternMapRows;
	PatternMapCols = patternMapCols;
	int patMapOffset = 2;
	for( int colOffset = 0; colOffset < patternMapCols; colOffset++ ){
		for( int rowOffset = 0; rowOffset < patternMapRows; rowOffset++ ){
			int newTile = dunFilePtr[ 2 + rowOffset + colOffset * patternMapRows ];
			if( newTile ){
				AltMap[ row + rowOffset ][ col + colOffset ] = newTile;
			}
		}
	}
	FreeMem( dunFilePtr );
	
}

//----- (0040C58E) --------------------------------------------------------
void __fastcall ChurchPlaceDoorTiles( int row, int col )
{
	int cell = col + 40 * row;
	int wallFlagMap = ChurchWallFlagMap[ 0 ][ cell ];
	if( (wallFlagMap & BIT(8)) ){
		ChurchWallFlagMap[ 0 ][ cell ] = (char)BIT(8);
		return;
	}
	uchar* wallAndFloorMap = &Map[ 0 ][ cell ];
	int flags = wallFlagMap & 0x7F;
	switch (flags ){
	case BIT(1):
		if( col != 1 ){
			switch (*wallAndFloorMap ){
			case CHR_WAFM_2_SWALL_M_MIDLE:									*wallAndFloorMap = CHR_WAFM_26_M_MIDDLE_CLOSED_DOOR;	break;
			case CHR_WAFM_7_SWALL_LU_END:									*wallAndFloorMap = CHR_WAFM_31_CDOOR_LU_END;	break;
			case CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL:			*wallAndFloorMap = CHR_WAFM_42_CORNER_BETWEEN_LU_ARCH_AND_RU_CDOOR;	break;
			case CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL:			*wallAndFloorMap = CHR_WAFM_43_CORNER_BETWEEN_LU_CWALL_AND_RU_CDOOR;	break;
			}
		}
		if( row != 1 ){
			switch (*wallAndFloorMap ){
			case CHR_WAFM_1_SWALL_UNM_MIDDLE:								*wallAndFloorMap = CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR;	break;
			case CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH:			*wallAndFloorMap = CHR_WAFM_40_CORNER_BETWEEN_LU_CDOOR_AND_RU_ARCH;	break;
			case CHR_WAFM_6_SWALL_RU_END:									*wallAndFloorMap = CHR_WAFM_30_CDOOR_RU_END;	break;
			}
		}
		break;
	case BIT(2):
		if( row != 1 ){
			switch (*wallAndFloorMap ){
			case CHR_WAFM_1_SWALL_UNM_MIDDLE:								*wallAndFloorMap = CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR;	break;
			case CHR_WAFM_6_SWALL_RU_END:									*wallAndFloorMap = CHR_WAFM_30_CDOOR_RU_END;	break;
			case CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH:			*wallAndFloorMap = CHR_WAFM_40_CORNER_BETWEEN_LU_CDOOR_AND_RU_ARCH;	break;
			case CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL:			*wallAndFloorMap = CHR_WAFM_41_CORNER_BETWEEN_LU_CDOOR_AND_RU_CWALL;	break;
			}
		}
		if( col != 1 ){
			switch (*wallAndFloorMap ){
			case CHR_WAFM_2_SWALL_M_MIDLE:									*wallAndFloorMap = CHR_WAFM_26_M_MIDDLE_CLOSED_DOOR;	break;
			case CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL:			*wallAndFloorMap = CHR_WAFM_42_CORNER_BETWEEN_LU_ARCH_AND_RU_CDOOR;	break;
			case CHR_WAFM_7_SWALL_LU_END:									*wallAndFloorMap = CHR_WAFM_31_CDOOR_LU_END;	break;
			}
		}
		break;
	case BIT(1)|BIT(2):
		if( row != 1 && col != 1 ){
			if( *wallAndFloorMap == CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL ){
				*wallAndFloorMap = CHR_WAFM_28_CORNER_BETWEEN_LU_CDOOR_AND_RU_CDOOR;
			}
		}
		if( col != 1 ){
			switch (*wallAndFloorMap ){
			case CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL:			*wallAndFloorMap = CHR_WAFM_42_CORNER_BETWEEN_LU_ARCH_AND_RU_CDOOR;	break;
			case CHR_WAFM_2_SWALL_M_MIDLE:									*wallAndFloorMap = CHR_WAFM_26_M_MIDDLE_CLOSED_DOOR;	break;
			case CHR_WAFM_7_SWALL_LU_END:									*wallAndFloorMap = CHR_WAFM_31_CDOOR_LU_END;	break;
			}
		}
		if( row != 1 ){
			switch (*wallAndFloorMap ){
			case CHR_WAFM_1_SWALL_UNM_MIDDLE:								*wallAndFloorMap = CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR;	break;
			case CHR_WAFM_6_SWALL_RU_END:									*wallAndFloorMap = CHR_WAFM_6_SWALL_RU_END;	break;
			case CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH:			*wallAndFloorMap = CHR_WAFM_40_CORNER_BETWEEN_LU_CDOOR_AND_RU_ARCH;	break;
			}
		}
		break;
	}
	ChurchWallFlagMap[ 0 ][ cell ] = (char)BIT(8);
}

//----- (0040C71E) --------------------------------------------------------
void InitSomeCryptLavaFloorCells()
{
	int col = 1;
	do{
		int row = 1;
		do{
			uchar* curCell = &Map[ row ][ col ];
			if( *curCell > CHR_WAFM_95_HALL_OF_HEROS_17 ){
				switch( *curCell ){
				case CHR_WAFM_116_R_WALL_DAMAGED_2:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_203_BEYOND;
					if( *(curCell - 41) != CHR_WAFM_13_FLOOR )
						goto LABEL_70;
					goto LABEL_30;
				case CHR_WAFM_120_R_WALL_DAMAGED_5:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_206_POISON_WELL_ENTER;
					if( *(curCell - 41) != CHR_WAFM_13_FLOOR )
						goto LABEL_70;
					goto LABEL_69;
				case CHR_WAFM_122_L_WALL_DAMAGED_1:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_211;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						*(curCell - 41) = CHR_WAFM_212;
					goto LABEL_63;
				case CHR_WAFM_133_FLOOR_WITH_CRUSHED_ROCK_1:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_203_BEYOND;
					if( *(curCell - 41) != CHR_WAFM_13_FLOOR )
						goto LABEL_70;
LABEL_30:
					*(curCell - 41) = CHR_WAFM_204_BEYOND;
					goto LABEL_70;
				case CHR_WAFM_137_FLOOR_WITH_CRUSHED_ROCK_5:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_213;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						*(curCell - 41) = CHR_WAFM_214;
					goto LABEL_70;
				case CHR_WAFM_139_TILE_WITH_SHADOW_1:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_215;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						*(curCell - 41) = CHR_WAFM_216;
					goto LABEL_63;
				case CHR_WAFM_143_TILE_WITH_SHADOW_5:
				case CHR_WAFM_145_TILE_WITH_SHADOW_7:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_213;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						*(curCell - 41) = CHR_WAFM_214;
					goto LABEL_63;
				case CHR_WAFM_150_TILE_WITH_SHADOW_12:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_203_BEYOND;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						*(curCell - 41) = CHR_WAFM_204_BEYOND;
					goto LABEL_47;
				case CHR_WAFM_140_TILE_WITH_SHADOW_2:
				case CHR_WAFM_157_TILE_WITH_SHADOW_19:
LABEL_47:
					if( *(curCell - 1) == CHR_WAFM_13_FLOOR )
						*(curCell - 1) = CHR_WAFM_217;
					goto LABEL_63;
				case CHR_WAFM_118_R_ARCH_DAMAGED_1:
				case CHR_WAFM_126_L_WALL_DAMAGED_3:
				case CHR_WAFM_128_ON_FLOOR_TORCH:
				case CHR_WAFM_135_FLOOR_WITH_CRUSHED_ROCK_3:
				case CHR_WAFM_152_TILE_WITH_SHADOW_14:
				case CHR_WAFM_160_L_HHWALL_R_WALL:
LABEL_49:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_206_POISON_WELL_ENTER;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						*(curCell - 41) = CHR_WAFM_207;
					goto LABEL_63;
				case CHR_WAFM_96_HALL_OF_HEROS_18:
				case CHR_WAFM_187_L_ODOOR_R_HHWALL:
					if( *(curCell - 1) == CHR_WAFM_13_FLOOR )
						*(curCell - 1) = CHR_WAFM_208;
					goto LABEL_63;
				case CHR_WAFM_119_R_WALL_DAMAGED_4:
				case CHR_WAFM_125_FLOOR_DAMAGED_1:
				case CHR_WAFM_136_FLOOR_WITH_CRUSHED_ROCK_4:
				case CHR_WAFM_142_TILE_WITH_SHADOW_4:
				case CHR_WAFM_153_TILE_WITH_SHADOW_15:
				case CHR_WAFM_156_TILE_WITH_SHADOW_18:
				case CHR_WAFM_159_L_ARCH_R_HHWALL:
				case CHR_WAFM_185_L_WALL_R_ODOOR:
				case CHR_WAFM_186_ODOOR_LU_WITH_BLOOD_1:
					goto LABEL_55;
				case CHR_WAFM_162_FLOOR_2:
				case CHR_WAFM_167_BUCHER_ROOM_2:
				case CHR_WAFM_192_M_WALL:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_209;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						*(curCell - 41) = CHR_WAFM_210;
					goto LABEL_63;
				default:
					goto LABEL_63;
				case CHR_WAFM_154_TILE_WITH_SHADOW_16:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_206_POISON_WELL_ENTER;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
LABEL_69:
					*(curCell - 41) = CHR_WAFM_207;
					break;
				case CHR_WAFM_121_L_ARCH_DAMAGED_1:
				case CHR_WAFM_123_L_ARCH_DAMAGED_2:
				case CHR_WAFM_138_FLOOR_WITH_CRUSHED_ROCK_6:
				case CHR_WAFM_155_TILE_WITH_SHADOW_17:
					goto LABEL_70;
				}
				goto LABEL_70;
			}
			if( *curCell != CHR_WAFM_95_HALL_OF_HEROS_17 ){
				switch( *curCell ){
				case CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_203_BEYOND;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						goto LABEL_30;
					break;
				case CHR_WAFM_9_ARCH_LU_END:
					if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
						*(curCell - 40) = CHR_WAFM_206_POISON_WELL_ENTER;
					if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
						goto LABEL_69;
					break;
				case CHR_WAFM_7_SWALL_LU_END:
				case CHR_WAFM_15_PILLAR:
				case CHR_WAFM_17_WALL_RD_END:
					goto LABEL_49;
				case CHR_WAFM_8_ARCH_RU_END:
				case CHR_WAFM_11_UNM_ARCH_MIDDLE:
				case CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL:
					goto LABEL_55;
				default:
					goto LABEL_63;
				case CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH:
				case CHR_WAFM_12_M_ARCH_MIDDLE:
					break;
				}
LABEL_70:
				if( *(curCell - 1) == CHR_WAFM_13_FLOOR )
					*(curCell - 1) = CHR_WAFM_205_BEYOND;
				goto LABEL_63;
			}
LABEL_55:
			if( *(curCell - 40) == CHR_WAFM_13_FLOOR )
				*(curCell - 40) = CHR_WAFM_203_BEYOND;
			if( *(curCell - 41) == CHR_WAFM_13_FLOOR )
				*(curCell - 41) = CHR_WAFM_204_BEYOND;
LABEL_63:
			++row;
		}while( row < 40 );
		++col;
	}while( col < 40 );
}

//----- (0040CA03) --------------------------------------------------------
void InitChurchStaticShadows()
{
	// расстановка тайлов с нарисованными тенями. Алгоритм так и не понял
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			int cell = (row+0)*40 + (col+0);
			int nextRowCell = (row+1)*40 + (col+0);
			int nextColCell = (row+0)*40 + (col+1);
			int nextRowAndColCell = (row+1)*40 + (col+1);
			for( int someIndex = 0; someIndex < 37; someIndex++ ){
				uchar* curBytePtr = &SomeChurchShadowsTable2[someIndex*7];
				if( 	curBytePtr[0] != SomeChurchShadowsTable[Map[ 0 ][ nextRowAndColCell ]] ){
					continue;
				}
				if( curBytePtr[1] && curBytePtr[1] != SomeChurchShadowsTable[Map[ 0 ][ cell ]] ){
					continue;
				}
				if( curBytePtr[2] && curBytePtr[2] != SomeChurchShadowsTable[Map[ 0 ][ nextRowCell ]] ){
					continue;
				}
				if( curBytePtr[3] && curBytePtr[3] != SomeChurchShadowsTable[Map[ 0 ][ nextColCell ]] ){
					continue;
				}

				if( curBytePtr[4] && !ChurchWallFlagMap[ 0 ][ cell ] ){
					Map[ 0 ][ cell ] = curBytePtr[4];
				}
				if( curBytePtr[5] && !ChurchWallFlagMap[ 0 ][ nextRowCell ] ){
					Map[ 0 ][ nextRowCell ] = curBytePtr[5];
				}
				if( curBytePtr[6] && !ChurchWallFlagMap[ 0 ][ nextColCell ] ){
					Map[ 0 ][ nextColCell ] = curBytePtr[6];
				}
			}
		}
	}

	// правка теней для решётчатых стен
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			int prevColCell = (row + 0)*40 + (col-1);
			int prevColNextRowCell = (row + 1)*40 + (col-1);

			if( !ChurchWallFlagMap[ 0 ][ prevColCell ] ){
				uchar newTileNumber;

				char prevColNextRowTileNumber = Map[ 0 ][ prevColNextRowCell ];
				bool isPrevColNextRowTileBars = 
					prevColNextRowTileNumber == CHR_WAFM_29_CORNER_BETWEEN_LU_BARS_AND_RU_BARS ||
					prevColNextRowTileNumber == CHR_WAFM_32_BARS_RU_END ||
					prevColNextRowTileNumber == CHR_WAFM_35_BARS_UNM_MIDDLE ||
					prevColNextRowTileNumber == CHR_WAFM_37_CORNER_BETWEEN_LU_BARS_AND_RU_CWALL ||
					prevColNextRowTileNumber == CHR_WAFM_38_CORNER_BETWEEN_LU_BARS_AND_RU_ARCH ||
					prevColNextRowTileNumber == CHR_WAFM_39_CORNER_BETWEEN_LU_BARS_AND_RU_CDOOR;

				if( !isPrevColNextRowTileBars ){
					continue;
				}

				switch (Map[ 0 ][ prevColCell ] ){
				case CHR_WAFM_139_TILE_WITH_SHADOW_1:					newTileNumber = CHR_WAFM_141_TILE_WITH_SHADOW_3;	break;
				case CHR_WAFM_149_TILE_WITH_SHADOW_11:					newTileNumber = CHR_WAFM_153_TILE_WITH_SHADOW_15;	break;
				case CHR_WAFM_148_TILE_WITH_SHADOW_10:					newTileNumber = CHR_WAFM_154_TILE_WITH_SHADOW_16;	break;
				default:											continue;
				}
				Map[ 0 ][ prevColCell ] = newTileNumber;
			}
		}
	}
}

//----- (0040CBF0) --------------------------------------------------------
int __fastcall GenerateChurchPatternObject( uchar* patternPtr, int minPatternsToPlace, int maxPatternsToPlace, int a4, int a5, bool resetPlayerPosition, int a7, int a8 )
{
	int col;
	int row;

	int patternRowSize = patternPtr[0];
	int patternColSize = patternPtr[1];

	char* beforePattern = (char*)&patternPtr[2];
	char* afterPattern = beforePattern + patternRowSize * patternColSize;

	//здесь определяется сколько копий объекта понатыкать на карте
	int numberOfPatternsToPlace;
	if( maxPatternsToPlace - minPatternsToPlace ){
		numberOfPatternsToPlace = RangeRND(0, maxPatternsToPlace - minPatternsToPlace ) + minPatternsToPlace;
	}else{
		numberOfPatternsToPlace = 1;
	}

	//уменьшаем зону поиска места для установки объекта учитывая его размеры (чтобы не выскочил за пределы массива)
	int mapRowsLimit = 40 - patternRowSize;
	int mapColumnsLimit = 40 - patternColSize;

	int continueFlag;

	for( int patternsPlaced = 0; patternsPlaced < numberOfPatternsToPlace; patternsPlaced++ ){
		bool isPatternPlaced = false;
		row = RangeRND(0, mapRowsLimit);
		col = RangeRND(0, mapColumnsLimit);
		int tryesCounter = 0;
		do{
			continueFlag = 1;
			if( (row >= -patternRowSize) && (row <= 12) ){
				row++;
				continueFlag = 0;
			}
			if( (col >= -patternColSize) && (col <= 12) )	{
				col++;
				continueFlag = 0;
			}
			// проверка на соответствие паттерну
			for( int colOffset = 0; colOffset < patternColSize && continueFlag; colOffset++ ){
				for( int rowOffset = 0; rowOffset < patternRowSize && continueFlag; rowOffset++ ){
					uchar neededTile = beforePattern[colOffset*patternRowSize+rowOffset];
					int mapCell = (row+rowOffset)*40 + (col+colOffset);
					if( (neededTile && (Map[ 0 ][ mapCell ] != neededTile)) || ChurchWallFlagMap[ 0 ][ mapCell ] ){
						continueFlag = 0; //бида бида, паттерн не соблюдается, надо искать другое место
					}
				}
			}
			if( continueFlag ){
				//матерь божья, мы нашли подходящее место для установки объекта, копируем ка его паттерн быстренько на карту
				for( int colOffset = 0; colOffset < patternColSize; colOffset++ ){
					for( int rowOffset = 0; rowOffset < patternRowSize; rowOffset++ ){
						uchar newTile = afterPattern[colOffset*patternRowSize+rowOffset];
						int mapCell = (row+rowOffset)*40 + (col+colOffset);
						if( newTile ){
							Map[ 0 ][ mapCell ] = newTile;
						}
					}
				}
				isPatternPlaced = true;
			}
			// следующая клетка
			if( !isPatternPlaced ){
				if( ++row == mapRowsLimit ){
					row = 0;
					if( ++col == mapColumnsLimit ){			
						col = 0;
					}
				}
				tryesCounter++;
				//после 4000 фэйлов в поиске подходящего места просто выходим, ну его нафиг
				if( tryesCounter > 4000 ){
					return -1;
				}
			}
		}while( !isPatternPlaced);
	}
	// вход в отравленный колодец помечаем как принадлежащий комнате 0
	if( patternPtr == PatMap6x6_WaterSupplyEnter ){
		int wallTransIndex = HallIndex; //запоминаем
		HallIndex = 0;
		SetAreaTransparencyByIndex_40(row, col + 2, row + 5, col + 4);
		HallIndex = wallTransIndex; //восстанавливаем
		Quests[Q_13_POISONED_WATER_SUPPLY].row = Convert40to112(row) + 5;
		Quests[Q_13_POISONED_WATER_SUPPLY].col = Convert40to112(col) + 6;
	}
	//перемещаем стартовую точку игрока поближе к созданному объекту (как правило это делается для лестницы)
	if( resetPlayerPosition == 1 ){
		PlayerRowPos = Convert40to112(row) + 3; // 2 * row + 19 
		PlayerColPos = Convert40to112(col) + 4;	// 2 * col + 20 
	}
	if( !a8 ){
		SomeXPos2 = 2 * row + 19;
		SomeYPos2 = 2 * col + 20;
	}
	//int result = 1;
	//v27 = __OFSUB__( row, a4 );
	//v25 = row == a4;
	//v26 = row - a4 < 0;
	//if( row < a4 ){
	//	if( col < (int) a5 ){
	//		return 0;
	//	}
	//	v27 = __OFSUB__( row, a4 );
	//	v25 = row == a4;
	//	v26 = row - a4 < 0;
	//}
	//if( !((unsigned __int8) (v26 ^ v27) | v25) ){
	//	if( col < (int) a5 ){
	//		return result;
	//	}
	//	v27 = __OFSUB__( row, a4 );
	//	v26 = row - a4 < 0;
	//}
	//if( v26 ^ v27 && col > ( int )a5 ){
	//	v28 = 2;
	//}else{
	//	v28 = 3;
	//}
	//return v28;

	return 0;
}

//----- (0040CE81) --------------------------------------------------------
void ClearWallFloorMap()
{
	for( int i = 0; i < 40*40; i++ ){
		Map[ 0 ][ i ] = 0;
		ChurchWallFlagMap[ 0 ][ i ] = 0;
	}
}

//----- (0040CEA3) --------------------------------------------------------
void ClearWallFlagMapBit7()
{
	for( int i = 0; i < 40*40; i++ ){
		ChurchWallFlagMap[ 0 ][ i ] &= ~BIT(7); // clear bit 7 (0x40)
	}
}

//----- (0040CEBE) --------------------------------------------------------
void ConstructChurchRooms()
{
	if( RangeRND(0, 2) ){
		// horisontal
		int startRow = 1;
		int endRow = 39;
		IsFirstBigChurchHallPlaced = RangeRND(0, 2);
		IsSecondBigChurchHallPlaced = RangeRND(0, 2);
		IsThirdBigChurchHallPlaced = RangeRND(0, 2);
		if( !(IsFirstBigChurchHallPlaced && IsThirdBigChurchHallPlaced) ){
			IsSecondBigChurchHallPlaced = 1;
		}
		if( IsFirstBigChurchHallPlaced ){
			BuildChurchRectangleRoom(1, 15, 10, 10);
		}else{
			startRow = 18;
		}
		if( IsSecondBigChurchHallPlaced ){
			BuildChurchRectangleRoom(15, 15, 10, 10);
		}
		if( IsThirdBigChurchHallPlaced ){
			BuildChurchRectangleRoom(29, 15, 10, 10);
		}else{
			endRow = 22;
		}
		//BuildChurchRectangleRoom(startRow, 17, endRow - startRow, 6);
		for( int col = 17; col < 17 + 6; col++ ){
			for( int row = startRow; row < startRow + endRow - startRow; row++ ){
				Map[ row ][ col ] = 1;
			}
		}
		if( IsFirstBigChurchHallPlaced ){
			RecursiveChurchRoomsConstruct(1, 15, 10, 10, 1);
		}
		if( IsSecondBigChurchHallPlaced ){
			RecursiveChurchRoomsConstruct(15, 15, 10, 10, 1);
		}
		if( IsThirdBigChurchHallPlaced ){
			RecursiveChurchRoomsConstruct(29, 15, 10, 10, 1);
		}
		IsThirdBigChurchHallPlaced2 = 0;
		IsSecondBigChurchHallPlaced2 = 0;
		IsFirstBigChurchHallPlaced2 = 0;
	}else{
		// vertical
		int startCol = 1;
		int endCol = 39;
		IsFirstBigChurchHallPlaced2 = RangeRND(0, 2);
		IsSecondBigChurchHallPlaced2 = RangeRND(0, 2);
		IsThirdBigChurchHallPlaced2 = RangeRND(0, 2);
		if( !(IsFirstBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2) ){
			IsSecondBigChurchHallPlaced2 = 1;
		}
		if( IsFirstBigChurchHallPlaced2 ){
			BuildChurchRectangleRoom(15, 1, 10, 10);
		}else{
			startCol = 18;
		}
		if( IsSecondBigChurchHallPlaced2 ){
			BuildChurchRectangleRoom(15, 15, 10, 10);
		}
		if( IsThirdBigChurchHallPlaced2 ){
			BuildChurchRectangleRoom(15, 29, 10, 10);
		}else{
			endCol = 22;
		}
		//BuildChurchRectangleRoom(17, startCol, 6, endCol - startCol);
		for( int col = startCol; col < startCol + endCol - startCol; col++ ){
			for( int row = 17; row < 17 + 6; row++ ){
				Map[ row ][ col ] = 1;
			}
		}
		if( IsFirstBigChurchHallPlaced2 ){
			RecursiveChurchRoomsConstruct(15, 1, 10, 10, 0);
		}
		if( IsSecondBigChurchHallPlaced2 ){
			RecursiveChurchRoomsConstruct(15, 15, 10, 10, 0);
		}
		if( IsThirdBigChurchHallPlaced2 ){
			RecursiveChurchRoomsConstruct(15, 29, 10, 10, 0);
		}
		IsThirdBigChurchHallPlaced = 0;
		IsSecondBigChurchHallPlaced = 0;
		IsFirstBigChurchHallPlaced = 0;
	}
}

//----- (0040D0F5) --------------------------------------------------------
void __fastcall BuildChurchRectangleRoom( int startRow, int startCol, int rows, int cols )
{
	//DumpMap((uchar*)Map, 40);
	for( int col = startCol; col < startCol + cols; col++ ){
		for( int row = startRow; row < startRow + rows; row++ ){
			Map[ row ][ col ] = 1;
		}
	}
	//DumpMap((uchar*)Map, 40);
}

//----- (0040D12C) --------------------------------------------------------
void __fastcall RecursiveChurchRoomsConstruct( int startRow, int startCol, int rows, int cols, int isHorisontal )
{
	int curRectRow = startRow;
	int curRectCol = startCol;
	int curRectRows = rows;
	int curRectCols = cols;
	bool curOrientationIsHorisontal = isHorisontal == 0 ? false : true;

	bool isRepeatNeed = true;
	do{
		int randFactor = RangeRND(0, 4);
		curOrientationIsHorisontal = curOrientationIsHorisontal ? (randFactor != 0) : (randFactor == 0);// 25% to change
		if( curOrientationIsHorisontal ){
			int leftRectRow, leftRectCol;
			int leftRectRows, leftRectCols;
			bool isLeftRectEnabled, isRightRectEnabled;
			// left
			int halfOfCurRectRows = curRectRows / 2;
			int tryesCount = 0;
			do{
				leftRectRows = (RangeRND(0, 5)+2) & ~BIT(1);// округление до меньшего четного
				leftRectCols = (RangeRND(0, 5)+2) & ~BIT(1);
				leftRectRow = halfOfCurRectRows + curRectRow - leftRectRows / 2;
				leftRectCol = curRectCol - leftRectCols;

				isLeftRectEnabled = ThereIsNoRoom(leftRectRow - 1, leftRectCol - 1, leftRectRows + 2, leftRectCols + 1);
			}while( !isLeftRectEnabled && ++tryesCount < 20 );

			if( isLeftRectEnabled ){
				BuildChurchRectangleRoom(leftRectRow, leftRectCol, leftRectRows, leftRectCols);
			}
			int rightRectRow = leftRectRow;
			int rightRectCol = curRectCols + curRectCol;
			// right
			isRightRectEnabled = ThereIsNoRoom(rightRectRow - 1, rightRectCol, leftRectRows + 2, leftRectCols + 1);
			if( isRightRectEnabled ){
				BuildChurchRectangleRoom(rightRectRow, rightRectCol, leftRectRows, leftRectCols);
			}
			if( isLeftRectEnabled ){
				RecursiveChurchRoomsConstruct(leftRectRow, leftRectCol, leftRectRows, leftRectCols, false);
			}
			if( !isRightRectEnabled ){
				return;
			}
			curOrientationIsHorisontal = false;
			curRectRow = rightRectRow;
			curRectCol = rightRectCol;
			curRectRows = leftRectRows;
			curRectCols = leftRectCols;

			isRepeatNeed = isRightRectEnabled;
		}else{
			int upRectRow, upRectCol;
			int upRectRows, upRectCols;
			bool isUpRectEnabled, isDownRectEnabled;
			// up
			int halfOfCurRectCols = curRectCols / 2;
			int tryesCount = 0;
			do{
				upRectRows = (RangeRND(0, 5)+2) & ~BIT(1);
				upRectCols = (RangeRND(0, 5)+2) & ~BIT(1);
				upRectCol = halfOfCurRectCols + curRectCol - upRectCols / 2;
				upRectRow = curRectRow - upRectRows;

				isUpRectEnabled = ThereIsNoRoom(upRectRow - 1, upRectCol - 1, upRectCols + 2, upRectRows + 1);//  upRectRows + 1, upRectCols + 2
			}while( !isUpRectEnabled && ++tryesCount < 20 );

			if( isUpRectEnabled == 1 ){
				BuildChurchRectangleRoom(upRectRow, upRectCol, upRectRows, upRectCols);
			}

			int downRectRow = curRectRows + curRectRow;
			int downRectCol = upRectCol;
			// down
			isDownRectEnabled = ThereIsNoRoom(downRectRow, downRectCol - 1, upRectRows + 1, upRectCols + 2);
			if( isDownRectEnabled ){
				BuildChurchRectangleRoom(downRectRow, downRectCol, upRectRows, upRectCols);
			}
			if( isUpRectEnabled ){
				RecursiveChurchRoomsConstruct(upRectRow, upRectCol, upRectRows, upRectCols, true);
			}

			curOrientationIsHorisontal = true;
			curRectRow = downRectRow;
			curRectCol = downRectCol;
			curRectRows = upRectRows;
			curRectCols = upRectCols;

			isRepeatNeed = isDownRectEnabled;
		}
		
	}while(isRepeatNeed);
}

//----- (0040D335) --------------------------------------------------------
bool __fastcall ThereIsNoRoom( int startRow, int startCol, int rows, int cols )
{
	if( startRow < 0 || startRow + rows > 40 || startCol < 0 || startCol + cols > 40 ){
		return 0;
	}
	for( int col = startCol; col < startCol + cols; col++ ){
		for( int row = startRow; row < startRow + rows; row++ ){
			if( Map[ row ][ col ] ){
				return 0;
			}
		}
	}
	return 1;
}

//----- (0040D399) --------------------------------------------------------
int AreaOfLevelRoomsChurch()
{
	int floorCellCount = 0;
	for( int i = 0; i < 40*40; i++ ){
		if( Map[ 0 ][ i ] == 1 ){
			floorCellCount++;
		}
	}
	return floorCellCount;
}

//----- (0040D3BB) --------------------------------------------------------
void CopyChurchInitalRoomsScheme()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			char wall = Map[ row ][ col ];
			InitalChurchWallScheme[ row * 2 ][ col * 2 ] = wall;
			InitalChurchWallScheme[ row * 2 ][ col * 2 + 1 ] = wall;
			InitalChurchWallScheme[ row * 2 + 1 ][ col * 2 ] = wall;
			InitalChurchWallScheme[ row * 2 + 1 ][ col * 2 + 1 ] = wall;
		}
	}
}

//----- (0040D3FF) --------------------------------------------------------
void InitChurchWallAndFloorMapFromBynaryPattern()
{
	for( int col = 0; col < 40* 40; col++ ){
		Map[ 0 ][ col ] = CHR_WAFM_22_BEYOND;
	}

	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			int row80 = 2 * row + 1;
			int col80 = 2 * col + 1;
			int var1 = InitalChurchWallScheme[ row80 + 0 ][ col80 + 0 ];
			int var2 = InitalChurchWallScheme[ row80 + 1 ][ col80 + 0 ];
			int var3 = InitalChurchWallScheme[ row80 + 0 ][ col80 + 1 ];
			int var4 = InitalChurchWallScheme[ row80 + 1 ][ col80 + 1 ];
			Map[ row ][ col ] = ChurchOrientedWallsAndCorner[var1 + 2*var2 + 4*var3 + 8*var4];
		}
	}
}

//----- (0040D475) --------------------------------------------------------
void ChurchMakeSomeCrossWalls()
{
	int walls;
	for( int col = 0; col < 40; col++ ){ // was wrong with rows first (!) must be careful with index order
		for( int row = 0; row < 40; row++ ){
			if( ChurchWallFlagMap[ row ][ col ] ){
				continue;
			}
			uchar wallAndFloorMap = Map[ row ][ col ];
			switch (wallAndFloorMap ){
			case CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH:
				RangeRND(0, 100);
				walls = ChurchCountWallInRowFrom(row, col);
				if( walls != -1 ){
					ChurchSetVerticalWall(row, col, 2, walls);
				}
				RangeRND(0, 100);
				walls = ChurchCountWallInColFrom(row, col);
				if( walls != -1 ){
					ChurchSetHorisontalWall(row, col, 1, walls);
				}
				break;
			case CHR_WAFM_6_SWALL_RU_END:
				RangeRND(0, 100);
				walls = ChurchCountWallInRowFrom(row, col);
				if( walls != -1 ){
					ChurchSetVerticalWall(row, col, 4, walls);
				}
				break;
			case CHR_WAFM_7_SWALL_LU_END:
				RangeRND(0, 100);
				walls = ChurchCountWallInColFrom(row, col);
				if( walls != -1 ){
					ChurchSetHorisontalWall(row, col, 4, walls);
				}
				break;
			case CHR_WAFM_2_SWALL_M_MIDLE:
				RangeRND(0, 100);
				walls = ChurchCountWallInRowFrom(row, col);
				if( walls != -1 ){
					ChurchSetVerticalWall(row, col, 2, walls);
				}
				break;
			case CHR_WAFM_1_SWALL_UNM_MIDDLE:
				RangeRND(0, 100);
				walls = ChurchCountWallInColFrom(row, col);
				if( walls != -1 ){
					ChurchSetHorisontalWall(row, col, 1, walls);
				}
				break;
			}
		}
	}
}

//----- (0040D5D1) --------------------------------------------------------
int __fastcall ChurchCountWallInRowFrom( int row, int col )
{
	int wallCount;
	uchar wall;
	for( wallCount = 1; wallCount < 40 - row; wallCount++ ){
		wall = Map[ row + wallCount ][ col + 0 ];
		if( wall != CHR_WAFM_13_FLOOR ||
			Map[ row + wallCount ][ col - 1 ] != CHR_WAFM_13_FLOOR ||
			Map[ row + wallCount ][ col + 1 ] != CHR_WAFM_13_FLOOR ||
			ChurchWallFlagMap[ row + wallCount ][ col + 0 ] ){
				break;
		}
	}
	if( (wall >= CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH && wall <= CHR_WAFM_7_SWALL_LU_END || wall >= CHR_WAFM_16_WALL_LD_END && wall <= CHR_WAFM_24_BEYOND_WALL_IN_RU_2 && wall != CHR_WAFM_22_BEYOND ) && wallCount > 1 ){
		return wallCount;
	}else{
		return -1;
	}
}

//----- (0040D660) --------------------------------------------------------
int __fastcall ChurchCountWallInColFrom( int row, int col )
{
	int wallCount;
	uchar wall;
	for( wallCount = 1; wallCount < 40 - col; wallCount++ ){
		wall = Map[ row + 0 ][ col + wallCount ];
		if( wall != CHR_WAFM_13_FLOOR ||
			Map[ row - 1 ][ col + wallCount ] != CHR_WAFM_13_FLOOR ||
			Map[ row + 1 ][ col + wallCount ] != CHR_WAFM_13_FLOOR ||
			ChurchWallFlagMap[ row + 0 ][ col + wallCount ] ){
				break;
		}
	}
	if( (wall >= CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH && wall <= CHR_WAFM_7_SWALL_LU_END || wall >= CHR_WAFM_16_WALL_LD_END && wall <= CHR_WAFM_24_BEYOND_WALL_IN_RU_2 && wall != CHR_WAFM_22_BEYOND) && wallCount > 1 ){
		return wallCount;
	}else{
		return -1;
	}
}

//----- (0040D6DC) --------------------------------------------------------
void __fastcall ChurchSetVerticalWall(int startRow, int startCol, char startWallType, int wallsCount)
{
	char wallType = CHR_WAFM_2_SWALL_M_MIDLE;// сплошная стена
	switch( RangeRND(0, 4) ){
	case 2:
		wallType = CHR_WAFM_12_M_ARCH_MIDDLE;// сплошная арка
		if( startWallType == CHR_WAFM_2_SWALL_M_MIDLE ){
			startWallType = CHR_WAFM_12_M_ARCH_MIDDLE;
		}
		if( startWallType == CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL ){
			startWallType = CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH;
		}
		break;
	case 3:
		wallType = CHR_WAFM_36_BARS_M_MIDDLE;// решётчатая стена. простреливаемая но не проходимая
		if( startWallType == CHR_WAFM_2_SWALL_M_MIDLE ){
			startWallType = CHR_WAFM_36_BARS_M_MIDDLE;
		}
		if( startWallType == CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL ){
			startWallType = CHR_WAFM_27_CORNER_BETWEEN_LU_SWALL_AND_RU_BARS;
		}
	}
	char doorType = RangeRND( 0, 6 ) == 5 ? CHR_WAFM_12_M_ARCH_MIDDLE : CHR_WAFM_26_M_MIDDLE_CLOSED_DOOR;
	Map[ startRow ][ startCol ] = startWallType;
	for( int rowOffset = 1; rowOffset < wallsCount; rowOffset++ ){
		Map[ startRow + rowOffset ][ startCol ] = wallType;
	}
	if( wallType == CHR_WAFM_12_M_ARCH_MIDDLE ){// у арочной стены дверь тоже арка
		doorType = CHR_WAFM_12_M_ARCH_MIDDLE;
	}
	int doorCell = startCol + 40 * (startRow + RangeRND(0, wallsCount - 1) + 1);
	if( doorType == CHR_WAFM_12_M_ARCH_MIDDLE ){
		Map[ 0 ][ doorCell ] = doorType;
	}else{
		ChurchWallFlagMap[ 0 ][ doorCell ] |= BIT(1);// потенциальная дверь?
		Map[ 0 ][ doorCell ] = CHR_WAFM_2_SWALL_M_MIDLE;
	}
}

//----- (0040D7C9) --------------------------------------------------------
void __fastcall ChurchSetHorisontalWall(int startRow, int startCol, char startWallType, int wallsCount)
{
	char wallType = CHR_WAFM_1_SWALL_UNM_MIDDLE;// сплошная стена
	switch( RangeRND(0, 4) ){
	case 2:
		wallType = CHR_WAFM_11_UNM_ARCH_MIDDLE;// сплошная арка
		if( startWallType == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
			startWallType = CHR_WAFM_11_UNM_ARCH_MIDDLE;
		}
		if( startWallType == CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL ){
			startWallType = CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL;
		}
		break;
	case 3:
		wallType = CHR_WAFM_35_BARS_UNM_MIDDLE;// решётчатая стена. простреливаемая но не проходимая
		if( startWallType == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
			startWallType = CHR_WAFM_35_BARS_UNM_MIDDLE;
		}
		if( startWallType == CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL ){
			startWallType = CHR_WAFM_37_CORNER_BETWEEN_LU_BARS_AND_RU_CWALL;
		}
	}
	int doorType = RangeRND( 0, 6 ) == 5 ? CHR_WAFM_11_UNM_ARCH_MIDDLE : CHR_WAFM_25_UNM_MIDDLE_CLOSED_DOOR;
	Map[ startRow ][ startCol ] = startWallType;
	for( int colOffset = 1; colOffset < wallsCount; colOffset++ ){
		Map[ startRow + 0 ][ startCol + colOffset ] = wallType;
	}
	if( wallType == CHR_WAFM_11_UNM_ARCH_MIDDLE ){
		doorType = CHR_WAFM_11_UNM_ARCH_MIDDLE;
	}
	int doorCell = (startCol + RangeRND(0, wallsCount - 1) + 1) + 40 * startRow;
	if( doorType == CHR_WAFM_11_UNM_ARCH_MIDDLE ){
		Map[ 0 ][ doorCell ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
	}else{
		ChurchWallFlagMap[ 0 ][ doorCell ] |= BIT(2);// потенциальная дверь?
		Map[ 0 ][ doorCell ] = CHR_WAFM_1_SWALL_UNM_MIDDLE;
	}
}

//----- (0040D8CF) --------------------------------------------------------
void ConvertToChurchWalls()
{
	// опасно работает алгоритм. Никих проверок на выход за границу Map. 
	// Может работать по разному в зависимости от фазы луны (смотря что прочтёт за пределами)
	// А может изменять что то за своими пределами

	// расстановка тайлов BEYOND
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar* curWallAndFloorMap = &Map[ row+0 ][ col+0 ];
			uchar* nextRowWallAndFloorMap = &Map[ row+1 ][ col+0 ];
			uchar* nextColWallAndFloorMap = &Map[ row+0 ][ col+1 ];
			switch (*curWallAndFloorMap ){
			case CHR_WAFM_2_SWALL_M_MIDLE:
				if( *nextRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextRowWallAndFloorMap = CHR_WAFM_23_BEYOND_WALL_IN_LU_2;
				}
				break;
			case CHR_WAFM_13_FLOOR:
				if( *nextRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextRowWallAndFloorMap = CHR_WAFM_18_BEYOND_WALL_IN_LU;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_2_SWALL_M_MIDLE ){
					*nextRowWallAndFloorMap = CHR_WAFM_7_SWALL_LU_END;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
					*nextColWallAndFloorMap = CHR_WAFM_6_SWALL_RU_END;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextColWallAndFloorMap = CHR_WAFM_19_BEYOND_WALL_IN_RU;
				}
				break;
			case CHR_WAFM_6_SWALL_RU_END:
				if( *nextRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextRowWallAndFloorMap = CHR_WAFM_24_BEYOND_WALL_IN_RU_2;
				}
				break;
			case CHR_WAFM_1_SWALL_UNM_MIDDLE:
				if( *nextColWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextColWallAndFloorMap = CHR_WAFM_24_BEYOND_WALL_IN_RU_2;
				}
				break;
			}
		}
	}

	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar* curWallAndFloorMap = &Map[ row+0 ][ col+0 ];
			uchar* nextRowWallAndFloorMap = &Map[ row+1 ][ col+0 ];
			uchar* nextColWallAndFloorMap = &Map[ row+0 ][ col+1 ];
			uchar* prevRowWallAndFloorMap = &Map[ row-1 ][ col+0 ];
			uchar* prevColWallAndFloorMap = &Map[ row+0 ][ col-1 ];
			switch (*curWallAndFloorMap ){
			case CHR_WAFM_1_SWALL_UNM_MIDDLE:
				if( *nextColWallAndFloorMap == CHR_WAFM_2_SWALL_M_MIDLE ){
					*nextColWallAndFloorMap = CHR_WAFM_7_SWALL_LU_END;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_13_FLOOR ){
					*nextColWallAndFloorMap = CHR_WAFM_16_WALL_LD_END;
				}
				break;
			case CHR_WAFM_2_SWALL_M_MIDLE:
				if( *nextRowWallAndFloorMap == CHR_WAFM_19_BEYOND_WALL_IN_RU ){
					*nextRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
					*nextRowWallAndFloorMap = CHR_WAFM_6_SWALL_RU_END;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_24_BEYOND_WALL_IN_RU_2 ){
					*nextRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_13_FLOOR ){
					*nextRowWallAndFloorMap = CHR_WAFM_17_WALL_RD_END;
				}
				break;
			case CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH:
				if( *nextRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextRowWallAndFloorMap = CHR_WAFM_24_BEYOND_WALL_IN_RU_2;
				}
				break;
			case CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL:
				if( *nextRowWallAndFloorMap == CHR_WAFM_16_WALL_LD_END ){
					*nextRowWallAndFloorMap = CHR_WAFM_17_WALL_RD_END;
				}
				break;
			case CHR_WAFM_6_SWALL_RU_END:
				if( *prevRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*prevRowWallAndFloorMap = CHR_WAFM_24_BEYOND_WALL_IN_RU_2;
				}
				if( *prevRowWallAndFloorMap == CHR_WAFM_23_BEYOND_WALL_IN_LU_2 ){
					*prevRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_18_BEYOND_WALL_IN_LU ){
					*nextColWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_2_SWALL_M_MIDLE ){
					*nextColWallAndFloorMap = CHR_WAFM_7_SWALL_LU_END;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextColWallAndFloorMap = CHR_WAFM_24_BEYOND_WALL_IN_RU_2;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_13_FLOOR ){
					*nextColWallAndFloorMap = CHR_WAFM_16_WALL_LD_END;
				}
				if( *prevColWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*prevColWallAndFloorMap = CHR_WAFM_7_SWALL_LU_END;
				}
				if( *prevColWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*prevColWallAndFloorMap = CHR_WAFM_24_BEYOND_WALL_IN_RU_2;
				}
				break;
			case CHR_WAFM_7_SWALL_LU_END:
				if( *nextRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextRowWallAndFloorMap = CHR_WAFM_23_BEYOND_WALL_IN_LU_2;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_19_BEYOND_WALL_IN_RU ){
					*nextRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
					*nextRowWallAndFloorMap = CHR_WAFM_6_SWALL_RU_END;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_24_BEYOND_WALL_IN_RU_2 ){
					*nextRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_13_FLOOR ){
					*nextRowWallAndFloorMap = CHR_WAFM_17_WALL_RD_END;
				}
				if( *prevColWallAndFloorMap == CHR_WAFM_24_BEYOND_WALL_IN_RU_2 ){
					*prevColWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				break;
			case CHR_WAFM_13_FLOOR:
				if( *nextRowWallAndFloorMap == CHR_WAFM_19_BEYOND_WALL_IN_RU ){
					*nextRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextRowWallAndFloorMap = CHR_WAFM_20_BEYOND_WALL_CORNER_BETWEEN_LU_AND_RU;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_24_BEYOND_WALL_IN_RU_2 ){
					*nextRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_16_WALL_LD_END ){
					*nextColWallAndFloorMap = CHR_WAFM_17_WALL_RD_END;
				}
				break;
			case CHR_WAFM_18_BEYOND_WALL_IN_LU:
				if( *nextColWallAndFloorMap == CHR_WAFM_2_SWALL_M_MIDLE ){
					*nextColWallAndFloorMap = CHR_WAFM_7_SWALL_LU_END;
				}
				if( *prevColWallAndFloorMap == CHR_WAFM_24_BEYOND_WALL_IN_RU_2 ){
					*prevColWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				break;
			case CHR_WAFM_19_BEYOND_WALL_IN_RU:
				if( *nextRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextRowWallAndFloorMap = CHR_WAFM_20_BEYOND_WALL_CORNER_BETWEEN_LU_AND_RU;
				}
				if( *nextRowWallAndFloorMap == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
					*nextRowWallAndFloorMap = CHR_WAFM_6_SWALL_RU_END;
				}
				if( *prevRowWallAndFloorMap == CHR_WAFM_23_BEYOND_WALL_IN_LU_2 ){
					*prevRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				break;
			case CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD:
				if( *nextRowWallAndFloorMap == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
					*nextRowWallAndFloorMap = CHR_WAFM_6_SWALL_RU_END;
				}
				if( *nextColWallAndFloorMap == CHR_WAFM_2_SWALL_M_MIDLE ){
					*nextColWallAndFloorMap = CHR_WAFM_7_SWALL_LU_END;
				}
				break;
			case CHR_WAFM_23_BEYOND_WALL_IN_LU_2:
				if( *prevRowWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*prevRowWallAndFloorMap = CHR_WAFM_19_BEYOND_WALL_IN_RU;
				}
				break;
			}
		}
	}

	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar* curWallAndFloorMap = &Map[ row+0 ][ col+0 ];
			uchar* nextRowWallAndFloorMap = &Map[ row+1 ][ col+0 ];
			uchar* nextColWallAndFloorMap = &Map[ row+0 ][ col+1 ];
			switch (*curWallAndFloorMap ){
			case CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL:
				if( *nextColWallAndFloorMap == CHR_WAFM_2_SWALL_M_MIDLE ){
					*nextColWallAndFloorMap = CHR_WAFM_7_SWALL_LU_END;
				}
				break;
			case CHR_WAFM_2_SWALL_M_MIDLE:
				if( *nextRowWallAndFloorMap == CHR_WAFM_19_BEYOND_WALL_IN_RU ){
					*nextRowWallAndFloorMap = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
				}
				break;
			case CHR_WAFM_18_BEYOND_WALL_IN_LU:
				if( *nextColWallAndFloorMap == CHR_WAFM_22_BEYOND ){
					*nextColWallAndFloorMap = CHR_WAFM_20_BEYOND_WALL_CORNER_BETWEEN_LU_AND_RU;
				}
				break;
			}
		}
	}
}

//----- (0040DD3E) --------------------------------------------------------
void __fastcall PlaceCryptPatternOnMap( uchar* aYSize, int MayBeSize )
{
	uchar *byteArray; // ebx@1
	int nextY; // edi@1
	uchar *mapCorner; // edi@4
	int curY; // esi@5
	int i; // edx@5
	int curX; // edi@7
	int curCell; // eax@8
	uchar patternCell; // cl@10
	int v12; // esi@17
	uchar xSize2; // al@17
	uchar xSize2_1; // al@20
	int j; // edx@34
	int v14; // edi@36
	char *xSize2_2; // eax@36
	char v15; // cl@37
	bool v16; // zf@42
	int mayBeSize2; // [sp+8h] [bp-28h]@1
	int xLeft2; // [sp+Ch] [bp-24h]@4
	int xLeft; // [sp+10h] [bp-20h]@2
	int startY; // [sp+18h] [bp-18h]@1
	uchar *mapCorner2; // [sp+1Ch] [bp-14h]@4
	int mapRow; // [sp+20h] [bp-10h]@4
	int ySize; // [sp+24h] [bp-Ch]@1
	int xSize; // [sp+28h] [bp-8h]@1
	int insizeMap; // [sp+2Ch] [bp-4h]@5

	byteArray = aYSize;
	mayBeSize2 = MayBeSize;
	nextY = 0;
	xSize = *aYSize;
	ySize = aYSize[ 1 ];
	startY = 0;
	if( 40 - ySize > 0 ){
		xLeft = 40 - *aYSize;
		while( xLeft <= 0 ){
		LABEL_43:
			nextY = startY++ + 1;
			if( startY >= 40 - ySize ){
				return;
			}
		}
		mapRow = 0;
		mapCorner = (uchar*) Map + nextY;
		mapCorner2 = mapCorner;
		xLeft2 = xLeft;
		while( 1 ){
			curY = 0;
			insizeMap = 1;
			for( i = 2; curY < ySize; ++curY ){
				if( insizeMap != 1 ){
					break;
				}
				curX = 0;
				if( xSize > 0 ){
					curCell = mapRow + curY + startY;
					do{
						if( insizeMap != 1 ){
							break;
						}
						patternCell = byteArray[ i ];
						if( patternCell && Map[ 0 ][ curCell ] != patternCell ){
							insizeMap = 0;
						}
						if( ChurchWallFlagMap[ 0 ][ curCell ] ){
							insizeMap = 0;
						}
						++i;
						++curX;
						curCell += 40;
					} while( curX < xSize );
				}
				mapCorner = mapCorner2;
			}
			v12 = xSize * ySize + 2;
			xSize2 = byteArray[ v12 ];
			if( xSize2 < 84u || xSize2 > 100u ){
				goto LABEL_32;
			}
			if( insizeMap == 1 ){
				break;
			}
		LABEL_42:
			mapRow += 40;
			mapCorner += 40;
			v16 = xLeft2-- == 1;
			mapCorner2 = mapCorner;
			if( v16 ){
				goto LABEL_43;
			}
		}
		xSize2_1 = *(mapCorner - 40);
		if( xSize2_1 >= 84u && xSize2_1 <= 100u ){
			insizeMap = 0;
		}
		if( mapCorner[ 40 ] >= 84u && xSize2_1 <= 100u ){
			insizeMap = 0;
		}
		if( mapCorner[ 1 ] >= 84u && xSize2_1 <= 100u ){
			insizeMap = 0;
		}
		if( *(mapCorner - 1) >= 84u && xSize2_1 <= 100u ){
			insizeMap = 0;
		}
	LABEL_32:
		if( insizeMap == 1 && RangeRND( 0, 100 ) < mayBeSize2 ){
			for( j = 0; j < ySize; ++j ){
				if( xSize > 0 ){
					v14 = xSize;
					xSize2_2 = (char *) Map + j + startY + mapRow;
					do{
						v15 = byteArray[ v12 ];
						if( v15 ){
							*xSize2_2 = v15;
						}
						++v12;
						xSize2_2 += 40;
						--v14;
					} while( v14 );
					mapCorner = mapCorner2;
				}
			}
		}
		goto LABEL_42;
	}
}

//----- (0040DEBC) --------------------------------------------------------
void ChurchTilesVariationsChange()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			int cell = row*40 + col;
			uchar& curWallAndFloorMap = Map[ 0 ][ cell ];

			if( RangeRND(0, 4) ){// 25 шанс выбора другого тайла
				continue;
			}

			int tileGroupNumber = ChurchTilesVariationsTable[curWallAndFloorMap];
			if( !tileGroupNumber || ChurchWallFlagMap[ 0 ][ cell ] ){
				continue;
			}

			int randCounter = RangeRND(0, 16);
			int newTileIndex = -1;
			while( randCounter >= 0 ){
				if( ++newTileIndex == CHR_WAFM_206_POISON_WELL_ENTER ){// последний тайл церкви
					newTileIndex = CHR_WAFM_0;// проматываем назад
				}
				if( ChurchTilesVariationsTable[newTileIndex] == tileGroupNumber ){// находим randCounter по счёту тайл того же типа
					randCounter--;
				}
			}

			if( newTileIndex == CHR_WAFM_89_HALL_OF_HEROS_11 ){// какие то особые случаи
				int prevColCell = (row+0)*40 + (col-1);
				uchar* prevColWallAndFloorMap = &Map[ 0 ][ prevColCell ];
				if( ChurchTilesVariationsTable[*prevColWallAndFloorMap] != CHR_WAFM_79_HALL_OF_HEROS_1 || ChurchWallFlagMap[ 0 ][ prevColCell ] ){
					newTileIndex = CHR_WAFM_79_HALL_OF_HEROS_1;
				}else{
					*prevColWallAndFloorMap = CHR_WAFM_90_HALL_OF_HEROS_12;
				}
			}

			if( newTileIndex == CHR_WAFM_91_HALL_OF_HEROS_13 ){
				int nextRowCell = (row+1)*40 + (col+0);
				uchar* nextRowWallAndFloorMap = &Map[ 0 ][ nextRowCell ];
				if( ChurchTilesVariationsTable[*nextRowWallAndFloorMap] != CHR_WAFM_80_HALL_OF_HEROS_2 || ChurchWallFlagMap[ 0 ][ nextRowCell ] ){
					newTileIndex = CHR_WAFM_80_HALL_OF_HEROS_2;
				}else{
					*nextRowWallAndFloorMap = CHR_WAFM_92_HALL_OF_HEROS_14;
				}
			}

			curWallAndFloorMap = newTileIndex;
		}
	}
}

//----- (0040DF9F) --------------------------------------------------------
void SetupChurchHallsPassagesAndPlaceSpecialPatternsInRandomHall()
{
	// настройка залов на главной диагонали
	if( IsFirstBigChurchHallPlaced ){
		SetupChurchHall(0, 14, 0, 0, 0, 1);
	}
	if( IsSecondBigChurchHallPlaced ){
		SetupChurchHall(14, 14, 0, 0, IsFirstBigChurchHallPlaced, IsThirdBigChurchHallPlaced);
	}
	if( IsThirdBigChurchHallPlaced ){
		SetupChurchHall(28, 14, 0, 0, 1, 0);
	}

	// настройка корридоров на главной диагонали
	if( IsFirstBigChurchHallPlaced ){
		if( !IsSecondBigChurchHallPlaced ){
			goto LABEL_24;
		}
		SetupChurchPassage( 12, 18, 14, 18 );
	}
	if( IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
		SetupChurchPassage( 26, 18, 28, 18 );
	}
	LABEL_24:
	if( IsFirstBigChurchHallPlaced && !IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
		SetupChurchPassage( 12, 18, 28, 18 );
	}

	// настройка залов на побочной диагонали
	if( IsFirstBigChurchHallPlaced2 ){
		SetupChurchHall(14, 0, 0, 1, 0, 0);
	}
	if( IsSecondBigChurchHallPlaced2 ){
		SetupChurchHall(14, 14, IsFirstBigChurchHallPlaced2, IsThirdBigChurchHallPlaced2, 0, 0);
	}
	if( IsThirdBigChurchHallPlaced2 ){
		SetupChurchHall(14, 28, 1, 0, 0, 0);
	}

	// настройка корридоров на побочной диагонали
	if( IsFirstBigChurchHallPlaced2 ){
		if( !IsSecondBigChurchHallPlaced2 ){
			goto LABEL_51;
		}
		SetupChurchPassage( 18, 12, 18, 14 );
	}
	if( IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
		SetupChurchPassage( 18, 26, 18, 28 );
	}
	LABEL_51:
	if( IsFirstBigChurchHallPlaced2 && !IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
		SetupChurchPassage( 18, 12, 18, 28 );
	}
	#ifdef GENERATE_UBER // сейчас комната грузится из файла
	// выбор зала для размещения коморки убера и размещение её
	if( DungeonLevel == 24 ){
		bool mayPlaceUberRoom = true;
		int uberRoomRow = 0;
		int uberRoomCol = 0;
		int uberHallIndex = 1;
		if( IsFirstBigChurchHallPlaced2 || IsSecondBigChurchHallPlaced2 || IsThirdBigChurchHallPlaced2 ){
			if( !IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				if( RangeRND(0, 2) ){
					uberHallIndex = 2;
				}
			}
			if( IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && !IsThirdBigChurchHallPlaced2 ){
				if( RangeRND(0, 2) ){
					uberHallIndex = 0;
				}
			}
			if( IsFirstBigChurchHallPlaced2 && !IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				uberHallIndex = (-(RangeRND(0, 2) != 0) & 0xFFFFFFFE) + 2;
			}
			if( IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				uberHallIndex = RangeRND(0, 3);
			}

			uberRoomRow = 16;
			switch (uberHallIndex ){
			case 0:	uberRoomCol = 2;	break;
			case 1:	uberRoomCol = 16;	break;
			case 2:	uberRoomCol = 30;	break;
			default: mayPlaceUberRoom = false;	break;
			}
		}else{
			if( !IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				if( RangeRND(0, 2) ){
					uberHallIndex = 2;
				}
			}
			if( IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && !IsThirdBigChurchHallPlaced ){
				if( RangeRND(0, 2) ){
					uberHallIndex = 0;
				}
			}
			if( IsFirstBigChurchHallPlaced && !IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				uberHallIndex = (-(RangeRND(0, 2) != 0) & 0xFFFFFFFE) + 2;
			}
			if( IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				uberHallIndex = RangeRND(0, 3);
			}
			uberRoomCol = 16;
			switch (uberHallIndex ){
			case 0:	uberRoomRow = 2;	break;
			case 1:	uberRoomRow = 16;	break;
			case 2:	uberRoomRow = 30;	break;
			default: mayPlaceUberRoom = false;	break;
			}
		}
		if( mayPlaceUberRoom ){
			CopyCryptLastBossPatternToMap(uberRoomRow, uberRoomCol);
		}
	}
	#endif
	// выбор зала для комнаты камня мира и установка его
	if( DungeonLevel >= 21 && DungeonLevel <= 22 ){
		bool mayPlaceCornerstoneRoom = true;
		int cornerstoneRoomRow = 0;
		int cornerstoneRoomCol = 0;
		int cornerstoneHallIndex = 1;
		if( IsFirstBigChurchHallPlaced2 || IsSecondBigChurchHallPlaced2 || IsThirdBigChurchHallPlaced2 ){
			if( !IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				if( RangeRND(0, 2) ){
					cornerstoneHallIndex = 2;
				}
			}
			if( IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && !IsThirdBigChurchHallPlaced2 ){
				if( RangeRND(0, 2) ){
					cornerstoneHallIndex = 0;
				}
			}
			if( IsFirstBigChurchHallPlaced2 && !IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				cornerstoneHallIndex = (-(RangeRND(0, 2) != 0) & 0xFFFFFFFE) + 2;
			}
			if( IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				cornerstoneHallIndex = RangeRND(0, 3);
			}

			cornerstoneRoomRow = 16;
			switch (cornerstoneHallIndex ){
			case 0:	cornerstoneRoomCol = 2;	break;
			case 1:	cornerstoneRoomCol = 16;	break;
			case 2:	cornerstoneRoomCol = 30;	break;
			default: mayPlaceCornerstoneRoom = false;	break;
			}
		}else{
			if( !IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				if( RangeRND(0, 2) ){
					cornerstoneHallIndex = 2;
				}
			}
			if( IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && !IsThirdBigChurchHallPlaced ){
				if( RangeRND(0, 2) ){
					cornerstoneHallIndex = 0;
				}
			}
			if( IsFirstBigChurchHallPlaced && !IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				cornerstoneHallIndex = (-(RangeRND(0, 2) != 0) & 0xFFFFFFFE) + 2;
			}
			if( IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				cornerstoneHallIndex = RangeRND(0, 3);
			}

			cornerstoneRoomCol = 16;
			switch (cornerstoneHallIndex ){
			case 0:	cornerstoneRoomRow = 2;	break;
			case 1:	cornerstoneRoomRow = 16;	break;
			case 2:	cornerstoneRoomRow = 30;	break;
			default: mayPlaceCornerstoneRoom = false;	break;
			}
		}
		if( mayPlaceCornerstoneRoom ){
			CopyCornerstoneRoomPatternToMap(cornerstoneRoomRow, cornerstoneRoomCol);
		}
	}

	// комната мясника, вход в гробницу леорика, вход в локу хоразона либо заблокированный проход вниз
	if( IsChurchHallDUNFileLoaded ){
		bool mayPlaceSomeRoom = true;
		int someRoomRow = 0;
		int someRoomCol = 0;
		int someHallIndex = 1;

		if( IsFirstBigChurchHallPlaced2 || IsSecondBigChurchHallPlaced2 || IsThirdBigChurchHallPlaced2 ){
			if( !IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				if( RangeRND(0, 2) ){
					someHallIndex = 2;
				}
			}
			if( IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && !IsThirdBigChurchHallPlaced2 ){
				if( RangeRND(0, 2) ){
					someHallIndex = 0;
				}
			}
			if( IsFirstBigChurchHallPlaced2 && !IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				someHallIndex = (-(RangeRND(0, 2) != 0) & 0xFFFFFFFE) + 2;
			}
			if( IsFirstBigChurchHallPlaced2 && IsSecondBigChurchHallPlaced2 && IsThirdBigChurchHallPlaced2 ){
				someHallIndex = RangeRND(0, 3);
			}

			someRoomRow = 16;
			switch (someHallIndex ){
			case 0:	someRoomCol = 2;	break;
			case 1:	someRoomCol = 16;	break;
			case 2:	someRoomCol = 30;	break;
			default: mayPlaceSomeRoom = false;	break;
			}
		}else{
			if( !IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				if( RangeRND(0, 2) ){
					someHallIndex = 2;
				}
			}
			if( IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && !IsThirdBigChurchHallPlaced ){
				if( RangeRND(0, 2) ){
					someHallIndex = 0;
				}
			}
			if( IsFirstBigChurchHallPlaced && !IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				someHallIndex = (-(RangeRND(0, 2) != 0) & 0xFFFFFFFE) + 2;
			}
			if( IsFirstBigChurchHallPlaced && IsSecondBigChurchHallPlaced && IsThirdBigChurchHallPlaced ){
				someHallIndex = RangeRND(0, 3);
			}

			someRoomCol = 16;
			switch (someHallIndex ){
			case 0:	someRoomRow = 2;	break;
			case 1:	someRoomRow = 16;	break;
			case 2:	someRoomRow = 30;	break;
			default: mayPlaceSomeRoom = false;	break;
			}
		}
		if( mayPlaceSomeRoom ){
			SetSomePatternsBlock(someRoomRow, someRoomCol);
		}
	}
}

//----- (0040E70D) --------------------------------------------------------
void __fastcall SetupChurchHall( int row, int col, int hasCoridorInNE, int hasCoridorInSW, int hasCoridorInNW, int hasCoridorInSE )
{
	// настройка стен залов для красивого перехода в корридор с коллонами
	// Напоминалка компас:
	//    N 
	//   W E
	//    S 
	if( hasCoridorInNE == 1 ){
		Map[ row + 2 ][ col + 0 ] = CHR_WAFM_12_M_ARCH_MIDDLE;
		Map[ row + 3 ][ col + 0 ] = CHR_WAFM_12_M_ARCH_MIDDLE;
		Map[ row + 4 ][ col + 0 ] = CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH;

		Map[ row + 7 ][ col + 0 ] = CHR_WAFM_9_ARCH_LU_END;
		Map[ row + 8 ][ col + 0 ] = CHR_WAFM_12_M_ARCH_MIDDLE;
		Map[ row + 9 ][ col + 0 ] = CHR_WAFM_2_SWALL_M_MIDLE;
	}

	if( hasCoridorInSW == 1 ){
		Map[ row + 2 ][ col + 11 ] = CHR_WAFM_10_CORNER_BETWEEN_LD_SWALL_AND_RD_ARCH;
		Map[ row + 3 ][ col + 11 ] = CHR_WAFM_12_M_ARCH_MIDDLE;
		Map[ row + 4 ][ col + 11 ] = CHR_WAFM_8_ARCH_RU_END;

		Map[ row + 7 ][ col + 11 ] = CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH;
		Map[ row + 8 ][ col + 11 ] = CHR_WAFM_12_M_ARCH_MIDDLE;
		if( Map[ row + 9 ][ col + 11 ] != CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL ){
			Map[ row + 9 ][ col + 11 ] = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
		}
	}

	if( hasCoridorInNW == 1 ){
		Map[ row + 0 ][ col + 2 ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
		Map[ row + 0 ][ col + 3 ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
		Map[ row + 0 ][ col + 4 ] = CHR_WAFM_3_CORNER_BETWEEN_LU_ARCH_AND_RU_ARCH;

		Map[ row + 0 ][ col + 7 ] = CHR_WAFM_8_ARCH_RU_END;
		Map[ row + 0 ][ col + 8 ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
		Map[ row + 0 ][ col + 9 ] = CHR_WAFM_1_SWALL_UNM_MIDDLE;
	}

	if( hasCoridorInSE == 1 ){
		Map[ row + 11 ][ col + 2 ] = CHR_WAFM_14_CORNER_BETWEEN_LD_ARCH_AND_RD_SWALL;
		Map[ row + 11 ][ col + 3 ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
		Map[ row + 11 ][ col + 4 ] = CHR_WAFM_9_ARCH_LU_END;

		Map[ row + 11 ][ col + 7 ] = CHR_WAFM_5_CORNER_BETWEEN_LD_ARCH_AND_RD_ARCH;
		Map[ row + 11 ][ col + 8 ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
		if( Map[ row + 11 ][ col + 9 ] != CHR_WAFM_4_CORNER_BETWEEN_LD_SWALL_AND_RD_SWALL ){
			Map[ row + 11 ][ col + 9 ] = CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD;
		}
	}

	// зал заполняется полом
	for( int colOffset = 0; colOffset < 10; colOffset++ ){
		for( int rowOffset = 0; rowOffset < 10; rowOffset++ ){
			int cell = (col + 1 + colOffset) + 40 * (row + 1 + rowOffset);
			ChurchWallFlagMap[ 0 ][ cell ] |= BIT(7);
			Map[ 0 ][ cell ] = CHR_WAFM_13_FLOOR;
		}
	}

	// посередине симметрично 4 колонны
	Map[ row + 4 ][ col + 4 ] = CHR_WAFM_15_PILLAR;
	Map[ row + 7 ][ col + 4 ] = CHR_WAFM_15_PILLAR;
	Map[ row + 4 ][ col + 7 ] = CHR_WAFM_15_PILLAR;
	Map[ row + 7 ][ col + 7 ] = CHR_WAFM_15_PILLAR;
}

//----- (0040E858) --------------------------------------------------------
void __fastcall SetupChurchPassage( int startRow, int startCol, int endRow, int endCol )
{
	//if( CurVP > StartValidatingPoint ){
	//	__debugbreak();
	//}
	// расстановка в 2 ряда связанных колонн в коридорах
	if( startCol == endCol ){
		// main diagonal
		for( int row = startRow; row < endRow; row++ ){
			Map[ row ][ startCol + 0 ] = CHR_WAFM_12_M_ARCH_MIDDLE;
			Map[ row ][ startCol + 3 ] = CHR_WAFM_12_M_ARCH_MIDDLE;
		}
	}else{
		// unmain diagonal
		for( int col = startCol; col < endCol; col++ ){
			Map[ startRow + 0 ][ col ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
			Map[ startRow + 3 ][ col ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
		}
	}
	//// расстановка в 2 ряда связанных колонн в коридорах
	//if( startCol == endCol ){
	//	// main diagonal
	//	if( startRow < endRow ){
	//		int row = endRow - startRow;
	//		uchar* cell = &Map[ startRow ][ startCol + 3 ];
	//		do{
	//			*(cell - 3) = CHR_WAFM_12_M_ARCH_MIDDLE;
	//			*cell = CHR_WAFM_12_M_ARCH_MIDDLE;
	//			cell += 40;
	//			--row;
	//		}while( row );
	//	}
	//}else{
	//	// unmain diagonal
	//	int col = startCol;
	//	if( startCol < endCol ){
	//		uchar* cell = Map[ startRow + 3 ];
	//		do{
	//			cell[ col - 120 ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
	//			cell[ col++ ] = CHR_WAFM_11_UNM_ARCH_MIDDLE;
	//		}while( col < endCol );
	//	}
	//}
}

//----- (0040E8A8) --------------------------------------------------------
void __fastcall SetSomePatternsBlock( int row, int col )
{
	ushort* dunFilePtr = (ushort*)DUNFilePtr;
	StartPatternRow40 = row;
	StartPatternCol40 = col;
	PatternMapRows = dunFilePtr[0];
	PatternMapCols = dunFilePtr[1];
	int patMapOffset = 2;
	for( int colOffset = 0; colOffset < PatternMapCols; colOffset++ ){
		for( int rowOffset = 0; rowOffset < PatternMapRows; rowOffset++ ){
			int cell = col + colOffset + 40 * (row + rowOffset);
			int newTile = dunFilePtr[2 + rowOffset + colOffset*PatternMapRows];
			if( newTile ){
				ChurchWallFlagMap[ 0 ][ cell ] |= BIT(8);
				Map[ 0 ][ cell ] = newTile;
			}else{
				Map[ 0 ][ cell ] = CHR_WAFM_13_FLOOR;
			}
		}
	}
}

//----- (0040E92D) --------------------------------------------------------
void __fastcall CopyCryptLastBossPatternToMap(int row, int col)
{
	UberRow = 2 * row + 6;
	UberCol = 2 * col + 8;
	StartPatternRow40 = row;
	StartPatternCol40 = col;
	PatternMapRows = UberRoomPattern[0];
	PatternMapCols = UberRoomPattern[1];

	IsUberRoomOpened = 0;
	SomeDword_64 = 0;
	IsUberLeverActivated = 0;

	int patMapOffset = 2;
	for( int colOffset = 0; colOffset < PatternMapCols; colOffset++ ){
		for( int rowOffset = 0; rowOffset < PatternMapRows; rowOffset++ ){
			int cell = col + colOffset + 40 * (row + rowOffset);
			int newTile = UberRoomPattern[patMapOffset];
			if( newTile ){
				ChurchWallFlagMap[ 0 ][ cell ] |= BIT(8);
				Map[ 0 ][ cell ] = newTile;
			}else{
				Map[ 0 ][ cell ] = CHR_WAFM_13_FLOOR;
			}
			patMapOffset++;
		}
	}
}

//----- (0040E9DC) --------------------------------------------------------
void __fastcall CopyCornerstoneRoomPatternToMap(int row, int col)
{
	StartPatternRow40 = row;
	StartPatternCol40 = col;
	PatternMapRows = CornerstoneRoomPattern[0];
	PatternMapCols = CornerstoneRoomPattern[1];

	int patMapOffset = 2;
	for( int colOffset = 0; colOffset < PatternMapCols; colOffset++ ){
		for( int rowOffset = 0; rowOffset < PatternMapRows; rowOffset++ ){
			int cell = col + colOffset + 40 * (row + rowOffset);
			int newTile = CornerstoneRoomPattern[patMapOffset];
			if( newTile ){
				ChurchWallFlagMap[ 0 ][ cell ] |= BIT(8);
				Map[ 0 ][ cell ] = newTile;
			}else{
				Map[ 0 ][ cell ] = CHR_WAFM_13_FLOOR;
			}
			patMapOffset++;
		}
	}
}

//----- (0040EA67) --------------------------------------------------------
void InitChurchWallsTransparency()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			if( Map[ row ][ col ] == CHR_WAFM_13_FLOOR && !HallMap[Convert40to112(row)][Convert40to112(col)] ){ // пол не отнесённый ни к одной из комнат относим к новой комнате
				SetChurchCellTransparency(row, col, Convert40to112(row), Convert40to112(col), 0);
				HallIndex++;
			}
		}
	}
}

//----- (0040EAD6) --------------------------------------------------------
void __fastcall SetChurchCellTransparency( int row40, int col40, int row112, int col112, int orientation )
{
	uchar wallTransparentIndex = HallIndex;
	int curRow112 = row112;
	int curCol112 = col112;
	int curCol40 = col40;
	int curRow40 = row40;
	while( Map[ curRow40 ][ curCol40 ] == CHR_WAFM_13_FLOOR && !HallMap[curRow112][curCol112] ){
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		// row ->
		//5 4 6
		//2 0 1
		//7 3 8
		SetChurchCellTransparency(curRow40 + 1,	curCol40,		curRow112 + 2,		curCol112,			1);
		SetChurchCellTransparency(curRow40 - 1,	curCol40,		curRow112 - 2,		curCol112,			2);
		SetChurchCellTransparency(curRow40,		curCol40 + 1,	curRow112,			curCol112 + 2,		3);
		SetChurchCellTransparency(curRow40,		curCol40 - 1,	curRow112,			curCol112 - 2,		4);
		SetChurchCellTransparency(curRow40 - 1,	curCol40 - 1,	curRow112 - 2,		curCol112 - 2,		5);
		SetChurchCellTransparency(curRow40 + 1,	curCol40 - 1,	curRow112 + 2,		curCol112 - 2,		6);
		SetChurchCellTransparency(curRow40 - 1,	curCol40 + 1,	curRow112 - 2,		curCol112 + 2,		7);
		orientation = 8;
		curCol40++;
		curRow40++;
		curRow112 = Convert40to112(curRow40);
		curCol112 = Convert40to112(curCol40);
	}

	switch (orientation ){
	case 1:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 2:
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 3:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	case 4:
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 5:
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 6:
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 7:
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	case 8:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	}
}

//----- (0040ECCA) --------------------------------------------------------
void ChurchSetAdditionalWallsTransparency()
{
	for( int col40 = 0; col40 < 40; col40++ ){
		for( int row40 = 0; row40 < 40; row40++ ){

			uchar curWallAndFloorMap =		Map[ row40+0 ][ col40+0 ];
			uchar nextRowWallAndFloorMap =	Map[ row40+1 ][ col40+0 ];
			uchar prevColWallAndFloorMap =	Map[ row40+0 ][ col40-1 ];

			uchar* curTransparentWallsMap =			&HallMap[ (Convert40to112(row40)+0) ][ (Convert40to112(col40)+0) ];
			uchar* nextRowTransparentWallsMap =		&HallMap[ (Convert40to112(row40)+1) ][ (Convert40to112(col40)+0) ];
			uchar* nextColTransparentWallsMap =		&HallMap[ (Convert40to112(row40)+0) ][ (Convert40to112(col40)+1) ];
			uchar* nextRowColTransparentWallsMap =	&HallMap[ (Convert40to112(row40)+1) ][ (Convert40to112(col40)+1) ];
			switch (curWallAndFloorMap ){
			case CHR_WAFM_23_BEYOND_WALL_IN_LU_2:
				if( prevColWallAndFloorMap == CHR_WAFM_18_BEYOND_WALL_IN_LU ){
					*nextRowTransparentWallsMap = *curTransparentWallsMap;
					*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				}
				break;
			case CHR_WAFM_24_BEYOND_WALL_IN_RU_2:
				if( nextRowWallAndFloorMap == CHR_WAFM_19_BEYOND_WALL_IN_RU ){
					*nextColTransparentWallsMap = *curTransparentWallsMap;
					*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				}
				break;
			case CHR_WAFM_18_BEYOND_WALL_IN_LU:
				*nextRowTransparentWallsMap = *curTransparentWallsMap;
				*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				break;
			case CHR_WAFM_19_BEYOND_WALL_IN_RU:
				*nextColTransparentWallsMap = *curTransparentWallsMap;
				*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				break;
			case CHR_WAFM_20_BEYOND_WALL_CORNER_BETWEEN_LU_AND_RU:
				*nextRowTransparentWallsMap = *curTransparentWallsMap;
				*nextColTransparentWallsMap = *curTransparentWallsMap;
				*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				break;
			}
		}
	}
}

//----- (0040ED5E) --------------------------------------------------------
void SomeConvertChurchAndCryptWalls()
{
	if( DungeonLevel >= 21 ){

		for( int col40 = 0; col40 < 39; col40++ ){
			for( int row40 = 0; row40 < 39; row40++ ){
				uchar* wallAndFloorMap = &Map[ row40 ][ col40 ];
				switch (*wallAndFloorMap ){
				case CHR_WAFM_19_BEYOND_WALL_IN_RU:							*wallAndFloorMap = CHR_WAFM_83_HALL_OF_HEROS_5;		break;
				case CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD:	*wallAndFloorMap = CHR_WAFM_85_HALL_OF_HEROS_7;		break;
				case CHR_WAFM_23_BEYOND_WALL_IN_LU_2:							*wallAndFloorMap = CHR_WAFM_87_HALL_OF_HEROS_9;		break;
				case CHR_WAFM_24_BEYOND_WALL_IN_RU_2:							*wallAndFloorMap = CHR_WAFM_88_HALL_OF_HEROS_10;		break;
				case CHR_WAFM_18_BEYOND_WALL_IN_LU:							*wallAndFloorMap = CHR_WAFM_82_HALL_OF_HEROS_4;		break;
				}
			}
		}

	}else{ // Cathedral

		for( int col40 = 0; col40 < 39; col40++ ){
			for( int row40 = 0; row40 < 39; row40++ ){
				uchar* curWallAndFloorMap = &Map[ row40+0 ][ col40+0 ];
				uchar nextRowWallAndFloorMap = Map[ row40+1 ][ col40+0 ];
				uchar nextColWallAndFloorMap = Map[ row40+0 ][ col40+1 ];

				switch (*curWallAndFloorMap ){
				case CHR_WAFM_21_BEYOND_WALL_CORNER_BETWEEN_LD_AND_RD:							
					if( nextRowWallAndFloorMap != CHR_WAFM_19_BEYOND_WALL_IN_RU ){
						*curWallAndFloorMap = CHR_WAFM_202_BEYOND;
					}
					if( nextColWallAndFloorMap != CHR_WAFM_18_BEYOND_WALL_IN_LU ){
						*curWallAndFloorMap = CHR_WAFM_202_BEYOND;
					}
					break;
				case CHR_WAFM_19_BEYOND_WALL_IN_RU:							
					if( nextRowWallAndFloorMap != CHR_WAFM_19_BEYOND_WALL_IN_RU ){
						*curWallAndFloorMap = CHR_WAFM_200_BEYOND;
					}
					break;
				case CHR_WAFM_24_BEYOND_WALL_IN_RU_2:							
					if( nextRowWallAndFloorMap != CHR_WAFM_19_BEYOND_WALL_IN_RU ){
						*curWallAndFloorMap = CHR_WAFM_205_BEYOND;
					}
					break;
				case CHR_WAFM_18_BEYOND_WALL_IN_LU:							
					if( nextColWallAndFloorMap != CHR_WAFM_18_BEYOND_WALL_IN_LU ){
						*curWallAndFloorMap = CHR_WAFM_199_BEYOND;
					}
					break;
				case CHR_WAFM_23_BEYOND_WALL_IN_LU_2:							
					if( nextColWallAndFloorMap != CHR_WAFM_18_BEYOND_WALL_IN_LU ){
						*curWallAndFloorMap = CHR_WAFM_204_BEYOND;
					}
					break;
				}
			}
		}

	}
}

//----- (0040EE13) --------------------------------------------------------
void SomeMoreChurchWallsConvert()
{
	int v0;     // edi@1
	uchar* result; // eax@2
	uchar*  v2;     // ecx@2
	int v3;     // ebx@2
	int v4;     // esi@2
	v0 = 1;
	do{
		v2 = &Map[ 0 ][ v0 + 41 ]; // !*!*!***обнаружена абсолютная адресация***!*!*!
		v4 = v0;
		v3 = 38;
		result = &Map[ 0 ][ v0 + 40 ]; // !*!*!***обнаружена абсолютная адресация***!*!*!
		do{
			if( !(ChurchWallFlagMap[ 0 ][ v4 + 40 ] & BIT(8)) ){
				if( *result == CHR_WAFM_17_WALL_RD_END && *(uchar*)(result - 40) == CHR_WAFM_13_FLOOR && *(result - 1) == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
					ChurchWallFlagMap[ 0 ][ v4 + 39 ] &= BIT(8);
					*result = CHR_WAFM_16_WALL_LD_END;
				}
			}
			if( *result == CHR_WAFM_202_BEYOND && Map[ 2 ][ v4 ] == CHR_WAFM_13_FLOOR && *v2 == CHR_WAFM_1_SWALL_UNM_MIDDLE ){
				*result = CHR_WAFM_8_ARCH_RU_END;
			}
			v4 += 40;
			v2 += 40;
			result += 40;
			--v3;
		}while( v3 );
		++v0;
	}while( v0 < 39 );
}

//----- (0040EE7A) --------------------------------------------------------
void __fastcall PlaceSomeCryptPatterns_1( int a1 )
{
	PlaceCryptPatternOnMap(PatMap1x1_48A3C8, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3CC, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3D0, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3D4, a1);
}

//----- (0040EEAF) --------------------------------------------------------
void __fastcall PlaceSomeCryptPatterns_2( int a1 )
{
	PlaceCryptPatternOnMap(PatMap1x1p5, a1);
	PlaceCryptPatternOnMap(PatMap1x1p6, a1);
	PlaceCryptPatternOnMap(PatMap1x1p7, a1);
	PlaceCryptPatternOnMap(PatMap1x1p8, a1);
	PlaceCryptPatternOnMap(PatMap1x1p9, a1);
	PlaceCryptPatternOnMap(PatMap1x1q1, a1);
	PlaceCryptPatternOnMap(PatMap1x1q2, a1);
	PlaceCryptPatternOnMap(PatMap1x1q3, a1);
	PlaceCryptPatternOnMap(PatMap1x1q4, a1);
	PlaceCryptPatternOnMap(PatMap1x1q5, a1);
	PlaceCryptPatternOnMap(PatMap1x1q6, a1);
	PlaceCryptPatternOnMap(PatMap1x1q7, a1);
	PlaceCryptPatternOnMap(PatMap1x1q8, a1);
	PlaceCryptPatternOnMap(PatMap1x1q9, a1);
	PlaceCryptPatternOnMap(PatMap1x1w1, a1);
	PlaceCryptPatternOnMap(PatMap1x1w2, a1);
	PlaceCryptPatternOnMap(PatMap1x1w3, a1);
}

//----- (0040EF80) --------------------------------------------------------
void __fastcall PlaceSomeCryptPatterns_3( int a1 )
{
	PlaceCryptPatternOnMap(PatMap1x1w4, a1);
	PlaceCryptPatternOnMap(PatMap1x1w5, a1);
	PlaceCryptPatternOnMap(PatMap1x1w6, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A34C, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A350, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A354, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A358, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A35C, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A360, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A364, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A368, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A36C, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A370, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A374, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A378, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A37C, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A380, a1);
}

//----- (0040F051) --------------------------------------------------------
void __fastcall PlaceSomeCryptPatterns_4( int a1 )
{
	PlaceCryptPatternOnMap(PatMap1x1_48A384, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A388, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A38C, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A390, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A394, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A398, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A39C, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3A0, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3A4, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3A8, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3AC, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3B0, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3B4, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3B8, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3BC, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3C0, a1);
	PlaceCryptPatternOnMap(PatMap1x1_48A3C4, a1);
}

//----- (0040F122) --------------------------------------------------------
void __fastcall PlaceSomeCryptPatterns_5( int a1 )
{
	PlaceCryptPatternOnMap(PatMap3x3q, a1);
	PlaceCryptPatternOnMap(PatMap3x3w, a1);
	PlaceCryptPatternOnMap(PatMap3x3e, a1);
	PlaceCryptPatternOnMap(PatMap3x3r, a1);
	PlaceCryptPatternOnMap(PatMap3x3t, a1);
	PlaceCryptPatternOnMap(PatMap3x3y, a1);
	PlaceCryptPatternOnMap(PatMap1x1p1, a1);
	PlaceCryptPatternOnMap(PatMap1x1p2, a1);
	PlaceCryptPatternOnMap(PatMap1x1p3, a1);
	PlaceCryptPatternOnMap(PatMap1x1p4, a1);
}

//----- (0040F19F) --------------------------------------------------------
void __fastcall PlaceSomeCryptPatterns_7( int a1 )
{
	PlaceCryptPatternOnMap(PatMap1x1a, a1);
	PlaceCryptPatternOnMap(PatMap1x1d, a1);
	PlaceCryptPatternOnMap(PatMap1x1s, a1);
	PlaceCryptPatternOnMap(PatMap1x1f, a1);
	PlaceCryptPatternOnMap(PatMap1x1g, a1);
	PlaceCryptPatternOnMap(PatMap1x1h, a1);
	PlaceCryptPatternOnMap(PatMap1x1j, a1);
	PlaceCryptPatternOnMap(PatMap1x1k, a1);
	PlaceCryptPatternOnMap(PatMap1x1l, a1);
	PlaceCryptPatternOnMap(PatMap1x1z, a1);
	PlaceCryptPatternOnMap(PatMap1x1x, a1);
	PlaceCryptPatternOnMap(PatMap1x1c, a1);
	PlaceCryptPatternOnMap(PatMap1x1v, a1);
	PlaceCryptPatternOnMap(PatMap1x1b, a1);
	PlaceCryptPatternOnMap(PatMap1x1n, a1);
	PlaceCryptPatternOnMap(PatMap1x1m, a1);
	PlaceCryptPatternOnMap(PatMap1x1q, a1);
	PlaceCryptPatternOnMap(PatMap1x1w, a1);
	PlaceCryptPatternOnMap(PatMap1x1e, a1);
	PlaceCryptPatternOnMap(PatMap1x1r, a1);
	PlaceCryptPatternOnMap(PatMap1x1t, a1);
	PlaceCryptPatternOnMap(PatMap1x1y, a1);
	PlaceCryptPatternOnMap(PatMap1x1u, a1);
	PlaceCryptPatternOnMap(PatMap1x1i, a1);
	PlaceCryptPatternOnMap(PatMap1x1o, a1);
	PlaceCryptPatternOnMap(PatMap1x1p, a1);
}

//----- (0040F2DC) --------------------------------------------------------
void __fastcall PlaceSomeCryptPatterns_6( int a1 )
{
	PlaceCryptPatternOnMap(Pat3Map1x1, a1);
	PlaceCryptPatternOnMap(Pat4Map1x1, a1);
	PlaceCryptPatternOnMap(Pat5Map1x1, a1);
	PlaceCryptPatternOnMap(Pat6Map1x1, a1);
}

//----- (0040F311) --------------------------------------------------------
void InitCataMaps()
{
	for( int cell = 0; cell < 40*40; cell++ ){
		FixedMap[ 0 ][ cell ] = 0;
		CatacombMapAdvance[ 0 ][ cell ] = CATA_MA_32_BEYOND;
	}
}

//----- (0040F333) --------------------------------------------------------
void AddAdditionalCataDoors()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar& curWallAndFloorMap = Map[ row+0 ][ col+0 ];
			uchar& prevRowWallAndFloorMap = Map[ row-1 ][ col+0 ];
			uchar& prevColWallAndFloorMap = Map[ row+0 ][ col-1 ];

			if( curWallAndFloorMap == CATA_WAFM_4_LU_ODOOR && prevRowWallAndFloorMap != CATA_WAFM_3_FLOOR ){
				curWallAndFloorMap = CATA_WAFM_1_LU_WALL;
			}
			if( curWallAndFloorMap == CATA_WAFM_5_RU_ODOOR && prevColWallAndFloorMap != CATA_WAFM_3_FLOOR ){
				curWallAndFloorMap = CATA_WAFM_2_RU_WALL;
			}
		}
	}

	for( int col = 1; col < 39; col++ ){
		for( int row = 1; row < 39; row++ ){
			int cell = col + 40 * row;
			if( FixedMap[row][col] & BIT(8) ){
				continue;
			}

			uchar curMap = Map[ row+0 ][ col+0 ];
			if( curMap != CATA_WAFM_2_RU_WALL && curMap != CATA_WAFM_5_RU_ODOOR ){
				continue;
			}

			uchar prevColMap = Map[ row+0 ][ col-1 ];
			uchar nextColMap = Map[ row+0 ][ col+1 ];
			if( prevColMap != CATA_WAFM_3_FLOOR || nextColMap != CATA_WAFM_3_FLOOR ){
				continue;
			}

			// двигаемся по стене, ища двери и конец стены
			bool isWallHasDoor = false;
			while( true ){

				uchar curMap = Map[ row+0 ][ col+0 ];
				if( curMap != CATA_WAFM_2_RU_WALL && curMap != CATA_WAFM_5_RU_ODOOR ){
					break;
				}

				uchar prevColMap = Map[ row+0 ][ col-1 ];
				uchar nextColMap = Map[ row+0 ][ col+1 ];
				if( prevColMap != CATA_WAFM_3_FLOOR || nextColMap != CATA_WAFM_3_FLOOR ){
					break;
				}

				if( curMap == CATA_WAFM_5_RU_ODOOR ){
					isWallHasDoor = true;
				}

				++row;
			}

			// если на протяжении всей стены не было ни одной двери, то ставим дверь на нижнюю клетку стены
			uchar& doorMap = Map[ row-1 ][ col+0 ];
			if( !isWallHasDoor && !( doorMap & BIT(8) ) ){
				doorMap = CATA_WAFM_5_RU_ODOOR;
			}
		}
	}

	for( int row = 1; row < 39; row++ ){
		for( int col = 1; col < 39; col++ ){

			if( FixedMap[row][col] & BIT(8) ){
				continue;
			}

			uchar curMap = Map[ row+0 ][ col+0 ];
			if( curMap != CATA_WAFM_1_LU_WALL && curMap != CATA_WAFM_4_LU_ODOOR ){
				continue;
			}

			uchar prevRowMap = Map[ row-1 ][ col+0 ];
			uchar nextRowMap = Map[ row+1 ][ col+0 ];
			if( prevRowMap != CATA_WAFM_3_FLOOR || nextRowMap != CATA_WAFM_3_FLOOR ){
				continue;
			}

			// двигаемся по стене, ища двери и конец стены
			bool isWallHasDoor = false;
			while( true ){

				uchar curMap = Map[ row+0 ][ col+0 ];
				if( curMap != CATA_WAFM_1_LU_WALL && curMap != CATA_WAFM_4_LU_ODOOR ){
					break;
				}

				uchar prevRowMap = Map[ row-1 ][ col+0 ];
				uchar nextRowMap = Map[ row+1 ][ col+0 ];

				if( prevRowMap != CATA_WAFM_3_FLOOR || nextRowMap != CATA_WAFM_3_FLOOR ){
					break;
				}

				if( curMap == CATA_WAFM_4_LU_ODOOR ){
					isWallHasDoor = true;
				}

				++col;
			}

			// если на протяжении всей стены не было ни одной двери, то ставим дверь на нижнюю клетку стены
			uchar& doorMap = Map[ row+0 ][ col-1 ];
			if( !isWallHasDoor && !( doorMap & BIT(8) ) ){
				doorMap = CATA_WAFM_4_LU_ODOOR;
			}
		}
	}
}

//----- (0040F483) --------------------------------------------------------
void ReplaceEnderCataDoorsWithEnderWalls()
{
	for( int col = 1; col < 40; col++ ){
		for( int row = 1; row < 40; row++ ){
			uchar& curWallAndFloorMap =		Map[ row+0 ][ col+0 ];
			uchar& prevRowWallAndFloorMap =	Map[ row-1 ][ col+0 ];
			uchar& prevColWallAndFloorMap =	Map[ row+0 ][ col-1 ];

			if( curWallAndFloorMap == CATA_WAFM_4_LU_ODOOR && prevColWallAndFloorMap == CATA_WAFM_3_FLOOR ){
				curWallAndFloorMap = CATA_WAFM_7_CORNER;
			}
			if( curWallAndFloorMap == CATA_WAFM_5_RU_ODOOR && prevRowWallAndFloorMap == CATA_WAFM_3_FLOOR ){
				curWallAndFloorMap = CATA_WAFM_9_CORNER;
			}
		}
	}
}

//----- (0040F4B8) --------------------------------------------------------
void __fastcall LoadQuestDungeonMapMainCatacomb(char* arglist, int a2, int a3)
{
	int v3;             // edx@1
	char* v4;           // edi@1
	int v5;             // eax@2
	int v6;             // ecx@2
	int v7;             // eax@5
	int v8;             // ebx@5
	int v9;             // edi@5
	int* v10;           // esi@5
	int v11;            // ecx@7
	char v12;           // dl@8
	int v13;            // ecx@13
	unsigned char* v14; // eax@14
	int v15;            // edx@14
	int v16;            // ebx@19
	char* v17;          // ecx@20
	int v18;            // edi@20
	int* v19;           // esi@20
	char v20;           // al@21
	int v21;            // edx@21
	int v22;            // ecx@37
	int* v23;           // edi@37
	int* v25;           // edx@38
	int v26;            // ebx@38
	int v27;            // esi@39
	char* v28;          // esi@1
	char* v29;          // eax@1
	int v30;            // eax@5
	char v31;           // zf@11
	int v32;            // [sp+Ch] [bp-Ch]@1
	char* a1;           // [sp+10h] [bp-8h]@1
	int* v34;           // [sp+14h] [bp-4h]@7
	v32 = a2;
	v28 = arglist;
	InitCataMaps();
	ClearWallsTransparency();
	v29 = (char*)LoadFile(v28, NULL);
	v4 = v29;
	v3 = 0;
	a1 = v29;
	do{
		v5 = v3;
		v6 = 40;
		do{
			FixedMap[ 0 ][ v5 ] = 0;
			Map[ 0 ][ v5 ] = CATA_WAFM_12_BEYOND;
			v5 += 40;
			--v6;
		}while( v6 );
		++v3;
	}while( v3 < 40 );
	v10 = (int*)*v4;
	v30 = (int)(v4 + 2);
	v8 = 0;
	v9 = *(v4 + 2);
	v7 = v30 + 2;
	if( v9 > 0 ){
		do{
			if( (int)v10 > 0 ){
				v11 = v8;
				v34 = v10;
				do{
					v12 = *(uchar*)v7;
					if( *(uchar*)v7 ){
						FixedMap[ 0 ][ v11 ] = (unsigned __int8)FixedMap[ 0 ][ v11 ] | 0x80;
						Map[ 0 ][ v11 ] = v12;
					}else{
						Map[ 0 ][ v11 ] = CATA_WAFM_3_FLOOR;
					}
					v11 += 40;
					v7 += 2;
					v31 = v34 == (int*)1; //проверить чего код делает на самом деле. TODO: V566 http://www.viva64.com/en/V566 The integer constant is converted to pointer. Possibly an error or a bad coding style: (int*) 1
					v34 = (int*)((char*)v34 - 1);
				}while( !v31 );
			}
			++v8;
		}while( v8 < v9 );
	}
	v13 = 0;
	do{
		v14 = &Map[ 0 ][ v13 ];
		v15 = 40;
		do{
			if( !*v14 )
				*v14 = CATA_WAFM_12_BEYOND;
			v14 += 40;
			--v15;
		}while( v15 );
		++v13;
	}while( v13 < 40 );
	InitCatacombLevelTiles();
	ClearObjectMaps();
	v16 = 0;
	v34 = FineMap[ 0 ];
	do{
		v19 = v34;
		v17 = &ArchGraphicsMap[ 0 ][ v16 ];
		v18 = 112;
		do{
			v21 = *v19;
			v20 = 0;
			if( *v19 == 541 )
				v20 = 5;
			if( v21 == 178 )
				v20 = 5;
			if( v21 == 551 )
				v20 = 5;
			if( v21 == 542 )
				v20 = 6;
			if( v21 == 553 )
				v20 = 6;
			if( v21 == 13 )
				v20 = 5;
			if( v21 == 17 )
				v20 = 6;
			*v17 = v20;
			v19 += 112;
			v17 += 112;
			--v18;
		}while( v18 );
		++v34;
		++v16;
	}while( (int)v34 < (int)&FineMap[ 0 ][ 112 ] );
	v22 = 0;
	v23 = FineMap[ 0 ];
	do{
		char* v24 = &ArchGraphicsMap[ 0 ][ v22 + 2 ]; // !*!*!***обнаружена абсолютная адресация***!*!*!
		v25 = v23;
		v26 = 112;
		do{
			v27 = *v25;
			if( *v25 == 132 ){
				*(uchar*)(v24 - 1) = 2;
				*(uchar*)v24 = 1;
			}else{
				if( v27 == 135 || v27 == 139 ){
					*(uchar*)(v24 + 110) = 3;
					*(uchar*)(v24 + 222) = 4;
				}
			}
			v25 += 112;
			v24 += 112;
			--v26;
		}while( v26 );
		++v23;
		++v22;
	}while( (int)v23 < (int)&FineMap[ 0 ][ 112 ] );
	PlayerRowPos = v32;
	PlayerColPos = a3;
	AddQuestMonsters((ushort*)a1, 0, 0);
	AddQuestItems((int)a1, 0, 0);
	FreeMem(a1);
}

//----- (0040F678) --------------------------------------------------------
void InitCatacombLevelTiles()
{
	TileSquare* currentLevelTilesFile = (TileSquare*)CurrentLevelTilesFile;
	TileSquare& beyondTile = currentLevelTilesFile[ CATA_WAFM_12_BEYOND-1 ];

	// заполняем всю карту тайлами бейонда
	for( int col = 0; col < 112; col += 2 ){
		for( int row = 0; row < 112; row += 2 ){
			FineMap[ row + 0 ][ col + 0 ] = beyondTile.up + 1;
			FineMap[ row + 1 ][ col + 0 ] = beyondTile.left + 1;
			FineMap[ row + 0 ][ col + 1 ] = beyondTile.right + 1;
			FineMap[ row + 1 ][ col + 1 ] = beyondTile.down + 1;
		}
	}

	// проходим по всем клеткам и заполняем их значениями из загруженного TIL файла
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar wafm = Map[ row ][ col ];
			ushort up = 0;
			ushort left = 0;
			ushort right = 0;
			ushort down = 0;
			if( wafm ){
				TileSquare& currentTile = currentLevelTilesFile[ wafm-1 ];
				up = currentTile.up + 1;
				left = currentTile.left + 1;
				right = currentTile.right + 1;
				down = currentTile.down + 1;
			}
			FineMap[ 2*row + 0 + 16 ][ 2*col + 0 + 16 ] = up;
			FineMap[ 2*row + 1 + 16 ][ 2*col + 0 + 16 ] = left;
			FineMap[ 2*row + 0 + 16 ][ 2*col + 1 + 16 ] = right;
			FineMap[ 2*row + 1 + 16 ][ 2*col + 1 + 16 ] = down;
		}
	}
}

//----- (0040F76A) --------------------------------------------------------
void __fastcall LoadQuestDungeonMapAltCatacomb( char* arglist, int a2, int a3 )
{
	char* v2;           // ebx@1
	int v3;             // esi@1
	int v4;             // eax@2
	int v5;             // edx@2
	int v6;             // eax@5
	int i;              // edx@5
	int v8;             // edi@5
	int v9;             // esi@7
	char v10;           // bl@8
	int v11;            // eax@13
	unsigned char* v12; // edx@14
	int v13;            // esi@14
	int v14;            // eax@19
	int v15;            // edx@20
	int v16;            // esi@20
	char* v17;          // esi@1
	char* v18;          // eax@1
	char* a1;           // [sp+Ch] [bp-Ch]@1
	int v21;            // [sp+14h] [bp-4h]@5
	int v22;            // [sp+10h] [bp-8h]@7
	v17 = arglist;
	InitCataMaps();
	ClearWallsTransparency();
	v18 = (char*)LoadFile(v17, NULL);
	v2 = v18;
	v3 = 0;
	a1 = v18;
	do{
		v5 = v3;
		v4 = 40;
		do{
			FixedMap[ 0 ][ v5 ] = 0;
			Map[ 0 ][ v5 ] = CATA_WAFM_12_BEYOND;
			v5 += 40;
			--v4;
		}while( v4 );
		++v3;
	}while( v3 < 40 );
	v6 = *(v2 + 2);
	v21 = 0;
	v8 = *v2;
	for( i = (int)(v2 + 4); v21 < v6; ++v21 ){
		if( v8 > 0 ){
			v9 = v21;
			v22 = v8;
			do{
				v10 = *(uchar*)i;
				if( *(uchar*)i ){
					FixedMap[ 0 ][ v9 ] = (unsigned __int8)FixedMap[ 0 ][ v9 ] | 0x80;
					Map[ 0 ][ v9 ] = v10;
				}else{
					Map[ 0 ][ v9 ] = CATA_WAFM_3_FLOOR;
				}
				v9 += 40;
				i += 2;
			}while( v22-- != 1 );
		}
	}
	v11 = 0;
	do{
		v12 = &Map[ 0 ][ v11 ];
		v13 = 40;
		do{
			if( !*v12 )
				*v12 = CATA_WAFM_12_BEYOND;
			v12 += 40;
			--v13;
		}while( v13 );
		++v11;
	}while( v11 < 40 );
	v14 = 0;
	do{
		v15 = v14;
		v16 = 40;
		do{
			AltMap[ 0 ][ v15 ] = Map[ 0 ][ v15 ];
			v15 += 40;
			--v16;
		}while( v16 );
		++v14;
	}while( v14 < 40 );
	FreeMem(a1);
}

//----- (0040F840) --------------------------------------------------------
void __fastcall CreateCatacombTypeLabyrinth(int randomSeed, int loadingMode)
{
	if( MaxCountOfPlayersInGame == 1 ){
		if( DungeonLevel == 7 && Quests[Q_8_HALLS_OF_THE_BLIND].status == QS_0_NO ){
			DungeonLevel = 6;
			CreateCatacombTypeLabyrinth(LevelRandSeed[DungeonLevel], 4);
			DungeonLevel = 7;
		}else if( DungeonLevel == 8 ){
			DungeonLevel = Quests[Q_8_HALLS_OF_THE_BLIND].status ? 7 : 6;
			CreateCatacombTypeLabyrinth(LevelRandSeed[DungeonLevel], 4);
			DungeonLevel = 8;
		}
	}
	InitRandomSeed(randomSeed);
	MapStartRow = 16;
	MapStartCol = 16;
	MapEndRow = 96;
	MapEndCol = 96;
	ClearWallsTransparency();
	ResetPatternMapPos();
	LoadCatacombQuestMaps();
	CatacombLevelGeneration(loadingMode);
	InitCatacombLevelTiles();
	FreeQuestDungeonMapPtr();
	InitCataArchs();
	MarkPatternPositionOnMap();
}

//----- (0040F90B) --------------------------------------------------------
void LoadCatacombQuestMaps()
{
	LoadedQuestDungeonMap = 0;
	if( IsQuestOnLevel(Q_8_HALLS_OF_THE_BLIND) ){
		QuestPatternPtr = (char*)LoadFile("Levels\\L2Data\\Blind2.DUN", NULL);
		LoadedQuestDungeonMap = 1;
	}else if( IsQuestOnLevel(Q_9_VALOR) ){
		QuestPatternPtr = (char*)LoadFile("Levels\\L2Data\\Blood1.DUN", NULL);
		LoadedQuestDungeonMap = 1;
	}else if( IsQuestOnLevel(Q_14_THE_CHAMBER_OF_BONE) ){
		QuestPatternPtr = (char*)LoadFile("Levels\\L2Data\\Bonestr2.DUN", NULL);
		LoadedQuestDungeonMap = 1;
	}else if( IsPinkiOnLevel () ){
		QuestPatternPtr = (char*)LoadFile("Levels\\L2Data\\pinkyRoom.DUN", NULL);
		LoadedQuestDungeonMap = 1;
	}else if( IsCeremorthOnLevel () ){
		QuestPatternPtr = (char*)LoadFile("levels\\l2data\\Ceromorth.dun", NULL);
		LoadedQuestDungeonMap = 1;
	}
}

//----- (0040F964) --------------------------------------------------------
void FreeQuestDungeonMapPtr()
{
	FreeMemAndZeroPtr(QuestPatternPtr);
}

//----- (0040F976) --------------------------------------------------------
void __fastcall CatacombLevelGeneration(int loadingMode)
{
	int generationEnd = 0;
	do{
		// попробовал добавить оптимизацию генерации катакомб, не получилось с первого раза
		//if( !MatchLevelSeed[ DungeonLevel ] && StartLevelSeed[ DungeonLevel ] ){
		//	MatchLevelSeed[ DungeonLevel ] = levelSeed;
		//}
		CataHallsCount = 0;
		InitCataMaps();
		ClearWallsTransparency();
		if( !MakePrimaryCataMap() ){
			continue;
		}
		SomeCataWallAndFroorConvert();
		if( LoadedQuestDungeonMap ){
			CopyQuestPatternToCataMap(CataQuestRoomStartRow, CataQuestRoomStartCol);
		}
		InitCataWallsTransparency();
		CataSetAdditionalWallsTransparency();

		bool goFromUp = loadingMode == 0;
		bool goFromDown = loadingMode == 1;
		bool goFromTown = loadingMode > 1;// == 2

		generationEnd = GenerateCataPatternObject(CataDungeonEnterToUp, 1, 1, -1, -1, goFromUp, 0);
		if( generationEnd ){
			generationEnd = GenerateCataPatternObject(CataDungeonEnterToDown, 1, 1, -1, -1, goFromDown, 1);
			if( generationEnd ){
				if( DungeonLevel == 5 ){
					generationEnd = GenerateCataPatternObject(CataDungeonEnterToTown, 1, 1, -1, -1, goFromTown, 6);
				}
			}
		}
		if( !goFromDown ){
			PlayerColPos -= 2;
		}else{
			--PlayerRowPos;
		}
	}while( !generationEnd );
	AddAdditionalCataDoors();
	ReplaceEnderCataDoorsWithEnderWalls();
	SomeCataCornersConvert();
	CreateRooms(6, 10, CATA_WAFM_3_FLOOR, 0, 0);
	PlaceCataPattern((uchar*)PatMap3x3_1, 100);
	PlaceCataPattern((uchar*)PatMap3x3_2, 100);
	PlaceCataPattern((uchar*)PatMap3x3_3, 100);
	PlaceCataPattern((uchar*)PatMap3x3_4, 100);
	PlaceCataPattern((uchar*)PatMap3x3_5, 100);
	PlaceCataPattern((uchar*)PatMap3x3_6, 100);
	PlaceCataPattern((uchar*)PatMap3x3_7, 100);
	PlaceCataPattern((uchar*)PatMap3x3_8, 100);
	PlaceCataPattern((uchar*)PatMap2x4_23, 100);
	PlaceCataPattern((uchar*)PatMap2x4_24, 100);
	PlaceCataPattern((uchar*)PatMap2x4_25, 100);
	PlaceCataPattern((uchar*)PatMap2x4_26, 100);
	PlaceCataPattern((uchar*)PatMap2x4_27, 100);
	PlaceCataPattern((uchar*)PatMap2x4_28, 100);
	PlaceCataPattern((uchar*)PatMap2x4_29, 100);
	PlaceCataPattern((uchar*)PatMap2x4_30, 100);
	PlaceCataPattern((uchar*)PatMap2x4, 100);
	PlaceCataPattern((uchar*)PatMap2x4_0, 100);
	PlaceCataPattern((uchar*)PatMap2x4_1, 100);
	PlaceCataPattern((uchar*)PatMap2x4_2, 100);
	PlaceCataPattern((uchar*)PatMap2x4_3, 100);
	PlaceCataPattern((uchar*)PatMap2x4_4, 100);
	PlaceCataPattern((uchar*)PatMap2x4_5, 100);
	PlaceCataPattern((uchar*)PatMap2x4_6, 100);
	PlaceCataPattern((uchar*)PatMap2x4_7, 100);
	PlaceCataPattern((uchar*)PatMap2x4_8, 100);
	PlaceCataPattern((uchar*)PatMap2x4_9, 100);
	PlaceCataPattern((uchar*)PatMap2x4_10, 100);
	PlaceCataPattern((uchar*)PatMap2x4_11, 100);
	PlaceCataPattern((uchar*)PatMap2x4_12, 100);
	PlaceCataPattern((uchar*)PatMap2x4_13, 100);
	PlaceCataPattern((uchar*)PatMap2x4_14, 100);
	PlaceCataPattern((uchar*)PatMap2x3, 100);
	PlaceCataPattern((uchar*)PatMap2x3_0, 100);
	PlaceCataPattern((uchar*)PatMap2x3_1, 100);
	PlaceCataPattern((uchar*)PatMap2x3_2, 100);
	PlaceCataPattern((uchar*)PatMap2x3_3, 100);
	PlaceCataPattern((uchar*)PatMap2x3_4, 100);
	PlaceCataPattern((uchar*)PatMap2x3_5, 100);
	PlaceCataPattern((uchar*)PatMap2x3_6, 100);
	PlaceCataPattern((uchar*)PatMap2x4_15, 100);
	PlaceCataPattern((uchar*)PatMap2x4_16, 100);
	PlaceCataPattern((uchar*)PatMap2x4_17, 100);
	PlaceCataPattern((uchar*)PatMap2x4_18, 100);
	PlaceCataPattern((uchar*)PatMap2x4_19, 100);
	PlaceCataPattern((uchar*)PatMap2x4_20, 100);
	PlaceCataPattern((uchar*)PatMap2x4_21, 100);
	PlaceCataPattern((uchar*)PatMap2x4_22, 100);
	PlaceCataPattern((uchar*)PatMap3x2, 100);
	PlaceCataPattern((uchar*)PatMap3x2_0, 100);
	PlaceCataPattern((uchar*)PatMap3x2_1, 100);
	PlaceCataPattern((uchar*)PatMap3x2_2, 100);
	PlaceCataPattern((uchar*)PatMap3x2_3, 100);
	PlaceCataPattern((uchar*)PatMap3x2_4, 100);
	PlaceCataPattern((uchar*)PatMap3x2_5, 100);
	PlaceCataPattern((uchar*)PatMap3x2_6, 100);
	PlaceCataPattern((uchar*)PatMap3x2_7, 100);
	PlaceCataPattern((uchar*)PatMap3x2_8, 100);
	PlaceCataPattern((uchar*)PatMap3x2_9, 100);
	PlaceCataPattern((uchar*)PatMap3x2_10, 100);
	PlaceCataPattern((uchar*)PatMap3x2_11, 100);
	PlaceCataPattern((uchar*)PatMap3x2_12, 100);
	PlaceCataPattern((uchar*)PatMap3x2_13, 100);
	PlaceCataPattern((uchar*)PatMap3x2_14, 100);
	PlaceCataPattern((uchar*)PatMap3x2_15, 100);
	PlaceCataPattern((uchar*)PatMap3x2_16, 100);
	PlaceCataPattern((uchar*)PatMap3x2_17, 100);
	PlaceCataPattern((uchar*)PatMap3x2_18, 100);
	PlaceCataPattern((uchar*)PatMap3x2_19, 100);
	PlaceCataPattern((uchar*)PatMap3x2_20, 100);
	PlaceCataPattern((uchar*)PatMap3x2_21, 100);
	PlaceCataPattern((uchar*)PatMap3x2_22, 100);
	PlaceCataPattern((uchar*)PatMap3x2_23, 100);
	PlaceCataPattern((uchar*)PatMap3x2_24, 100);
	PlaceCataPattern((uchar*)PatMap3x2_25, 100);
	PlaceCataPattern((uchar*)PatMap3x2_26, 100);
	PlaceCataPattern((uchar*)PatMap3x2_27, 100);
	PlaceCataPattern((uchar*)PatMap3x2_28, 100);
	PlaceCataPattern((uchar*)PatMap3x2_29, 100);
	PlaceCataPattern((uchar*)PatMap3x2_30, 100);
	PlaceCataPattern((uchar*)PatMap3x2_31, 100);
	PlaceCataPattern((uchar*)PatMap3x2_32, 100);
	PlaceCataPattern((uchar*)PatMap3x2_33, 100);
	PlaceCataPattern((uchar*)PatMap3x2_34, 100);
	PlaceCataPattern((uchar*)PatMap3x2_35, 100);
	PlaceCataPattern((uchar*)PatMap3x2_36, 100);
	PlaceCataPattern((uchar*)PatMap3x2_37, 100);
	PlaceCataPattern((uchar*)PatMap3x2_38, 100);
	PlaceCataPattern((uchar*)PatMap3x3_0, 99);
	PlaceCataPattern((uchar*)PatMap1x1_0, 10);
	PlaceCataPattern((uchar*)PatMap1x1_1, 10);
	PlaceCataPattern((uchar*)PatMap1x1_2, 10);
	PlaceCataPattern((uchar*)PatMap1x1_3, 10);
	PlaceCataPattern((uchar*)PatMap1x1_4, 10);
	PlaceCataPattern((uchar*)PatMap1x1_5, 10);
	PlaceCataPattern((uchar*)PatMap1x1_6, 50);
	PlaceCataPattern((uchar*)PatMap5x3, 1); // расхождение
	PlaceCataPattern((uchar*)PatMap5x3_0, 1);
	PlaceCataPattern((uchar*)PatMap2x2_0, 3);
	PlaceCataPattern((uchar*)PatMap2x2_1, 3);
	PlaceCataPattern((uchar*)PatMap1x2, 3);
	PlaceCataPattern((uchar*)PatMap2x1, 3);
	PlaceCataPattern((uchar*)PatMap2x2_2, 3);
	PlaceCataPattern((uchar*)PatMap1x2_0, 20);
	PlaceCataPattern((uchar*)PatMap2x1_0, 20);
	PlaceCataPattern((uchar*)PatMap2x2_3, 3);
	PlaceCataPattern((uchar*)PatMap2x2_4, 20);
	PlaceCataPattern((uchar*)PatMap2x2_5, 20);
	CataTilesVariationsChange();
	ApplyStrangeCataPatterns();
	for( int i = 0; i < 40*40; i++ ){
		AltMap[ 0 ][ i ] = Map[ 0 ][ i ];
	}
	ClearObjectMaps();
	AddDungeonQuestPatternToWallMap(CataQuestRoomStartRow, CataQuestRoomStartCol);
}

//----- (00410045) --------------------------------------------------------
int __fastcall GenerateCataPatternObject(uchar* patternPtr, int minPatternsToPlace, int maxPatternsToPlace, int a4, int a5, int resetPlayerPosition, int a7)
{
	#ifndef REFUCKTOR
	int v7; // ebx@1
	int v8; // esi@1
	int v9; // edi@1
	int v10; // edx@1
	int row; // esi@6
	int col; // ebx@6
	int v13; // edi@21
	int i; // eax@21
	int v15; // ecx@24
	unsigned __int8 v16; // dl@26
	int v17; // eax@39
	int j; // ecx@39
	int v19; // edi@40
	unsigned __int8 *v20; // edx@41
	unsigned __int8 v21; // bl@42
	int result; // eax@49
	unsigned __int8 *v23; // [sp+Ch] [bp-28h]@1
	int v24; // [sp+10h] [bp-24h]@2
	int v25; // [sp+14h] [bp-20h]@4
	int v26; // [sp+18h] [bp-1Ch]@23
	int tryesCounter; // [sp+1Ch] [bp-18h]@6
	int v28; // [sp+20h] [bp-14h]@1
	int v29; // [sp+24h] [bp-10h]@1
	int v30; // [sp+28h] [bp-Ch]@5
	int range; // [sp+2Ch] [bp-8h]@5
	//int v32; // [sp+30h] [bp-4h]@0
	int v33; // [sp+30h] [bp-4h]@6
	int isPatternPlaced; // [sp+3Ch] [bp+8h]@8

	v7 = patternPtr[ 1 ];
	v8 = minPatternsToPlace;
	v9 = *patternPtr;
	v23 = patternPtr;
	v10 = maxPatternsToPlace - minPatternsToPlace;
	v28 = *patternPtr;
	v29 = patternPtr[ 1 ];
	if( v10 ){
		v24 = v8 + RangeRND( 0, v10 );
	}else{
		v24 = 1;
	}
	v25 = 0;
	if( v24 <= 0 ){
		row = a7;
		col = 0;//v32;
	}else{
		range = 40 - v9;
		v30 = 40 - v7;
		do{
			row = RangeRND( 0, range );
			tryesCounter = 0;
			col = RangeRND( 0, v30 );
			v33 = col;
			do{
				if( tryesCounter >= 200 ){
					return 0;
				}
				isPatternPlaced = 1;
				if( row >= CataQuestRoomStartRow
					&& row <= CataQuestRoomEndRow
					&& col >= CataQuestRoomStartCol
					&& col <= CataQuestRoomEndCol ){
					isPatternPlaced = 0;
				}
				if( a4 != -1 && row >= a4 - v28 && row <= a4 + 12 ){
					row = RangeRND( 0, range );
					isPatternPlaced = 0;
					v33 = RangeRND( 0, v30 );
					col = v33;
				}
				if( a5 != -1 && col >= a5 - v29 && col <= a5 + 12 ){
					row = RangeRND( 0, range );
					isPatternPlaced = 0;
					v33 = RangeRND( 0, v30 );
					col = v33;
				}
				v13 = 0;
				for( i = 2; v13 < v29; ++v13 ){
					if( isPatternPlaced != 1 ){
						break;
					}
					v26 = 0;
					if( v28 > 0 ){
						v15 = col + v13 + 40 * row;
						do{
							if( isPatternPlaced != 1 ){
								break;
							}
							v16 = v23[ i ];
							if( v16 && Map[ 0 ][ v15 ] != v16 ){
								isPatternPlaced = 0;
							}
							if( FixedMap[ 0 ][ v15 ] ){
								isPatternPlaced = 0;
							}
							++i;
							++v26;
							v15 += 40;
						} while( v26 < v28 );
					}
				}
				if( !isPatternPlaced && ++row == range ){
					row = 0;
					v33 = ++col;
					if( col == v30 ){
						v33 = 0;
						col = 0;
					}
				}
				++tryesCounter;
			} while( !isPatternPlaced );
			if( tryesCounter >= 200 ){
				return 0;
			}
			v17 = 0;
			for( j = v28 * v29 + 2; v17 < v29; ++v17 ){
				v19 = v28;
				if( v28 > 0 ){
					v20 = &Map[ row ][ v17 ] + col;
					do{
						v21 = v23[ j ];
						if( v21 ){
							*v20 = v21;
						}
						++j;
						v20 += 40;
						--v19;
					} while( v19 );
					col = v33;
				}
			}
			++v25;
		} while( v25 < v24 );
	}
	result = 1;
	if( resetPlayerPosition == 1 ){
		PlayerRowPos = 2 * row + 21;
		PlayerColPos = 2 * col + 22;
	}
	if( !a7 ){
		SomeXPos2 = 2 * row + 21;
		SomeYPos2 = 2 * col + 22;
	}
	if( a7 == 6 ){
		SomeXPos2 = 2 * row + 21;
		SomeYPos2 = 2 * col + 22;
	}
	return result;
	#else
	int col = 0;
	int row = a7;

	int patternRowSize = *patternPtr;
	int patternColSize = *(patternPtr + 1);

	uchar* beforePattern = (patternPtr + 2);
	uchar* afterPattern = beforePattern + patternRowSize * patternColSize;

	//здесь определяется сколько копий объекта понатыкать на карте
	int numberOfPatternsToPlace;
	if( maxPatternsToPlace - minPatternsToPlace ){
		numberOfPatternsToPlace = RangeRND(0, maxPatternsToPlace - minPatternsToPlace) + minPatternsToPlace;
	}else{
		numberOfPatternsToPlace = 1;
	}

	//уменьшаем зону поиска места для установки объекта учитывая его размеры (чтобы не выскочил за пределы массива)
	int mapRowsLimit = 40 - patternRowSize;
	int mapColumnsLimit = 40 - patternColSize;

	int continueFlag;

	for( int patternsPlaced = 0; patternsPlaced < numberOfPatternsToPlace; patternsPlaced++ ){
		bool isPatternPlaced = false;
		row = RangeRND(0, mapRowsLimit);
		col = RangeRND(0, mapColumnsLimit);
		int tryesCounter = 0;

		do{
			continueFlag = 1;
			if( row >= CataQuestRoomStartRow && row <= CataQuestRoomEndRow 
				&& col >= CataQuestRoomStartCol && col <= CataQuestRoomEndCol ){
					maxPatternsToPlace = 0;
			}
			if( a4 != -1 ){
				if( row >= a4 - patternRowSize && row <= a4 + 12 ){
					row = RangeRND(0, mapRowsLimit);
					col = RangeRND(0, mapColumnsLimit);
					continueFlag = 0;
				}
			}
			if( a5 != -1 ){
				if( col >= a5 - patternColSize && col <= a5 + 12 ){
					row = RangeRND(0, mapRowsLimit);
					col = RangeRND(0, mapColumnsLimit);
					continueFlag = 0;
				}
			}
			// проверка на соответствие паттерну
			for( int colOffset = 0; colOffset < patternColSize && continueFlag; colOffset++ ){
				for( int rowOffset = 0; rowOffset < patternRowSize && continueFlag; rowOffset++ ){
					uchar neededTile = beforePattern[colOffset*patternRowSize+rowOffset];
					int mapCell = (row+rowOffset)*40 + (col+colOffset);
					if( (neededTile && (Map[ 0 ][ mapCell ] != neededTile)) || FixedMap[ 0 ][ mapCell ] ){
						continueFlag = 0; //бида бида, паттерн не соблюдается, надо искать другое место
					}
				}
			}

			tryesCounter++;
			if( tryesCounter >= 200 ){
				return 0;
			}

			if( continueFlag ){
				//матерь божья, мы нашли подходящее место для установки объекта, копируем ка его паттерн быстренько на карту
				for( int colOffset = 0; colOffset < patternColSize; colOffset++ ){
					for( int rowOffset = 0; rowOffset < patternRowSize; rowOffset++ ){
						uchar newTile = afterPattern[colOffset*patternRowSize+rowOffset];
						int mapCell = (row+rowOffset)*40 + (col+colOffset);
						if( newTile ){
							Map[ 0 ][ mapCell ] = newTile;
						}
					}
				}
				isPatternPlaced = true;
			}

			// следующая клетка
			if( !isPatternPlaced ){
				if( ++row == mapRowsLimit ){
					row = 0;
					if( ++col == mapColumnsLimit ){			
						col = 0;
					}
				}
				//tryesCounter++;
				//
				//if( tryesCounter >= 200 ){
				//	return 0;
				//}
			}

		}while( !isPatternPlaced);

	}

	//перемещаем стартовую точку игрока поближе к созданному объекту (как правило это делается для лестницы)
	if( resetPlayerPosition ){
		PlayerRowPos = Convert40to112(row) + 5;
		PlayerColPos = Convert40to112(col) + 6;
	}
	if( !a7 ){
		SomeXPos2 = Convert40to112(row) + 5;
		SomeYPos2 = Convert40to112(col) + 6;
	}
	if( a7 == 6 ){
		SomeXPos2 = Convert40to112(row) + 5;
		SomeYPos2 = Convert40to112(col) + 6;
	}
	return 1;
	#endif
}

//----- (004102A2) --------------------------------------------------------
void __fastcall PlaceCataPattern(uchar* patternPtr, int chanceToPlace)
{
	#ifndef REFAK
	int patternRowSize = patternPtr[0];
	int patternColSize = patternPtr[1];
	int mapRowsLimit = 40 - patternRowSize;
	int mapColsLimit = 40 - patternColSize;
	int prevRnd = 0;
	int seekIndex = 0;
	for( int col = 0; col < mapColsLimit; col++ ){
		for( int row = 0; row < mapRowsLimit; row++ ){
			int continueFlag = 1;
			int patternIndex = 2;
			if( row >= CataQuestRoomStartRow && row <= CataQuestRoomEndRow
			 && col >= CataQuestRoomStartCol && col <= CataQuestRoomEndCol ){
				continueFlag = 0;
			}
			for( int colOffset = 0; colOffset < patternColSize && continueFlag == 1; colOffset++ ){
				for( int rowOffset = 0; rowOffset < patternRowSize && continueFlag == 1; rowOffset++ ){
					uchar needTile = patternPtr[patternIndex++];
					if( needTile && Map[row + rowOffset][col + colOffset] != needTile || FixedMap[row + rowOffset][col + colOffset] ){
						continueFlag = 0;
					}
				}
			}
			seekIndex = patternRowSize * patternColSize + 2;
			if( continueFlag != 1 ){
				continue;
			}
			uchar seekTile = patternPtr[ seekIndex ];
			// защита от установки декора друг рядом с другом
			for( int colOffset = -patternColSize; colOffset < 2 * patternColSize && continueFlag == 1; colOffset++ ){
				for( int rowOffset = -patternRowSize; rowOffset < 2 * patternRowSize && continueFlag == 1; rowOffset++ ){
					int r = row + rowOffset, c = col + colOffset;
					// фикс морфинга подземелий, пока с заглушкой эмулирующей баг th1 при сверке
					if( r >= 0 && r < 40 && c >= 0 && c < 40 ){
						if( Map[ r ][ c ] == seekTile ){
							continueFlag = 0;
						}
					}
					#ifdef TH1
					else if( IsExeValidating && Exe::Map[ r ][ c ] == seekTile ){
						continueFlag = 0;
					}
					#endif
				}
			}
			if( continueFlag == 1 ){
				int rnd = RangeRND(0, 100);
				//if( rnd == 13 && prevRnd == 47 && chanceToPlace == 1 ) __debugbreak();
				//prevRnd = rnd;
				if( rnd < chanceToPlace ){
					for( int colOffset = 0; colOffset < patternColSize; colOffset++ ){
						for( int rowOffset = 0; rowOffset < patternRowSize; rowOffset++ ){
							uchar newTile = patternPtr[seekIndex++];
							if( newTile ){
								Map[row + rowOffset][col + colOffset] = newTile;
							}
						}
					}
				}
			}
		}
	}
	#else
	unsigned __int8 *patterPtr; // ebx@1
	int patternColSize; // eax@1
	int patternRowSize; // ecx@1
	signed int patternIndex; // edx@5
	int patternColSize_2; // ecx@10
	int colOffset; // esi@10
	int rowOffset; // edi@12
	int cellOffset; // eax@13
	unsigned __int8 needTile; // cl@15
	int seekIndex; // esi@22
	int col_1; // edi@23
	int rowOfs; // eax@25
	int rowOfsSize; // ecx@25
	unsigned __int8 seekTile; // bl@26
	int row; // ecx@26
	unsigned __int8 *cell_1; // edx@26
	int colOffset_1; // edx@34
	int rowOffset_1; // edi@35
	unsigned __int8 *map; // eax@36
	char newTile; // cl@37
	int chanceToPlace_1; // [sp+8h] [bp-2Ch]@1
	int colOffsetSize; // [sp+Ch] [bp-28h]@23
	unsigned __int8 *patternPtr_1; // [sp+10h] [bp-24h]@1
	int patternColsLimit; // [sp+14h] [bp-20h]@1
	int patternRowsLimit; // [sp+18h] [bp-1Ch]@2
	int cell; // [sp+1Ch] [bp-18h]@4
	int patternColSize_1; // [sp+20h] [bp-14h]@1
	int patternRowSize_1; // [sp+24h] [bp-10h]@1
	int row_1; // [sp+28h] [bp-Ch]@3
	int col; // [sp+2Ch] [bp-8h]@1
	signed int continueFlag; // [sp+30h] [bp-4h]@5

	patterPtr = patternPtr;
	chanceToPlace_1 = chanceToPlace;
	patternColSize = patternPtr[ 1 ];
	patternRowSize = *patternPtr;
	patternPtr_1 = patterPtr;
	patternRowSize_1 = patternRowSize;
	patternColsLimit = 40 - patternColSize;
	patternColSize_1 = patternColSize;
	col = 0;
	if( 40 - patternColSize > 0 ){
		patternRowsLimit = 40 - patternRowSize;
		do{
			row_1 = 0;
			if( patternRowsLimit > 0 ){
				cell = 0;
				do{
					continueFlag = 1;
					patternIndex = 2;
					if( row_1 >= CataQuestRoomStartRow
						&& row_1 <= CataQuestRoomEndRow
						&& col >= CataQuestRoomStartCol
						&& col <= CataQuestRoomEndCol ){
						continueFlag = 0;
					}
					patternColSize_2 = patternColSize_1;
					for( colOffset = 0; colOffset < patternColSize_1; ++colOffset ){
						if( continueFlag != 1 ){
							break;
						}
						rowOffset = 0;
						if( patternRowSize_1 > 0 ){
							cellOffset = cell + colOffset + col;
							do{
								if( continueFlag != 1 ){
									break;
								}
								needTile = patterPtr[ patternIndex ];
								if( needTile ){
									if( Map[ 0 ][ cellOffset ] != needTile ){
										continueFlag = 0;
									}
								}
								if( FixedMap[ 0 ][ cellOffset ] ){
									continueFlag = 0;
								}
								++patternIndex;
								++rowOffset;
								cellOffset += 40;
							} while( rowOffset < patternRowSize_1 );
						}
						patternColSize_2 = patternColSize_1;
					}
					seekIndex = patternRowSize_1 * patternColSize_2 + 2;
					if( continueFlag == 1 ){
						col_1 = col - patternColSize_2;
						colOffsetSize = col + 2 * patternColSize_2;
						if( col - patternColSize_2 >= col + 2 * patternColSize_2 ){
						LABEL_32:
							if( continueFlag == 1 && RangeRND( 0, 100 ) < chanceToPlace_1 ){
								for( colOffset_1 = 0; colOffset_1 < patternColSize_1; ++colOffset_1 ){
									rowOffset_1 = patternRowSize_1;
									if( patternRowSize_1 > 0 ){
										map = (unsigned __int8 *) Map + colOffset_1 + col + cell;
										do{
											newTile = patterPtr[ seekIndex ];
											if( newTile ){
												*map = newTile;
											}
											++seekIndex;
											map += 40;
											--rowOffset_1;
										}while( rowOffset_1 );
									}
								}
							}
						}else{
							while( continueFlag == 1 ){
								rowOfs = row_1 - patternRowSize_1;
								rowOfsSize = row_1 + 2 * patternRowSize_1;
								if( row_1 - patternRowSize_1 < rowOfsSize ){
									seekTile = patterPtr[ seekIndex ];
									row = rowOfsSize - rowOfs;
									//if( rowOfs < 0 || rowOfs > 39 || col_1 < 0 || col_1 > 39 ) __debugbreak();
									cell_1 = &Map[ rowOfs ][ col_1 ];
									do{
										if( cell_1 >= (uchar*)Map ){
											if( *cell_1 == seekTile ){
												continueFlag = 0;
											}
										}
										#ifdef TH1
										else if( IsExeValidating ){
											if( *((uchar*)(&MonsterMap[111][112]) - ((uint)Map-(uint)cell_1)) == seekTile ){
												continueFlag = 0;
											}
										}
										#endif
										cell_1 += 40;
										--row;
									}while( row );
									patterPtr = patternPtr_1;
								}
								if( ++col_1 >= colOffsetSize ){
									goto LABEL_32;
								}
							}
						}
					}
					++row_1;
					cell += 40;
				}while( row_1 < patternRowsLimit );
			}
			++col;
		}while( col < patternColsLimit );
	}
	#endif
}

//----- (00410449) --------------------------------------------------------
void CataTilesVariationsChange()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			int cell = row*40 + col;
			uchar& curWallAndFloorMap = Map[ 0 ][ cell ];
			if( (row >= CataQuestRoomStartRow && row <= CataQuestRoomEndRow) 
				|| (col >= CataQuestRoomStartCol && col <= CataQuestRoomEndCol) ){
					continue;// косяк оригинального алгоритма. Не прямоугольник квестового зала освобождается от рандомизации, а крест с прямоугольником зала в центре
			}
			if( RangeRND(0, 4) ){
				continue;
			}


			int tileGroupNumber = CataTilesVariationsTable[curWallAndFloorMap];
			if( !tileGroupNumber ){
				continue;
			}

			int randCounter = RangeRND(0, 16);
			int newTileIndex = -1;
			while( randCounter >= 0 ){
				if( ++newTileIndex == CATA_WAFM_161 ){
					newTileIndex = 0;
				}
				if( CataTilesVariationsTable[newTileIndex] == tileGroupNumber ){
					randCounter--;
				}
			}

			bool isEqualTileAround = false;
			for( int colOffset = -2; colOffset < 2 && !isEqualTileAround; colOffset++ ){
				for( int rowOffset = -2; rowOffset < 2 && !isEqualTileAround; rowOffset++ ){
					int cell = (row+rowOffset)*40 + (col+colOffset);
					if( Map[ 0 ][ cell ] == newTileIndex ){
						isEqualTileAround = true;
					}
				}
			}

			if( !isEqualTileAround ){
				curWallAndFloorMap = newTileIndex;
			}

		}
	}
}

//----- (00410540) --------------------------------------------------------
void ApplyStrangeCataPatterns()
{
	for( int col = 1; col < 40; col++ ){
		for( int row = 1; row < 40; row++ ){
			int cell = row * 40 + col;
			for( int patternIndex = 0; patternIndex < 2; patternIndex++ ){
				StrangeCataPattern& pattern = StrangeCataPatterns[patternIndex];
				if( pattern.curTileType == SomeCataTilesTypes[Map[ 0 ][ cell ]] ){
					bool isPatternAccess = 1;
					if( pattern.upTileType && pattern.upTileType != SomeCataTilesTypes[Map[ 0 ][ cell - 41 ]] ){// up
						isPatternAccess = 0;
					}
					if( pattern.leftTileType && pattern.leftTileType != SomeCataTilesTypes[Map[ 0 ][ cell - 1 ]] ){// left
						isPatternAccess = 0;
					}
					if( pattern.rightTileType && pattern.rightTileType != SomeCataTilesTypes[Map[ 0 ][ cell - 40 ]] ){// right
						isPatternAccess = 0;
					}
					if( !isPatternAccess ){
						continue;
					}
					if( pattern.newUpTile ){
						Map[ 0 ][ cell - 41 ] = pattern.newUpTile;// up
					}
					if( pattern.newLeftTile ){
						Map[ 0 ][ cell - 1 ] = pattern.newLeftTile;// left
					}
					if( pattern.newRightTile ){
						Map[ 0 ][ cell - 40 ] = pattern.newRightTile;// right
					}
				}
			}
		}
	}
}

//----- (00410610) --------------------------------------------------------
void __fastcall CopyQuestPatternToCataMap(int row, int col)
{
	ushort* questPatternPtr = (ushort*)QuestPatternPtr;
	StartPatternRow40 = row;
	StartPatternCol40 = col;
	PatternMapRows = questPatternPtr[0];
	PatternMapCols = questPatternPtr[1];

	int patMapOffset = 2;
	for( int colOffset = 0; colOffset < PatternMapCols; colOffset++ ){
		for( int rowOffset = 0; rowOffset < PatternMapRows; rowOffset++ ){
			int cell = col + colOffset + 40 * (row + rowOffset);
			ushort newTile = questPatternPtr[patMapOffset];
			if( newTile ){
				FixedMap[ 0 ][ cell ] |= BIT(8);
				Map[ 0 ][ cell ] = (uchar)newTile;
			}else{
				Map[ 0 ][ cell ] = CATA_WAFM_3_FLOOR;
			}
			patMapOffset++;
		}
	}
}

//----- (00410695) --------------------------------------------------------
void SomeCataWallAndFroorConvert()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar& curWallAndFloorMap = Map[ row+0 ][ col+0 ];
			uchar& nextRowWallAndFloorMap = Map[ row+1 ][ col+0 ];
			uchar& nextColWallAndFloorMap = Map[ row+0 ][ col+1 ];
			if( curWallAndFloorMap == CATA_WAFM_1_LU_WALL && nextColWallAndFloorMap == CATA_WAFM_3_FLOOR ){
				nextColWallAndFloorMap = CATA_WAFM_1_LU_WALL;
			}
			if( curWallAndFloorMap == CATA_WAFM_3_FLOOR ){
				if( nextColWallAndFloorMap == CATA_WAFM_1_LU_WALL ){
					nextColWallAndFloorMap = CATA_WAFM_3_FLOOR;
				}
				if( nextRowWallAndFloorMap == CATA_WAFM_7_CORNER ){
					nextRowWallAndFloorMap = CATA_WAFM_3_FLOOR;
				}
			}
			if( curWallAndFloorMap == CATA_WAFM_2_RU_WALL && nextRowWallAndFloorMap == CATA_WAFM_3_FLOOR ){
				nextRowWallAndFloorMap = CATA_WAFM_2_RU_WALL;
			}
			if( curWallAndFloorMap == CATA_WAFM_11_LD_WALL && nextRowWallAndFloorMap == CATA_WAFM_14_CORNER ){
				nextRowWallAndFloorMap = CATA_WAFM_16_CORNER;
			}
		}
	}
}

// updated to 1.216
//----- (004106F8) --------------------------------------------------------
bool MakePrimaryCataMap()
{
	// выбор размера первой комнаты для установки туда квестового шаблона
	int questPatternRoomColSize = 0;
	int questPatternRoomRowSize = 0;
	int needQuestPatternRoom = 0;
	if( DungeonLevel == 5 ){
		if( Quests[Q_9_VALOR].status ){
			needQuestPatternRoom = 1;
			questPatternRoomRowSize = 20;
			questPatternRoomColSize = 14;
		}
	}else if( DungeonLevel == 6 ){
		if( Quests[Q_14_THE_CHAMBER_OF_BONE].status ){
			needQuestPatternRoom = 1;
			questPatternRoomColSize = 10;
			questPatternRoomRowSize = 10;
		}
		if( IsPinkiOnLevel () ){
			needQuestPatternRoom = 1;
			questPatternRoomColSize = 13;
			questPatternRoomRowSize = 13;
		}
	}else if( DungeonLevel == 7 ){
		if( Quests[Q_8_HALLS_OF_THE_BLIND].status ){
			needQuestPatternRoom = 1;
			questPatternRoomColSize = 15;
			questPatternRoomRowSize = 15;
		}
	}else{
		if( IsCeremorthOnLevel () ){
			needQuestPatternRoom = 1;
			questPatternRoomColSize = 13;
			questPatternRoomRowSize = 13;
		}
	}

	// создание комнат
	RecursiveCataHallsGeneration(2, 2, 39, 39, 0, 0, needQuestPatternRoom, questPatternRoomRowSize, questPatternRoomColSize);
	
	// создание корридоров между комнатами и выбор тайлов для дверей
	while( CataPassageQueuePtr ){
		int firstDoorRow, firstDoorCol, secondDoorRow, secondDoorCol, startOrientation;
		LoadNextCataPassageParams(firstDoorRow, firstDoorCol, secondDoorRow, secondDoorCol, startOrientation);
		MakeCataPassage(firstDoorRow, firstDoorCol, secondDoorRow, secondDoorCol, startOrientation);
	}
	
	// небольшие преобразования перед созданием карты по шаблону
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar& curRowCurCol = CatacombMapAdvance[ row + 0 ][ col + 0 ];
			uchar& nextRowNextCol = CatacombMapAdvance[ row + 1 ][ col + 1 ];
			uchar& prevRowPrevCol = CatacombMapAdvance[ row - 1 ][ col - 1 ];

			uchar& nextRowCurCol = CatacombMapAdvance[ row + 1 ][ col + 0 ];
			uchar& prevRowCurCol = CatacombMapAdvance[ row - 1 ][ col + 0 ];

			uchar& curRowPrevCol = CatacombMapAdvance[ row + 0 ][ col - 1 ];
			uchar& curRowNextCol = CatacombMapAdvance[ row + 0 ][ col + 1 ];

			uchar& nextRowPrevCol = CatacombMapAdvance[ row + 1 ][ col - 1 ];
			uchar& prevRowNextCol = CatacombMapAdvance[ row - 1 ][ col + 1 ];

			switch (curRowCurCol ){
				case CATA_MA_67_UP_CORNER:
				case CATA_MA_66_RIGHT_CORNER:
				case CATA_MA_69_LEFT_CORNER:
				case CATA_MA_65_DOWN_CORNER:	curRowCurCol = CATA_MA_35_WALL;	break;// углы теряют спец обозначения и становятся просто стенами
				case CATA_MA_44_PASSAGE_FLOOR:	
					// пол коридора становится посто полом, а бейонд вокруг тайлов коридора становится стеной
					curRowCurCol = CATA_MA_46_FLOOR;
					if( prevRowPrevCol == CATA_MA_32_BEYOND ){
						prevRowPrevCol = CATA_MA_35_WALL;
					}
					if( prevRowCurCol == CATA_MA_32_BEYOND ){
						prevRowCurCol = CATA_MA_35_WALL;
					}
					if( prevRowNextCol == CATA_MA_32_BEYOND ){
						prevRowNextCol = CATA_MA_35_WALL;
					}
					if( nextRowPrevCol == CATA_MA_32_BEYOND ){
						nextRowPrevCol = CATA_MA_35_WALL;
					}
					if( nextRowCurCol == CATA_MA_32_BEYOND ){
						nextRowCurCol = CATA_MA_35_WALL;
					}
					if( nextRowNextCol == CATA_MA_32_BEYOND ){
						nextRowNextCol = CATA_MA_35_WALL;
					}
					if( curRowPrevCol == CATA_MA_32_BEYOND ){
						curRowPrevCol = CATA_MA_35_WALL;
					}
					if( curRowNextCol == CATA_MA_32_BEYOND ){
						curRowNextCol = CATA_MA_35_WALL;
					}
					break;
			}
		}
	}
	
	// расширение комнат в стороны для набора заданной площади пола
	if( !CataHallsExpand() ){
		return false;
	}

	// за счёт применения шаблонов превращение грубого наброска в что то похожее на катакомбы
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			CataFillWallAndFloorMapWithUsingSomePatterns(row, col);
		}
	}
	return true;
}

// оптимизация лишнего прибавления
__forceinline int RandToMaxMinus1( int min, int max ){	return min + RangeRND( 0, max - min ); }
//----- (0041084A) --------------------------------------------------------
void __fastcall RecursiveCataHallsGeneration(int startRow2, int startCol2, int endRow2, int endCol2, int motherCataHallIndex, int orientation, int needQuestPatternRoom, int questPatternRoomRowSize, int questPatternRoomColSize)
{
	for( ; CataHallsCount < 80; ){
		int rowSize2 = endRow2 - startRow2;
		int colSize2 = endCol2 - startCol2;

		// если слишком узкий холл, выходим
		if( rowSize2 < MinCataHallSize || colSize2 < MinCataHallSize ){
			return;
		}

		// рендомизируем размеры
		int roomColSize;
		if( rowSize2 > BigCataHallSize ){
			roomColSize = RandToMaxMinus1(MediumCataHallSize, BigCataHallSize);
		}else if( rowSize2 > MediumCataHallSize ){
			roomColSize = RandToMaxMinus1(MediumCataHallSize, rowSize2);
		}else{
			roomColSize = rowSize2;
		}

		int roomRowSize;
		if( colSize2 > BigCataHallSize ){
			roomRowSize = RandToMaxMinus1(MediumCataHallSize, BigCataHallSize);
		}else if( colSize2 > MediumCataHallSize ){
			roomRowSize = RandToMaxMinus1(MediumCataHallSize, colSize2);
		}else{
			roomRowSize = colSize2;
		}

		if( needQuestPatternRoom == 1 ){
			roomColSize = questPatternRoomColSize;
			roomRowSize = questPatternRoomRowSize;
		}

		int startRow = startRow2 + RangeRND(0, rowSize2);
		int startCol = startCol2 + RangeRND(0, colSize2);

		int endRow = startRow + roomColSize;
		int endCol = startCol + roomRowSize;

		if( startRow + roomColSize > endRow2 ){
			endRow = endRow2;
			startRow = endRow2 - roomColSize;
		}

		if( startCol + roomRowSize > endCol2 ){
			endCol = endCol2;
			startCol = endCol2 - roomRowSize;
		}

		LimitToRange(startRow, 1, 38);
		LimitToRange(startCol, 1, 38);
		LimitToRange(endRow, 1, 38);
		LimitToRange(endCol, 1, 38);

		ConstructCataHall(startRow, startCol, endRow, endCol, needQuestPatternRoom);
		if( needQuestPatternRoom == 1 ){
			CataQuestRoomEndRow = endRow;
			CataQuestRoomStartRow = startRow + 2;
			CataQuestRoomStartCol = startCol + 2;
			CataQuestRoomEndCol = endCol;
		}

		CataHalls[CataHallsCount].motherCataHallIndex = motherCataHallIndex;

		if( motherCataHallIndex ){
			CataHall& curRoom = CataHalls[motherCataHallIndex];
			if( orientation == 1 ){
				int randStartRow = RandToMaxMinus1(startRow + 1, endRow - 1);
				int randEndRow = RandToMaxMinus1(curRoom.startRow + 1, curRoom.endRow - 1);
				SaveCataPassageParamsToQueue(randStartRow, startCol, randEndRow, curRoom.endCol, orientation);
			}else if( orientation == 2 ){
				int randEndCol = RandToMaxMinus1(startCol + 1, endCol - 1);
				int randStartCol = RandToMaxMinus1(curRoom.startCol + 1, curRoom.endCol - 1);
				SaveCataPassageParamsToQueue(endRow, randEndCol, curRoom.startRow, randStartCol, orientation);
			}else if( orientation == 3 ){
				int randEndRow = RandToMaxMinus1(startRow + 1, endRow - 1);
				int randStartRow = RandToMaxMinus1(curRoom.startRow + 1, curRoom.endRow - 1);
				SaveCataPassageParamsToQueue(randEndRow, endCol, randStartRow, curRoom.startCol, orientation);
			}else if( orientation == 4 ){
				int randStartCol = RandToMaxMinus1(startCol + 1, endCol - 1);
				int randEndCol = RandToMaxMinus1(curRoom.startCol + 1, curRoom.endCol - 1);
				SaveCataPassageParamsToQueue(startRow, randStartCol, curRoom.endRow, randEndCol, orientation);
			}
		}

		motherCataHallIndex = CataHallsCount;
		if( roomRowSize <= roomColSize ){
			RecursiveCataHallsGeneration(startRow2 + 2,		startCol2 + 2,			endRow - 2,		startCol - 2,	motherCataHallIndex, 3, 0, 0, 0);
			RecursiveCataHallsGeneration(startRow + 2,	endCol + 2,		endRow2 - 2,	endCol2 - 2,			motherCataHallIndex, 1, 0, 0, 0);
			RecursiveCataHallsGeneration(startRow2 + 2,		startCol + 2,	startRow - 2,	endCol2 - 2,			motherCataHallIndex, 2, 0, 0, 0);
			orientation = 4;
			endCol2 = endCol - 2;
			startRow2 = endRow + 2;
		}else{
			RecursiveCataHallsGeneration(startRow2 + 2,		startCol2 + 2,			startRow - 2,	endCol - 2,		motherCataHallIndex, 2, 0, 0, 0);
			RecursiveCataHallsGeneration(endRow + 2,	startCol + 2,	endRow2 - 2,	endCol2 - 2,			motherCataHallIndex, 4, 0, 0, 0);
			RecursiveCataHallsGeneration(startRow2 + 2,		endCol + 2,		endRow - 2,		endCol2 - 2,			motherCataHallIndex, 1, 0, 0, 0);
			orientation = 3;
			endCol2 = startCol - 2;
			startRow2 = startRow + 2;
		}
		endRow2 -= 2;
		startCol2 += 2;
		questPatternRoomColSize = 0;
		questPatternRoomRowSize = 0;
		needQuestPatternRoom = 0;
	}
}

//----- (00410CA9) --------------------------------------------------------
void __fastcall ConstructCataHall(int startRow, int startCol, int endRow, int endCol, int isFixedHall)
{
	int startRowOfs; // esi@1
	int endRowOfs; // edi@1
	int cataCountNext; // eax@1
	int row; // eax@2
	bool lastCol; // zf@5
	int afterStartRow; // ecx@7
	unsigned __int8 *cataAdvOfs; // eax@8
	unsigned __int8 *cell; // ebx@13
	int rowDif_1; // eax@13
	int colDif; // [sp+10h] [bp-4h]@4
	int rowDif; // [sp+10h] [bp-4h]@8
	int prevEndCol; // [sp+20h] [bp+Ch]@10
	unsigned __int8 *fixedMapOfs; // [sp+24h] [bp+10h]@4

	startRowOfs = 40 * startRow;
	endRowOfs = 40 * endRow;
	*(&CatacombMapAdvance[ 0 ][ startCol ] + startRowOfs) = 67;
	*(&CatacombMapAdvance[ 0 ][ endCol ] + startRowOfs) = 69;
	*(&CatacombMapAdvance[ 0 ][ startCol ] + endRowOfs) = 66;
	*(&CatacombMapAdvance[ 0 ][ endCol ] + endRowOfs) = 65;
	cataCountNext = CataHallsCount + 1;
	CataHallsCount = cataCountNext;
	cataCountNext *= 20;
	*(int *) ((char *) &CataHalls[ 0 ].startRow + cataCountNext) = startRow;
	*(int *) ((char *) &CataHalls[ 0 ].endRow + cataCountNext) = endRow;
	*(int *) ((char *) &CataHalls[ 0 ].startCol + cataCountNext) = startCol;
	*(int *) ((char *) &CataHalls[ 0 ].endCol + cataCountNext) = endCol;
	if( isFixedHall == 1 ){
		for( row = startRow; row < endRow; ++row ){
			if( row < endCol ){
				fixedMapOfs = &FixedMap[ row ][ startCol ];
				colDif = endCol - row;
				row = endCol;
				do{
					*fixedMapOfs |= 0x80u;
					lastCol = colDif-- == 1;
					fixedMapOfs += 40;
				}while( !lastCol );
			}
		}
	}
	afterStartRow = startRow + 1;
	if( afterStartRow <= endRow - 1 ){
		rowDif = endRow - 1 - afterStartRow + 1;
		cataAdvOfs = &CatacombMapAdvance[ afterStartRow ][ endCol ];
		do{
			cataAdvOfs[ startCol - endCol ] = 35;
			*cataAdvOfs = 35;
			cataAdvOfs += 40;
			--rowDif;
		}while( rowDif );
	}
	prevEndCol = endCol - 1;
	while( ++startCol <= prevEndCol ){
		*(&CatacombMapAdvance[ 0 ][ startCol ] + startRowOfs) = 35;
		*(&CatacombMapAdvance[ 0 ][ startCol ] + endRowOfs) = 35;
		if( afterStartRow < endRow ){
			cell = &CatacombMapAdvance[ afterStartRow ][ startCol ];
			rowDif_1 = endRow - afterStartRow;
			do{
				*cell = 46;
				cell += 40;
				--rowDif_1;
			}while( rowDif_1 );
		}
	}
	#ifdef refucktor
	// углы
	CatacombMapAdvance[ startRow ][ startCol ] = CATA_MA_67_UP_CORNER;
	CatacombMapAdvance[ startRow ][ endCol ] = CATA_MA_69_LEFT_CORNER;
	CatacombMapAdvance[ endRow ][ startCol ] = CATA_MA_66_RIGHT_CORNER;
	CatacombMapAdvance[ endRow ][ endCol ] = CATA_MA_65_DOWN_CORNER;

	// стены 35
	for( int row = startRow + 1; row <= endRow - 1; row++ ){
		CatacombMapAdvance[ row ][ startCol ] = CATA_MA_35_WALL;
		CatacombMapAdvance[ row ][ endCol ] = CATA_MA_35_WALL;
	}

	for( int col = startCol + 1; col <= endCol - 1; col++ ){
		CatacombMapAdvance[ startRow ][ col ] = CATA_MA_35_WALL;
		CatacombMapAdvance[ endRow ][ col ] = CATA_MA_35_WALL;
	}

	// пол 46
	for( int col = startCol + 1; col <= endCol - 1; col++ ){
		for( int row = startRow + 1; row <= endRow - 1; row++ ){
			CatacombMapAdvance[ row ][ col ] = CATA_MA_46_FLOOR;
		}
	}

	CataHall& curHall = CataHalls[++CataHallsCount];// баг оригинала
	curHall.startRow = startRow;
	curHall.startCol = startCol;
	curHall.endRow = endRow;
	curHall.endCol = endCol;

	if( isFixedHall == 1 ){
	#if comment // верная версия, но увы для совместимости придется пока оставить косячную
		for( int row = startRow; row < endRow; row++ ){
			for( int col = startCol; col < endCol; col++ ){
				FixedMap[ row ][ col ] |= BIT(8);
			}
		}
	#endif
		// такая ахинея в оригинале. Она и оставлена для совместимости генерации
		for( int row = startRow; row < endRow; ++row ){
			for( int col = row; col < endCol; ++col ){
				FixedMap[col][startCol] |= BIT( 8 );
			}
			row = endCol;
		}
	}
	#endif
}

//----- (00410DCD) --------------------------------------------------------
void __fastcall SaveCataPassageParamsToQueue(int firstDoorRow, int firstDoorCol, int secondDoorRow, int secondDoorCol, int startOrientation)
{
	CataPassageQueue* nextCataRoomElement;
	if( CataPassageQueuePtr ){
		nextCataRoomElement = (CataPassageQueue*)AllocMem(sizeof CataPassageQueue);
		nextCataRoomElement->firstDoorRow = firstDoorRow;
		nextCataRoomElement->firstDoorCol = firstDoorCol;
		nextCataRoomElement->secondDoorRow = secondDoorRow;
		nextCataRoomElement->secondDoorCol = secondDoorCol;
		nextCataRoomElement->startOrientation = startOrientation;
		nextCataRoomElement->nextElementPtr = 0;

		// добавление нового элемента в конец очереди
		CataPassageQueue* lastCataRoomElement = CataPassageQueuePtr;
		while( lastCataRoomElement->nextElementPtr ){
			lastCataRoomElement = lastCataRoomElement->nextElementPtr;
		}
		lastCataRoomElement->nextElementPtr = nextCataRoomElement;
	}else{
		nextCataRoomElement = (CataPassageQueue*)AllocMem(sizeof CataPassageQueue);
		nextCataRoomElement->firstDoorRow = firstDoorRow;
		nextCataRoomElement->firstDoorCol = firstDoorCol;
		nextCataRoomElement->secondDoorRow = secondDoorRow;
		nextCataRoomElement->secondDoorCol = secondDoorCol;
		nextCataRoomElement->startOrientation = startOrientation;
		nextCataRoomElement->nextElementPtr = 0;
		CataPassageQueuePtr = nextCataRoomElement;
	}
}

//----- (00410E5C) --------------------------------------------------------
void __fastcall LoadNextCataPassageParams(int& firstDoorRow, int& firstDoorCol, int& secondDoorRow, int& secondDoorCol, int& startOrientation)
{
	firstDoorRow = CataPassageQueuePtr->firstDoorRow;
	firstDoorCol = CataPassageQueuePtr->firstDoorCol;
	secondDoorRow = CataPassageQueuePtr->secondDoorRow;
	secondDoorCol = CataPassageQueuePtr->secondDoorCol;
	startOrientation = CataPassageQueuePtr->startOrientation;
	CataPassageQueue* nextElementPtr = CataPassageQueuePtr->nextElementPtr;
	FreeMemAndZeroPtr(CataPassageQueuePtr);
	CataPassageQueuePtr = nextElementPtr;
}

//----- (00410EB9) --------------------------------------------------------
void __fastcall MakeCataPassage(int firstDoorRow, int firstDoorCol, int secondDoorRow, int secondDoorCol, int startOrientation)
{
	const int O_1_DEC_COL = 1;
	const int O_2_INC_ROW = 2;
	const int O_3_INC_COL = 3;
	const int O_4_DEC_ROW = 4;
	
	int row = firstDoorRow;
	int col = firstDoorCol;
	int randFactor1 = RangeRND(0, 100);
	int randFactor2 = RangeRND(0, 100);
	MakeCataDoor(row, col);
	MakeCataDoor(secondDoorRow, secondDoorCol);
	int curOrientation = startOrientation;
	secondDoorRow -= SomeRowArray[startOrientation];
	secondDoorCol -= SomeColArray[startOrientation];
	int someFlag = 0;
	CatacombMapAdvance[ secondDoorRow ][ secondDoorCol ] = CATA_MA_44_PASSAGE_FLOOR;
	uchar* curCataMapPtr = &CatacombMapAdvance[ row ][ col ];
	for( ; row != secondDoorRow || col != secondDoorCol; ){
		if( row >= 38 && curOrientation == O_2_INC_ROW ){
			curOrientation = O_4_DEC_ROW;
		}
		if( col >= 38 && curOrientation == O_3_INC_COL ){
			curOrientation = O_1_DEC_COL;
		}
		if( row <= 1 && curOrientation == O_4_DEC_ROW ){
			curOrientation = O_2_INC_ROW;
		}
		if( col <= 1 && curOrientation == O_1_DEC_COL ){
			curOrientation = O_3_INC_COL;
		}
		if( *curCataMapPtr == CATA_MA_67_UP_CORNER && ( curOrientation == O_1_DEC_COL || curOrientation == O_4_DEC_ROW ) ){
			curOrientation = O_2_INC_ROW;
		}
		if( *curCataMapPtr == CATA_MA_66_RIGHT_CORNER && ( curOrientation == O_1_DEC_COL || curOrientation == O_2_INC_ROW ) ){
			curOrientation = O_3_INC_COL;
		}
		if( *curCataMapPtr == CATA_MA_69_LEFT_CORNER && ( curOrientation == O_4_DEC_ROW || curOrientation == O_3_INC_COL ) ){
			curOrientation = O_1_DEC_COL;
		}
		if( *curCataMapPtr == CATA_MA_65_DOWN_CORNER && ( curOrientation == O_2_INC_ROW || curOrientation == O_3_INC_COL ) ){
			curOrientation = O_4_DEC_ROW;
		}
		int rowOffset = SomeRowArray[curOrientation];
		int colOffset = SomeColArray[curOrientation];
		col += colOffset;
		row += rowOffset;
		curCataMapPtr = &CatacombMapAdvance[ row ][ col ];
		if( *curCataMapPtr == CATA_MA_32_BEYOND ){
			if( someFlag ){
				MakeCataDoor(row - rowOffset, col - colOffset);
			}else{
				if( randFactor1 < 50 ){
					if( curOrientation == O_1_DEC_COL || curOrientation == O_3_INC_COL ){
						MakeCataPassageFloor(row - 1, col);
					}else{
						MakeCataPassageFloor(row, col - 1);
					}
				}
				if( randFactor2 < 50 ){
					if( curOrientation == O_1_DEC_COL || curOrientation == O_3_INC_COL ){
						MakeCataPassageFloor(row + 1, col);
					}else{
						MakeCataPassageFloor(row, col + 1);
					}
				}
			}
			someFlag = 0;
			*curCataMapPtr = CATA_MA_44_PASSAGE_FLOOR;
		}else{
			if( someFlag == 0 && *curCataMapPtr == CATA_MA_35_WALL ){
				MakeCataDoor(row, col);
			}
			if( *curCataMapPtr != CATA_MA_44_PASSAGE_FLOOR ){
				someFlag = 1;
			}
		}
		int deltaRow = abs(secondDoorRow - row);
		int deltaCol = abs(secondDoorCol - col);
		int someChanse = 0;
		if( deltaRow <= deltaCol ){
			someChanse = 5 * deltaCol;
			LimitToMax(someChanse, 80);
			if( RangeRND(0, 100) < someChanse ){
				if( secondDoorCol <= col || col >= 40 ){
					curOrientation = O_1_DEC_COL;
				}else{
					curOrientation = O_3_INC_COL;
				}
			}
		}else{
			someChanse = 2 * deltaRow;
			LimitToMax(someChanse, 30);
			if( RangeRND(0, 100) < someChanse ){
				if( secondDoorRow <= row || row >= 40 ){
					curOrientation = O_4_DEC_ROW;
				}else{
					curOrientation = O_2_INC_ROW;
				}
			}
		}
		if( deltaCol < 10 && row == secondDoorRow && ( curOrientation == O_2_INC_ROW || curOrientation == O_4_DEC_ROW ) ){
			if( secondDoorCol <= col || col >= 40 ){
				curOrientation = O_1_DEC_COL;
			}else{
				curOrientation = O_3_INC_COL;
			}
		}
		if( deltaRow < 10 && col == secondDoorCol && ( curOrientation == O_1_DEC_COL || curOrientation == O_3_INC_COL ) ){
			if( secondDoorRow <= row || row >= 40 ){
				curOrientation = O_4_DEC_ROW;
			}else{
				curOrientation = O_2_INC_ROW;
			}
		}
		if( deltaCol == 1 && deltaRow > 1 && ( curOrientation == O_1_DEC_COL || curOrientation == O_3_INC_COL ) ){
			if( secondDoorRow <= row || row >= 40 ){
				curOrientation = O_4_DEC_ROW;
			}else{
				curOrientation = O_2_INC_ROW;
			}
		}
		if( deltaRow == 1 && deltaCol > 1 && ( curOrientation == O_2_INC_ROW || curOrientation == O_4_DEC_ROW )){
			if( secondDoorCol <= col || row >= 40 ){
				curOrientation = O_1_DEC_COL;
			}else{
				curOrientation = O_3_INC_COL;
			}
		}
		if( deltaRow == 0 && *curCataMapPtr != CATA_MA_32_BEYOND && ( curOrientation == O_2_INC_ROW || curOrientation == O_4_DEC_ROW ) ){
			if( secondDoorRow <= firstDoorRow || row >= 40 ){
				curOrientation = O_1_DEC_COL;
			}else{
				curOrientation = O_3_INC_COL;
			}
		}
		if( deltaCol == 0 && *curCataMapPtr != CATA_MA_32_BEYOND && ( curOrientation == O_1_DEC_COL || curOrientation == O_3_INC_COL ) ){
			if( secondDoorCol <= firstDoorCol || col >= 40 ){
				curOrientation = O_4_DEC_ROW;
			}else{
				curOrientation = O_2_INC_ROW;
			}
		}
	}
}

//----- (00411216) --------------------------------------------------------
void __fastcall MakeCataDoor(int row, int col)
{
	int cell = col + 40 * row;
	char curCataValue = CatacombMapAdvance[ 0 ][ cell ];
	if( CatacombMapAdvance[ 0 ][ cell - 40 ] == CATA_MA_68_DOOR 
		|| CatacombMapAdvance[ 0 ][ cell + 40 ] == CATA_MA_68_DOOR 
		|| CatacombMapAdvance[ 0 ][ cell - 1 ] == CATA_MA_68_DOOR 
		|| CatacombMapAdvance[ 0 ][ cell + 1 ] == CATA_MA_68_DOOR 
		|| curCataValue == CATA_MA_66_RIGHT_CORNER 
		|| curCataValue == CATA_MA_67_UP_CORNER 
		|| curCataValue == CATA_MA_65_DOWN_CORNER 
		|| curCataValue == CATA_MA_69_LEFT_CORNER ){
			return;
	}
	CatacombMapAdvance[ 0 ][ cell ] = CATA_MA_68_DOOR;
}

//----- (00411277) --------------------------------------------------------
void __fastcall MakeCataPassageFloor(int row, int col)
{
	int cell = col + 40 * row;
	if( CatacombMapAdvance[ 0 ][ cell ] == CATA_MA_32_BEYOND ){
		CatacombMapAdvance[ 0 ][ cell ] = CATA_MA_44_PASSAGE_FLOOR;
	}
}

//----- (0041128F) --------------------------------------------------------
void __fastcall CataFillWallAndFloorMapWithUsingSomePatterns(int row, int col)
{
	/* алгоритм следующий:
		есть куча шаблонов каждый из 10ти значений.
		проверяется квадрат 3 на 3 (в CatacombMapAdvance) вокруг нашей клетки на соответствие шаблону
		если подошёл, то ставится 10 значение соответствующей клетке Map
		квадрат может совпадать с несколькими шаблонами. Тогда приоритет отдаётся самому последнему
	*/
	for( int patternIndex = 0; SomeCataPatternMaps10x100[patternIndex * 10 + 4] != 255; patternIndex++ ){
		int checkingCol = col - 1;
		int checkingRow = row - 1;
		bool isPatternFit = 1;

		for( int patternPosition = 0; patternPosition < 10 && isPatternFit == 1; patternPosition++ ){
			if( patternPosition == 9 ){
				if( isPatternFit == 1 ){
					Map[ row ][ col ] = SomeCataPatternMaps10x100[patternIndex * 10 + 9];
				}
				break;
			}

			isPatternFit = 0;
			if( patternPosition == 3 || patternPosition == 6 ){
				checkingCol++;
				checkingRow = row - 1;
			}
			if( checkingRow < 0 || checkingRow >= 40 || checkingCol < 0 || checkingCol >= 40 ){
				isPatternFit = 1;
			}else{
				char catacombMapAdvance = CatacombMapAdvance[ checkingRow ][ checkingCol ];
				switch( SomeCataPatternMaps10x100[patternIndex * 10 + patternPosition] ){
				case 1:
					if( catacombMapAdvance == CATA_MA_35_WALL ){
						isPatternFit = 1;
					}
					break;
				case 2:
					if( catacombMapAdvance == CATA_MA_46_FLOOR ){
						isPatternFit = 1;
					}
					break;
				case 4:
					if( catacombMapAdvance == CATA_MA_32_BEYOND ){
						isPatternFit = 1;
					}
					break;
				case 3:
					if( catacombMapAdvance == CATA_MA_68_DOOR ){
						isPatternFit = 1;
					}
					break;
				case 5:
					if( catacombMapAdvance == CATA_MA_68_DOOR || catacombMapAdvance == CATA_MA_46_FLOOR ){
						isPatternFit = 1;
					}
					break;
				case 6:
					if( catacombMapAdvance == CATA_MA_68_DOOR || catacombMapAdvance == CATA_MA_35_WALL ){
						isPatternFit = 1;
					}
					break;
				case 7:
					if( catacombMapAdvance == CATA_MA_32_BEYOND || catacombMapAdvance == CATA_MA_46_FLOOR ){
						isPatternFit = 1;
					}
					break;
				case 8:
					if( catacombMapAdvance == CATA_MA_68_DOOR || catacombMapAdvance == CATA_MA_35_WALL || catacombMapAdvance == CATA_MA_46_FLOOR ){
						isPatternFit = 1;
					}
					break;
				case 0:
					isPatternFit = 1;
					break;
				default:
					break;
				}
			}
			checkingRow++;
		}
	}
}

//----- (00411420) --------------------------------------------------------
bool CataHallsExpand()
{
	int someCount = CountOfCataBeyond();
	for( int tryesCount = 0; someCount > 700 && tryesCount < 100; someCount = CountOfCataBeyond()){
		int row = RangeRND(0, 38) + 1;
		int col = RangeRND(0, 38) + 1;
		int cell = row * 40 + col;
		if( CatacombMapAdvance[ 0 ][ cell ] != CATA_MA_35_WALL ){
			continue;
		}
		bool mayIncCol = 0;
		bool mayDecCol = 0;
		bool mayIncRow = 0;
		bool mayDecRow = 0;
		char v6 = CatacombMapAdvance[ 0 ][ cell - 40 ];
		char v7 = CatacombMapAdvance[ 0 ][ cell - 1 ];

		if( v6 == CATA_MA_32_BEYOND && CatacombMapAdvance[ 0 ][ cell + 40 ] == CATA_MA_46_FLOOR ){// переполение при row == 39. Как исправить не понимаю

			if( CatacombMapAdvance[ 0 ][ cell + 39 ] == CATA_MA_46_FLOOR 
				&& CatacombMapAdvance[ 0 ][ cell + 41 ] == CATA_MA_46_FLOOR 
				&& CatacombMapAdvance[ 0 ][ cell - 41 ] == v6 
				&& CatacombMapAdvance[ 0 ][ cell - 39 ] == v6 ){
					mayIncCol = 1;
					mayDecCol = 1;
					mayDecRow = 1;
			}

		}else if( CatacombMapAdvance[ 0 ][ cell + 40 ] == CATA_MA_32_BEYOND && v6 == CATA_MA_46_FLOOR ){

			if( CatacombMapAdvance[ 0 ][ cell - 41 ] == v6 
				&& CatacombMapAdvance[ 0 ][ cell - 39 ] == v6 
				&& CatacombMapAdvance[ 0 ][ cell + 39 ] == CATA_MA_32_BEYOND 
				&& CatacombMapAdvance[ 0 ][ cell + 41 ] == CATA_MA_32_BEYOND ){
					mayIncCol = 1;
					mayDecCol = 1;
					mayIncRow = 1;
			}

		}else if( v7 == CATA_MA_32_BEYOND && CatacombMapAdvance[ 0 ][ cell + 1 ] == CATA_MA_46_FLOOR ){

			if( CatacombMapAdvance[ 0 ][ cell - 39 ] == CATA_MA_46_FLOOR 
				&& CatacombMapAdvance[ 0 ][ cell + 41 ] == CATA_MA_46_FLOOR 
				&& CatacombMapAdvance[ 0 ][ cell - 41 ] == v7 
				&& CatacombMapAdvance[ 0 ][ cell + 39 ] == v7 ){
					mayIncRow = 1;
					mayDecRow = 1;
					mayDecCol = 1;
			}

		}else{

			if( CatacombMapAdvance[ 0 ][ cell + 1 ] == CATA_MA_32_BEYOND 
				&& v7 == CATA_MA_46_FLOOR 
				&& CatacombMapAdvance[ 0 ][ cell - 41 ] == v7 
				&& CatacombMapAdvance[ 0 ][ cell + 39 ] == v7 
				&& CatacombMapAdvance[ 0 ][ cell - 39 ] == CATA_MA_32_BEYOND 
				&& CatacombMapAdvance[ 0 ][ cell + 41 ] == CATA_MA_32_BEYOND ){
					mayIncRow = 1;
					mayDecRow = 1;
					mayIncCol = 1;
			}

		}

		if( !IsValidCombination(mayDecRow, mayDecCol, mayIncRow, mayIncCol) ){
			++tryesCount;
			continue;
		}
		
		int startRow;
		int endRow;
		int startCol;
		int endCol;

		if( mayDecRow ){
			startRow = row - 1;
		}else{
			startRow = row;
		}

		if( mayIncRow ){
			endRow = row + 1;
		}else{
			endRow = row;
		}

		if( mayDecCol ){
			startCol = col - 1;
		}else{
			startCol = col;
		}

		if( mayIncCol ){
			endCol = col + 1;
		}else{
			endCol = col;
		}
		


		if( !mayDecRow ){

			// вначале считаем длину линии с endRow двигаясь в обе стороны до предела
			while( mayDecCol || mayIncCol ){
				if( startCol == 0 ){
					mayDecCol = 0;
				}
				if( endCol == 39 ){
					mayIncCol = 0;
				}
				if( endCol - startCol >= 14 ){
					break;
				}
				if( mayDecCol ){
					--startCol;
				}
				if( mayIncCol ){
					++endCol;
				}
				if( CatacombMapAdvance[ endRow ][ startCol ] != CATA_MA_32_BEYOND ){
					mayDecCol = 0;
				}
				if( CatacombMapAdvance[ endRow ][ endCol ] != CATA_MA_32_BEYOND ){
					mayIncCol = 0;
				}
			}

			// уменьшаем линию на 2 с обоих концов
			endCol -= 2;
			startCol += 2;
			if( endCol - startCol <= 5 ){// после уменьшения разница между ними должна составлять более 5
				++tryesCount;
				continue;
			}

			// теперь считаем ширину прямоугольника, проверяя все клетки линии и сдвигая линию по endRow
			while( mayIncRow ){
				if( endRow == 39 || endRow - startRow >= 12 ){
					break;
				}
				for( int col = startCol; col <= endCol; col++ ){
					if( CatacombMapAdvance[ endRow ][ col ] != CATA_MA_32_BEYOND ){
						mayIncRow = 0;
						break;
					}
				}
				if( mayIncRow ){
					++endRow;
				}
			}

			endRow -= 2;
			if( endRow - startRow <= 5 ){// после дохождения до предела, ширина должна составлять более 5
				++tryesCount;
				continue;
			}
			ExpandCataHall(startRow, startCol, endRow, endCol);// расширяем холл
			CompleteExpandCataHall(startRow, startCol, endRow, endCol);// исправляем погрешности на стыках
			++tryesCount;
			continue;
		}
		if( !mayIncRow ){
			while( mayDecCol || mayIncCol ){
				if( startCol == 0 ){
					mayDecCol = 0;
				}
				if( endCol == 39 ){
					mayIncCol = 0;
				}
				if( endCol - startCol >= 14 ){
					break;
				}
				if( mayDecCol ){
					--startCol;
				}
				if( mayIncCol ){
					++endCol;
				}
				if( CatacombMapAdvance[ startRow ][ startCol ] != CATA_MA_32_BEYOND ){
					mayDecCol = 0;
				}
				if( CatacombMapAdvance[ startRow ][ endCol ] != CATA_MA_32_BEYOND ){
					mayIncCol = 0;
				}
			}
			endCol -= 2;
			startCol += 2;
			if( endCol - startCol <= 5 ){
				++tryesCount;
				continue;
			}

			while( mayDecRow ){
				if( startRow == 0 || endRow - startRow >= 12 ){
					break;
				}
				
				for( int col = startCol; col <= endCol; col++ ){
					if( CatacombMapAdvance[ startRow ][ col ] != CATA_MA_32_BEYOND ){
						mayDecRow = 0;
						break;
					}
				}

				if( mayDecRow ){
					--startRow;
				}
			};

			startRow += 2;

			if( endRow - startRow <= 5 ){
				++tryesCount;
				continue;
			}
			ExpandCataHall(startRow, startCol, endRow, endCol);
			CompleteExpandCataHall(startRow, startCol, endRow, endCol);
			++tryesCount;
			continue;

		}
		if( !mayDecCol ){
			while( mayDecRow || mayIncRow ){
				if( startRow == 0 ){
					mayDecRow = 0;
				}
				if( endRow == 39 ){
					mayIncRow = 0;
				}
				if( endRow - startRow >= 14 ){
					break;
				}
				if( mayDecRow ){
					--startRow;
				}
				if( mayIncRow ){
					++endRow;
				}
				if( CatacombMapAdvance[ startRow ][ endCol ] != CATA_MA_32_BEYOND ){ 
					mayDecRow = 0;
				}
				if( CatacombMapAdvance[ endRow ][ endCol ] != CATA_MA_32_BEYOND ){ 
					mayIncRow = 0;
				}
			}
			startRow += 2;
			endRow -= 2;
			if( endRow - startRow <= 5 ){
				++tryesCount;
				continue;
			}

			while( mayIncCol ){
				if( endCol == 39 || endCol - startCol >= 12 ){
					break;
				}

				for( int row = startRow; row <= endRow; row++ ){
					if( CatacombMapAdvance[ row ][ endCol ] != CATA_MA_32_BEYOND ){
						mayIncCol = 0;
						break;
					}
				}

				if( mayIncCol ){
					endCol++;
				}
			}
			endCol -= 2;
			if( endCol - startCol <= 5 ){
				++tryesCount;
				continue;
			}
			ExpandCataHall(startRow, startCol, endRow, endCol);
			CompleteExpandCataHall(startRow, startCol, endRow, endCol);
			++tryesCount;
			continue;
		}
		if( !mayIncCol ){
			while( mayDecRow || mayIncRow ){
				if( startRow == 0 ){
					mayDecRow = 0;
				}
				if( endRow == 39 ){
					mayIncRow = 0;
				}
				if( endRow - startRow >= 14 ){
					break;
				}
				if( mayDecRow ){
					--startRow;
				}
				if( mayIncRow ){
					++endRow;
				}
				if( CatacombMapAdvance[ startRow ][ startCol ] != CATA_MA_32_BEYOND ){ 
					mayDecRow = 0;
				}
				if( CatacombMapAdvance[ endRow ][ startCol ] != CATA_MA_32_BEYOND ){ 
					mayIncRow = 0;
				}
			}
			startRow += 2;
			endRow -= 2;

			if( endRow - startRow <= 5 ){
				++tryesCount;
				continue;
			}

			while( mayDecCol ){
				if( startCol == 0 ){
					mayDecCol = 0;
				}
				if( endCol - startCol >= 12 ){
					mayDecCol = 0;
				}

				for( int row = startRow; row <= endRow; row++ ){
					if( CatacombMapAdvance[ row ][ startCol ] != CATA_MA_32_BEYOND ){
						mayDecCol = 0;
						break;
					}
				}

				if( mayDecCol ){
					--startCol;
				}
				
			};
			startCol += 2;

			if( endCol - startCol <= 5 ){
				++tryesCount;
				continue;
			}
			ExpandCataHall(startRow, startCol, endRow, endCol);
			CompleteExpandCataHall(startRow, startCol, endRow, endCol);
			++tryesCount;
			continue;
		}
		++tryesCount;
	}
	return CountOfCataBeyond() <= 700;
}

//----- (0041199A) --------------------------------------------------------
bool __fastcall IsValidCombination(int mayDecRow, int mayDecCol, int mayIncRow, int mayIncCol)
{
	if( mayDecRow && mayIncRow && (mayDecCol || mayIncCol) 
		|| mayDecCol && mayIncCol && (mayDecRow || mayIncRow) ){
			return true;
	}
	return false;
}

//----- (004119E0) --------------------------------------------------------
int CountOfCataBeyond()
{
	int count = 0;
	for( int cell = 0; cell < 40*40; cell++ ){
		if( CatacombMapAdvance[ 0 ][ cell ] == CATA_MA_32_BEYOND ){
			count++;
		}
	}
	return count;
}

//----- (00411A02) --------------------------------------------------------
void __fastcall ExpandCataHall(int startRow, int startCol, int endRow, int endCol)
{
	for( int col = startCol; col <= endCol; col++ ){
		for( int row = startRow; row <= endRow; row++ ){
			CatacombMapAdvance[ row ][ col ] = CATA_MA_46_FLOOR;// пол?
		}
	}

	for( int col = startCol; col <= endCol; col++ ){
		CatacombMapAdvance[ startRow ][ col ] = CATA_MA_35_WALL; // стены?
		CatacombMapAdvance[ endRow ][ col ] = CATA_MA_35_WALL;
	}

	for( int row = startRow; row <= endRow; row++ ){
		CatacombMapAdvance[ row ][ startCol ] = CATA_MA_35_WALL;
		CatacombMapAdvance[ row ][ endCol ] = CATA_MA_35_WALL;
	}
}

//----- (00411A8B) --------------------------------------------------------
void __fastcall CompleteExpandCataHall(int startRow, int startCol, int endRow, int endCol)
{
	// убираем неровные края между холлом и его расширением
	for( int row = startRow + 1; row < endRow; row++ ){
		uchar& nextEndCol = CatacombMapAdvance[ row ][ endCol + 1 ];// на самом деле учар
		uchar& prevStartCol = CatacombMapAdvance[ row ][ startCol - 1 ];

		// если с обеих сторон от стены пол, то сносим стену
		if( prevStartCol == CATA_MA_46_FLOOR && CatacombMapAdvance[ row ][ startCol + 1 ] == CATA_MA_46_FLOOR ){
			CatacombMapAdvance[ row ][ startCol ] = CATA_MA_46_FLOOR;
		}
		if( CatacombMapAdvance[ row ][ endCol - 1 ] == CATA_MA_46_FLOOR && nextEndCol == CATA_MA_46_FLOOR ){
			CatacombMapAdvance[ row ][ endCol ] = CATA_MA_46_FLOOR;
		}
		// если находим дверь висящую теперь в воздухе, заменяем её на пол
		if( prevStartCol == CATA_MA_68_DOOR ){
			prevStartCol = CATA_MA_46_FLOOR;
		}
		if( nextEndCol == CATA_MA_68_DOOR ){
			nextEndCol = CATA_MA_46_FLOOR;
		}
	}

	for( int col = startCol + 1; col < endCol; col++ ){

		uchar& nextEndRow = CatacombMapAdvance[ endRow + 1 ][ col ];// на самом деле учар
		uchar& prevStartRow = CatacombMapAdvance[ startRow - 1 ][ col ];
		// если с обеих сторон от стены пол, то сносим стену
		if( prevStartRow == CATA_MA_46_FLOOR && CatacombMapAdvance[ startRow + 1 ][ col ] == CATA_MA_46_FLOOR ){
			CatacombMapAdvance[ startRow ][ col ] = CATA_MA_46_FLOOR;
		}
		if( CatacombMapAdvance[ endRow - 1 ][ col ] == CATA_MA_46_FLOOR && nextEndRow == CATA_MA_46_FLOOR ){
			CatacombMapAdvance[ endRow ][ col ] = CATA_MA_46_FLOOR;
		}
		// если находим дверь висящую теперь в воздухе, заменяем её на пол
		if( prevStartRow == CATA_MA_68_DOOR ){
			prevStartRow = CATA_MA_46_FLOOR;
		}
		if( nextEndRow == CATA_MA_68_DOOR ){
			nextEndRow = CATA_MA_46_FLOOR;
		}
	}
}

//----- (00411B66) --------------------------------------------------------
void InitCataWallsTransparency()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			if( Map[ row ][ col ] == CATA_WAFM_3_FLOOR && !HallMap[Convert40to112(row)][Convert40to112(col)] ){ // пол не отнесённый ни к одной из комнат относим к новой комнате
				SetCataCellTransparency(row, col, Convert40to112(row), Convert40to112(col), 0);
				HallIndex++;
			}
		}
	}
}

//----- (00411BD5) --------------------------------------------------------
void __fastcall SetCataCellTransparency(int row40, int col40, int row112, int col112, int orientation)
{
	uchar wallTransparentIndex = HallIndex;
	int curRow112 = row112;
	int curCol112 = col112;
	int curCol40 = col40;
	int curRow40 = row40;
	while( Map[ curRow40 ][ curCol40 ] == CATA_WAFM_3_FLOOR && !HallMap[curRow112][curCol112] ){
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		// row ->
		//5 4 6
		//2 0 1
		//7 3 8
		SetCataCellTransparency(curRow40 + 1,	curCol40,		curRow112 + 2,		curCol112,			1);
		SetCataCellTransparency(curRow40 - 1,	curCol40,		curRow112 - 2,		curCol112,			2);
		SetCataCellTransparency(curRow40,		curCol40 + 1,	curRow112,			curCol112 + 2,		3);
		SetCataCellTransparency(curRow40,		curCol40 - 1,	curRow112,			curCol112 - 2,		4);
		SetCataCellTransparency(curRow40 - 1,	curCol40 - 1,	curRow112 - 2,		curCol112 - 2,		5);
		SetCataCellTransparency(curRow40 + 1,	curCol40 - 1,	curRow112 + 2,		curCol112 - 2,		6);
		SetCataCellTransparency(curRow40 - 1,	curCol40 + 1,	curRow112 - 2,		curCol112 + 2,		7);
		orientation = 8;
		curCol40++;
		curRow40++;
		curRow112 = Convert40to112(curRow40);
		curCol112 = Convert40to112(curCol40);
	}

	switch (orientation ){
	case 1:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 2:
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 3:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	case 4:
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 5:
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 6:
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 7:
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	case 8:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	}
}

//----- (00411DC9) --------------------------------------------------------
void CataSetAdditionalWallsTransparency()
{
	for( int col40 = 0; col40 < 40; col40++ ){
		for( int row40 = 0; row40 < 40; row40++ ){

			uchar curWallAndFloorMap =		Map[ row40+0 ][ col40+0 ];
			uchar nextRowWallAndFloorMap =	Map[ row40+1 ][ col40+0 ];
			uchar prevColWallAndFloorMap =	Map[ row40+0 ][ col40-1 ];

			uchar* curTransparentWallsMap =			&HallMap[ (Convert40to112(row40)+0) ][ (Convert40to112(col40)+0) ];
			uchar* nextRowTransparentWallsMap =		&HallMap[ (Convert40to112(row40)+1) ][ (Convert40to112(col40)+0) ];
			uchar* nextColTransparentWallsMap =		&HallMap[ (Convert40to112(row40)+0) ][ (Convert40to112(col40)+1) ];
			uchar* nextRowColTransparentWallsMap =	&HallMap[ (Convert40to112(row40)+1) ][ (Convert40to112(col40)+1) ];
			switch (curWallAndFloorMap ){
			case CATA_WAFM_14_CORNER:
				if( prevColWallAndFloorMap == CATA_WAFM_10_RD_WALL ){
					*nextRowTransparentWallsMap = *curTransparentWallsMap;
					*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				}
				break;
			case CATA_WAFM_15_CORNER:
				if( nextRowWallAndFloorMap == CATA_WAFM_11_LD_WALL ){
					*nextColTransparentWallsMap = *curTransparentWallsMap;
					*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				}
				break;
			case CATA_WAFM_10_RD_WALL:
				*nextRowTransparentWallsMap = *curTransparentWallsMap;
				*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				break;
			case CATA_WAFM_11_LD_WALL:
				*nextColTransparentWallsMap = *curTransparentWallsMap;
				*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				break;
			case CATA_WAFM_16_CORNER:
				*nextRowTransparentWallsMap = *curTransparentWallsMap;
				*nextColTransparentWallsMap = *curTransparentWallsMap;
				*nextRowColTransparentWallsMap = *curTransparentWallsMap;
				break;
			}
		}
	}

}

//----- (00411E5D) --------------------------------------------------------
void SomeCataCornersConvert()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar& curWallAndFloorMap =		Map[ row+0 ][ col+0 ];
			uchar& nextRowWallAndFloorMap =	Map[ row+1 ][ col+0 ];
			uchar& nextColWallAndFloorMap =	Map[ row+0 ][ col+1 ];

			if( curWallAndFloorMap == CATA_WAFM_13_CORNER && nextRowWallAndFloorMap != CATA_WAFM_11_LD_WALL ){
				curWallAndFloorMap = CATA_WAFM_146;
			}
			if( curWallAndFloorMap == CATA_WAFM_11_LD_WALL && nextRowWallAndFloorMap != CATA_WAFM_11_LD_WALL ){
				curWallAndFloorMap = CATA_WAFM_144;
			}
			if( curWallAndFloorMap == CATA_WAFM_15_CORNER && nextRowWallAndFloorMap != CATA_WAFM_11_LD_WALL ){
				curWallAndFloorMap = CATA_WAFM_148;
			}
			if( curWallAndFloorMap == CATA_WAFM_10_RD_WALL && nextColWallAndFloorMap != CATA_WAFM_10_RD_WALL ){
				curWallAndFloorMap = CATA_WAFM_143;
			}
			if( curWallAndFloorMap == CATA_WAFM_13_CORNER && nextColWallAndFloorMap != CATA_WAFM_10_RD_WALL ){
				curWallAndFloorMap = CATA_WAFM_146;
			}
			if( curWallAndFloorMap == CATA_WAFM_14_CORNER && nextColWallAndFloorMap != CATA_WAFM_15_CORNER ){
				curWallAndFloorMap = CATA_WAFM_147;
			}

		}
	}
}

//----- (00411EC9) --------------------------------------------------------
void InitCataArchs()
{
	int* v0;      // ebx@1
	int v1;       // edi@1
	int* v2;      // edx@2
	char* v3;     // ecx@2
	int v4;       // esi@2
	int v5;       // eax@3
	char v6;      // ST00_1@9
	int v7;       // ecx@15
	int* v8;      // esi@15
	char* result; // eax@16
	int* v10;     // edx@16
	int v11;      // ebx@16
	int v12;      // edi@17
	v1 = 0;
	v0 = FineMap[ 0 ];
	do{
		v3 = &ArchGraphicsMap[ 0 ][ v1 ];
		v2 = v0;
		v4 = 112;
		do{
			v5 = *v2;
			if( *v2 != 541 && v5 != 178 && v5 != 551 ){
				if( v5 == 542 || v5 == 553 )
					goto LABEL_11;
				if( v5 != 13 ){
					if( v5 != 17 )
						goto LABEL_13;
LABEL_11:
					v6 = 6;
					goto LABEL_12;
				}
			}
			v6 = 5;
LABEL_12:
			*v3 = v6;
LABEL_13:
			v2 += 112;
			v3 += 112;
			--v4;
		}while( v4 );
		++v0;
		++v1;
	}while( (int)v0 < (int)&FineMap[ 0 ][ 112 ] );
	v7 = 0;
	v8 = FineMap[ 0 ];
	do{
		result = &ArchGraphicsMap[ 0 ][ v7 + 2 ];
		v10 = v8;
		v11 = 112;
		do{
			v12 = *v10;
			if( *v10 == 132 ){
				*(result - 1) = 2;
				*result = 1;
			}else{
				if( v12 == 135 || v12 == 139 ){
					*(result + 110) = 3;
					*(result + 222) = 4;
				}
			}
			v10 += 112;
			result += 112;
			--v11;
		}while( v11 );
		++v8;
		++v7;
	}while( (int)v8 < (int)&FineMap[ 0 ][ 112 ] );
}

//----- (00411F8B) --------------------------------------------------------
void MakeDoorsInWoodWalls()
{
	for( int col = 1; col < 39; col++ ){
		for( int row = 1; row < 39; row++ ){

			uchar& curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			if( curRowCurCol != CAVE_WAFM_7_FLOOR ){
				continue;
			}

			uchar prevRowCurCol =	Map[ row - 1 ][ col + 0 ];
			uchar nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar curRowPrevCol =	Map[ row + 0 ][ col - 1 ];
			uchar curRowNextCol =	Map[ row + 0 ][ col + 1 ];

			if( IsWoodWall(prevRowCurCol) && IsWoodWall(nextRowCurCol) ){
					curRowCurCol = CAVE_WAFM_146_WOOD_WALL_M_CDOOR;
			}else if( IsWoodWall(curRowPrevCol) && IsWoodWall(curRowNextCol) ){
					curRowCurCol = CAVE_WAFM_147_WOOD_WALL_UNM_CDOOR;
			}

		}
	}
}

//----- (00411FEF) --------------------------------------------------------
void DeleteUnwantedWoodenDoorTiles()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar& curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			if( curRowCurCol == CAVE_WAFM_146_WOOD_WALL_M_CDOOR ){
				uchar nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
				uchar prevRowCurCol =	Map[ row - 1 ][ col + 0 ];
				if( !IsWoodWall(nextRowCurCol) 
				 || !IsWoodWall(prevRowCurCol) 
				 || (!IsMainDiagonalNearDoorTile (nextRowCurCol) && !IsMainDiagonalNearDoorTile (prevRowCurCol)) ){
					curRowCurCol = CAVE_WAFM_7_FLOOR;
				}
			}else if( curRowCurCol == CAVE_WAFM_147_WOOD_WALL_UNM_CDOOR ){
				uchar curRowNextCol =	Map[ row + 0 ][ col + 1 ];
				uchar curRowPrevCol =	Map[ row + 0 ][ col - 1 ];
				if( !IsWoodWall(curRowNextCol) 
				 || !IsWoodWall(curRowPrevCol) 
				 || (!IsUnmainDiagonalNearDoorTile (curRowNextCol) && !IsUnmainDiagonalNearDoorTile (curRowPrevCol)) ){
						curRowCurCol = CAVE_WAFM_7_FLOOR;
				}
			}
		}
	}
}

//----- (00412102) --------------------------------------------------------
bool PlaceAnvilPatternToMap()
{
	int patternRowSize = PatMap11x11_48A678_AnvilOfFuryPattern[0];
	int patternColSize = PatMap11x11_48A678_AnvilOfFuryPattern[1];
	uchar* beforePattern = &PatMap11x11_48A678_AnvilOfFuryPattern[2];
	uchar* afterPattern = beforePattern + patternRowSize * patternColSize;
	int mapRowsLimit = 40 - patternRowSize;
	int mapColumnsLimit = 40 - patternColSize;
	int row = RangeRND(0, mapRowsLimit);
	int col = RangeRND(0, mapColumnsLimit);
	int tryesCounter = 0;
	bool continueFlag = 0;
	do{
		if( tryesCounter >= 200 ){
			return 1;
		}
		tryesCounter++;
		continueFlag = 1;

		// проверка на соответствие паттерну
		for( int colOffset = 0; colOffset < patternColSize && continueFlag; colOffset++ ){
			for( int rowOffset = 0; rowOffset < patternRowSize && continueFlag; rowOffset++ ){
				uchar neededTile = beforePattern[colOffset*patternRowSize+rowOffset];
				int mapCell = (row+rowOffset)*40 + (col+colOffset);
				if( (neededTile && (Map[ 0 ][ mapCell ] != neededTile)) || FixedMap[ 0 ][ mapCell ] ){
					continueFlag = 0; //бида бида, паттерн не соблюдается, надо искать другое место
				}
			}
		}

		if( continueFlag ){
			break;
		}
		if( ++row == mapRowsLimit ){
			row = 0;
			if( ++col == mapColumnsLimit ){
				col = 0;
			}
		}
	}while( !continueFlag );

	for( int colOffset = 0; colOffset < patternColSize; colOffset++ ){
		for( int rowOffset = 0; rowOffset < patternRowSize; rowOffset++ ){
			uchar newTile = afterPattern[colOffset*patternRowSize+rowOffset];
			int mapCell = (row+rowOffset)*40 + (col+colOffset);
			if( newTile ){
				Map[ 0 ][ mapCell ] = newTile;
			}
			FixedMap[ 0 ][ mapCell ] |= BIT(8);
		}
	}
	StartPatternRow40 = row;
	StartPatternCol40 = col;
	PatternMapRows = patternRowSize;
	PatternMapCols = patternColSize;
	return 0;
}

//----- (00719DC0) --------------------------------------------------------
bool PlaceIzualPatternToMap()
{
	int patternRowSize = PatMap9x9_IzualPattern[0];
	int patternColSize = PatMap9x9_IzualPattern[1];
	uchar* beforePattern = &PatMap9x9_IzualPattern[2];
	uchar* afterPattern = beforePattern + patternRowSize * patternColSize;
	int mapRowsLimit = 40 - patternRowSize;
	int mapColumnsLimit = 40 - patternColSize;
	int row = RangeRND(0, mapRowsLimit);
	int col = RangeRND(0, mapColumnsLimit);
	int tryesCounter = 0;
	bool continueFlag = 0;
	do{
		if( tryesCounter >= 200 ){
			return 1;
		}
		tryesCounter++;
		continueFlag = 1;

		// проверка на соответствие паттерну
		for( int colOffset = 0; colOffset < patternColSize && continueFlag; colOffset++ ){
			for( int rowOffset = 0; rowOffset < patternRowSize && continueFlag; rowOffset++ ){
				uchar neededTile = beforePattern[colOffset*patternRowSize+rowOffset];
				int mapCell = (row+rowOffset)*40 + (col+colOffset);
				if( (neededTile && (Map[ 0 ][ mapCell ] != neededTile)) || FixedMap[ 0 ][ mapCell ] ){
					continueFlag = 0; //бида бида, паттерн не соблюдается, надо искать другое место
				}
			}
		}

		if( continueFlag ){
			break;
		}
		if( ++row == mapRowsLimit ){
			row = 0;
			if( ++col == mapColumnsLimit ){
				col = 0;
			}
		}
	}while( !continueFlag );

	for( int colOffset = 0; colOffset < patternColSize; colOffset++ ){
		for( int rowOffset = 0; rowOffset < patternRowSize; rowOffset++ ){
			uchar newTile = afterPattern[colOffset*patternRowSize+rowOffset];
			int mapCell = (row+rowOffset)*40 + (col+colOffset);
			if( newTile ){
				Map[ 0 ][ mapCell ] = newTile;
			}
			FixedMap[ 0 ][ mapCell ] |= BIT(8);
		}
	}
	StartPatternRow40 = row;
	StartPatternCol40 = col;
	PatternMapRows = patternRowSize;
	PatternMapCols = patternColSize;
	return 0;
}

//----- (00412254) --------------------------------------------------------
void CaveConvertTempTailToEnterToTownTiles()
{
	for( int col = 0; col < 39; col++ ){// отсебятина. Заменил 0-40 на 0-39 иначе, читает за границе массива
		for( int row = 0; row < 39; row++ ){

			uchar& curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];
			uchar& nextRowNextCol =	Map[ row + 1 ][ col + 1 ];

			if( curRowCurCol == CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER 
				&& nextRowCurCol == CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER
				&& curRowNextCol == CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER 
				&& nextRowNextCol == CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER ){
					curRowCurCol = CAVE_WAFM_156_ENTER_TO_TOWN;
					nextRowCurCol = CAVE_WAFM_155_ENTER_TO_TOWN;
					curRowNextCol = CAVE_WAFM_153_ENTER_TO_TOWN;
					nextRowNextCol = CAVE_WAFM_154_ENTER_TO_TOWN;
					return;
			}
			// вот это бредятина объединять два конвертирования в одном
			// на 9м когда встретит лестницу, после неё остальные места перестанет конвертировать
			if( curRowCurCol == CAVE_WAFM_5_CORNER_IN_DOWN && nextRowNextCol == CAVE_WAFM_7_FLOOR ){
				curRowCurCol = CAVE_WAFM_7_FLOOR;
			}

		}
	}
}

//----- (004122B8) --------------------------------------------------------
void SomeStrangeCaveTilesConvert()
{
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			uchar& curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar nextRowNextCol =	Map[ row + 1 ][ col + 1 ];
			if( curRowCurCol == CAVE_WAFM_5_CORNER_IN_DOWN && nextRowNextCol == CAVE_WAFM_7_FLOOR ){
				curRowCurCol = CAVE_WAFM_7_FLOOR;
			}
		}
	}

	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			uchar& curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];
			uchar& nextRowNextCol =	Map[ row + 1 ][ col + 1 ];

			if( curRowCurCol == CAVE_WAFM_5_CORNER_IN_DOWN && nextRowNextCol == CAVE_WAFM_12_CORNER_IN_UP ){
				if( nextRowCurCol == CAVE_WAFM_7_FLOOR ){
					curRowCurCol = CAVE_WAFM_7_FLOOR;
					curRowNextCol = CAVE_WAFM_7_FLOOR;
					nextRowNextCol = CAVE_WAFM_7_FLOOR;
				}
				if( curRowNextCol == CAVE_WAFM_7_FLOOR ){
					curRowCurCol = CAVE_WAFM_7_FLOOR;
					nextRowCurCol = CAVE_WAFM_7_FLOOR;
					nextRowNextCol = CAVE_WAFM_7_FLOOR;
				}
			}
		}
	}
}

//----- (0041232C) --------------------------------------------------------
void __fastcall CaveBinPatternSomeStrangeRecursiveCalc(int row, int col)
{
	while( CaveLinkedFloorCheckMap[ row ][ col ] ){
		CaveLinkedFloorCheckMap[ row ][ col ] = 0;
		LinkedFloorTilesCount++;
		CaveBinPatternSomeStrangeRecursiveCalc(row, col - 1);
		CaveBinPatternSomeStrangeRecursiveCalc(row, col + 1);
		CaveBinPatternSomeStrangeRecursiveCalc(row - 1, col);
		row++;
	}
}

//----- (00412384) --------------------------------------------------------
bool IsAllCaveFloorTilesAreLinked()
{
	// проверка все ли клетки проходимые связанны между собой
	int startRow = 0;
	int startCol = 0;
	int floorTilesCount = 0;
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			int cell = row*40 + col;
			if( Map[ 0 ][ cell ] ){
				CaveLinkedFloorCheckMap[ 0 ][ cell ] = 1;
				startRow = row;
				startCol = col;
				floorTilesCount++;
			}else{
				CaveLinkedFloorCheckMap[ 0 ][ cell ] = 0;
			}
		}
	}
	LinkedFloorTilesCount = 0;
	CaveBinPatternSomeStrangeRecursiveCalc(startRow, startCol);
	return floorTilesCount == LinkedFloorTilesCount;
}

//----- (004123E1) --------------------------------------------------------
void __fastcall CreateCaveTypeLabyrinth(int levelRandomSeed, int loadingMode)
{
	InitRandomSeed(levelRandomSeed);
	MapStartRow = 16;
	MapStartCol = 16;
	MapEndRow = 96;
	MapEndCol = 96;
	ClearWallsTransparency();
	ResetPatternMapPos();
	CaveLevelGeneration(loadingMode);
	InitCaveLevelTiles();
	if( DungeonLevel >= 17 ){ //  бездна
		for( int col = 0; col < 112; col++ ){
			for( int row = 0; row < 112; row++ ){
				int dmap = FineMap[ row ][ col ];
				if( dmap >= 382 && dmap <= 457 ){
					ApplyLightSource(row, col, 9, -1);
				}
			}
		}
	}else{ //  пещеры
		for( int col = 0; col < 112; col++ ){
			for( int row = 0; row < 112; row++ ){
				int dmap = FineMap[ row ][ col ];
				if( dmap >= 56 && dmap <= 147 
				 || dmap >= 154 && dmap <= 161 
				 || dmap == 150 || dmap == 152 ){
					ApplyLightSource(row, col, 7, -1); // свет от лавы
				}
			}
		}
	}
	MarkPatternPositionOnMap();
}

//----- (004124CB) --------------------------------------------------------
void __fastcall CaveLevelGeneration(int loadingMode)
{
	MaybeHasLavaTiles = 0;
	while( 1 ){
		// составляем бинарную карту пещер
		bool isBinPatternGenerationComplete = true;
		do{
			InitCaveMaps();
			int mainRoomStartRow = RangeRND(0, 20) + 10;
			int mainRoomStartCol = RangeRND(0, 20) + 10;
			int mainRoomEndRow = mainRoomStartRow + 2;
			int mainRoomEndCol = mainRoomStartCol + 2;
			MakeSerratedCaveBinaryPatternRoom(mainRoomStartRow, mainRoomStartCol, mainRoomEndRow, mainRoomEndCol);
			RecursiveCaveRoomsGeneration(mainRoomStartRow, mainRoomStartCol, 2, 0);
			RecursiveCaveRoomsGeneration(mainRoomEndRow, mainRoomStartCol, 2, 1);
			RecursiveCaveRoomsGeneration(mainRoomStartRow, mainRoomEndCol, 2, 2);
			RecursiveCaveRoomsGeneration(mainRoomStartRow, mainRoomStartCol, 2, 3);
			if( IsQuestOnLevel(Q_10_ANVIL_OF_FURY) ){
				int lavaRectRowPos = RangeRND(0, 10);
				int lavaRectColPos = RangeRND(0, 10);
				CaveMakeRectRoomInBinPattern(lavaRectRowPos + 10, lavaRectColPos + 10, lavaRectRowPos + 22, lavaRectColPos + 22);
			}else if( IsQuestOnLevel(Q_17_IZUAL) ){
				int lavaRectRowPos = RangeRND(0, 10);
				int lavaRectColPos = RangeRND(0, 10);
				CaveMakeRectRoomInBinPattern(lavaRectRowPos + 10, lavaRectColPos + 10, lavaRectRowPos + 20, lavaRectColPos + 20);
			}else if( IsQuestOnLevel(Q_20_ISLAND) ){
				int lavaRectRowPos = RangeRND(0, 10);
				int lavaRectColPos = RangeRND(0, 10);
				CaveMakeRectRoomInBinPattern(lavaRectRowPos + 10, lavaRectColPos + 10, lavaRectRowPos + 16, lavaRectColPos + 16);
			}
			SomeCaveBinPatternConvert_MaybeLavaRiverConvert();
			CaveBinLavaLakeConvert();
			MakeSomeLavaBridgeInCaveBinPattern();
			SomeCaveBinPatternConvert_MaybeLavaRiverConvert();
			SetToZeroLastLinesInCaveBinPattern();
			if( AreaOfLevelRoomsCave() < 600 ){
				isBinPatternGenerationComplete = 0;
			}else{
				isBinPatternGenerationComplete = IsAllCaveFloorTilesAreLinked();
			}
		}while( !isBinPatternGenerationComplete );
		InitCaveWallAndFloorMapFromBynaryPattern();
		bool goFromUp = loadingMode == 0;
		bool goFromDown = loadingMode == 1;
		bool goFromTown = loadingMode > 1;// == 2

		int isGenerationEnd;
		if( DungeonLevel >= 17 ){
			isGenerationEnd = PlaceCavePatMap(PatMap3x3_48A400_AbyssDungeonEnterToUp, 1, 1, -1, -1, goFromUp, 0);
		}else{
			isGenerationEnd = PlaceCavePatMap(PatMap3x3_48A3E8_CaveDungeonEnterToUp, 1, 1, -1, -1, goFromUp, 0);
		}
		if( !isGenerationEnd ){
			if( DungeonLevel >= 17 ){
				isGenerationEnd = PlaceCavePatMap(PatMap3x3_48A430_AbyssDungeonEnterToDown, 1, 1, -1, -1, goFromDown, 1);
			}else{
				isGenerationEnd = PlaceCavePatMap(PatMap3x3_48A418_CaveDungeonEnterToDown, 1, 1, -1, -1, goFromDown, 1);
			}
			if( goFromDown ){
				PlayerRowPos += 2;
				PlayerColPos -= 2;
			}
		}
		if( !isGenerationEnd ){
			if( DungeonLevel == 9 ){
				isGenerationEnd = PlaceCavePatMap(PatMap3x3_48A448_CaveDungeonEnterToTown, 1, 1, -1, -1, goFromTown, 6);
			}
			if( DungeonLevel == 17 ){
				isGenerationEnd = PlaceCavePatMap(PatMap3x3_48A460_AbyssDungeonEnterToTown, 1, 1, -1, -1, goFromTown, 6);
			}
		}
		if( !isGenerationEnd ){
			if( IsQuestOnLevel(Q_10_ANVIL_OF_FURY) ){
				isGenerationEnd = PlaceAnvilPatternToMap();
			}else if( IsQuestOnLevel(Q_17_IZUAL) ){
				isGenerationEnd = PlaceIzualPatternToMap();
			}else if( IsQuestOnLevel( Q_20_ISLAND ) ){
				isGenerationEnd = PlaceIslandPattern();
			}
		}
		if( !isGenerationEnd ){
			if( DungeonLevel >= 17 ){
				MaybeHasLavaTiles += PlaceAbyssWallPattern(PatMap4x5_48A998_ABYSS, 30);
				MaybeHasLavaTiles += PlaceAbyssWallPattern(PatMap4x5_48A9C8_ABYSS, 40);
				MaybeHasLavaTiles += PlaceAbyssWallPattern(PatMap4x4_48A948_ABYSS, 50);
				MaybeHasLavaTiles += PlaceAbyssWallPattern(PatMap4x4_48A970_ABYSS, 60);
				if( MaybeHasLavaTiles < 3 ){
					MaybeHasLavaTiles = 0;
				}
			}else{
				CaveMakeSomeLavaLakes();
			}
			if( MaybeHasLavaTiles ){
				break;
			}
		}
	}

	if( DungeonLevel >= 17 ){
		PlaceCavePattern(PatMap2x3_48A8F8_ABYSS, 70);
		PlaceCavePattern(PatMap3x2_48A908_ABYSS, 70);
		PlaceCavePattern(PatMap2x3_48A918_ABYSS, 30);
		PlaceCavePattern(PatMap3x2_48A928_ABYSS, 30);
		PlaceCavePattern(PatMap2x3_48A8F8_ABYSS, 100);
		PlaceCavePattern(PatMap3x2_48A908_ABYSS, 100);
		PlaceCavePattern(PatMap2x2_48A938_ABYSS, 90);
	}else{
		CaveLavaConvert_SomeBeyondIntoLava();
		CaveConvertTempTailToEnterToTownTiles();
		PlaceCavePattern(PatMap2x3_48A618, 70);
		PlaceCavePattern(PatMap3x2_48A628, 70);
		PlaceCavePattern(PatMap2x3_48A638, 30);
		PlaceCavePattern(PatMap3x2_48A648, 30);
		PlaceCavePattern(PatMap2x3_48A618, 100);
		PlaceCavePattern(PatMap3x2_48A628, 100);
		PlaceCavePattern(PatMap2x2_48A658, 90);
	}
	
	if( DungeonLevel < 17){
		SomeStrangeCaveTilesConvert();
		CaveMakeLavaRivers();
	}
	if( IsQuestOnLevel(Q_10_ANVIL_OF_FURY) ){
		Map[ StartPatternRow40 + 7 ][ StartPatternCol40 + 5 ] = CAVE_WAFM_7_FLOOR;
		Map[ StartPatternRow40 + 8 ][ StartPatternCol40 + 5 ] = CAVE_WAFM_7_FLOOR;
		Map[ StartPatternRow40 + 9 ][ StartPatternCol40 + 5 ] = CAVE_WAFM_7_FLOOR;
		uchar& someFuryWafm = Map[ StartPatternRow40 + 10 ][ StartPatternCol40 + 5 ];
		if( someFuryWafm == CAVE_WAFM_17_LAVA_RIVER_HORIZ_1 || someFuryWafm == CAVE_WAFM_18_LAVA_RIVER_HORIZ_2 ){
			someFuryWafm = CAVE_WAFM_45_LAVA_RIVER_HORIZ_PASSING;
		}
	}

	if( DungeonLevel >= 17 ){
		PlaceCavePattern(PatMap1x1_48A76C_ABYSS, 20);
		PlaceCavePattern(PatMap1x1_48A770_ABYSS, 20);
		PlaceCavePattern(PatMap1x1_48A774_ABYSS, 20);
		PlaceCavePattern(PatMap1x1_48A778_ABYSS, 20);


		PlaceCavePattern(PatMap3x3_48A808_ABYSS, 10);
		PlaceCavePattern(PatMap3x3_48A820_ABYSS, 15);
		PlaceCavePattern(PatMap3x3_48A838_ABYSS, 20);
		PlaceCavePattern(PatMap3x3_48A850_ABYSS, 25);
		PlaceCavePattern(PatMap3x3_48A868_ABYSS, 30);
		PlaceCavePattern(PatMap3x3_48A880_ABYSS, 35);
		PlaceCavePattern(PatMap3x3_48A898_ABYSS, 40);
		PlaceCavePattern(PatMap3x3_48A8B0_ABYSS, 45);
		PlaceCavePattern(PatMap3x3_48A8C8_ABYSS, 50);
		PlaceCavePattern(PatMap3x3_48A8E0_ABYSS, 55);
		// почему то зеркально расположены
		PlaceCavePattern(PatMap3x3_48A8E0_ABYSS, 10);
		PlaceCavePattern(PatMap3x3_48A8C8_ABYSS, 15);
		PlaceCavePattern(PatMap3x3_48A8B0_ABYSS, 20);
		PlaceCavePattern(PatMap3x3_48A898_ABYSS, 25);
		PlaceCavePattern(PatMap3x3_48A880_ABYSS, 30);
		PlaceCavePattern(PatMap3x3_48A868_ABYSS, 35);
		PlaceCavePattern(PatMap3x3_48A850_ABYSS, 40);
		PlaceCavePattern(PatMap3x3_48A838_ABYSS, 45);
		PlaceCavePattern(PatMap3x3_48A820_ABYSS, 50);
		PlaceCavePattern(PatMap3x3_48A808_ABYSS, 55);

		PlaceCavePattern(PatMap3x3_48A790_ABYSS, 40);
		PlaceCavePattern(PatMap3x3_48A7A8_ABYSS, 45);
		PlaceCavePattern(PatMap1x1_48A77C_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A780_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A784_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A788_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7BC_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7C0_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7C4_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7C8_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7CC_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7D4_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7D8_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7DC_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7E0_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7E4_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7EC_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7F0_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7F4_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7F8_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7D0_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7E8_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A7FC_ABYSS, 25);
		PlaceCavePattern(PatMap1x1_48A800_ABYSS, 25);
	}else{
		CreateRooms(5, 10, CAVE_WAFM_7_FLOOR, 0, 0);
		MakeSomeCaveWoodenWallsCrossWallsAndDoors();
		PlaceCavePattern(PatMap4x4_48A478_STALAGMIT_1, 10);
		PlaceCavePattern(PatMap4x4_48A4A0_STALAGNAT_1, 10);
		PlaceCavePattern(PatMap4x4_48A4C8_STALAGNAT_2, 10);
		PlaceCavePattern(PatMap5x4_48A4F0_STALAGNAT_3, 20);
		PlaceCavePattern(PatMap4x5_48A520_STALAGNAT_4, 20);
		PlaceCavePattern(PatMap3x3_48A550_STALAGMIT_2, 20);
		PlaceCavePattern(PatMap3x3_48A568_STALAGMIT_3, 20);
		PlaceCavePattern(PatMap3x3_48A580_STALAGMIT_4, 20);
		PlaceCavePattern(PatMap3x3_48A598_STALAGMIT_5, 30);
		PlaceCavePattern(PatMap2x1_48A5B0_STALAGNAT_ON_WALL_1, 20);
		PlaceCavePattern(PatMap1x2_48A5B8_STALAGNAT_ON_WALL_2, 20);
		PlaceCavePattern(PatMap2x1_48A5C0_CRACK_IN_WALL_1, 30);
		PlaceCavePattern(PatMap2x1_48A5C8_CRACK_IN_WALL_2, 30);
		PlaceCavePattern(PatMap1x2_48A5D0_CRACK_IN_WALL_3, 30);
		PlaceCavePattern(PatMap2x1_48A5D8_CRACK_IN_WALL_4, 30);
		PlaceCavePattern(PatMap1x2_48A5E0_CRACK_IN_WALL_5, 30);
		PlaceCavePattern(PatMap1x2_48A5E8_CRACK_IN_WALL_6, 30);
		PlaceCavePattern(PatMap2x1_48A5F0_CRACK_IN_WALL_7, 30);
		PlaceCavePattern(PatMap1x2_48A5F8_CRACK_IN_WALL_8, 30);
		PlaceCavePattern(PatMap2x1_48A600_CRACK_IN_WALL_9, 30);
		PlaceCavePattern(PatMap2x1_48A608_CRACK_IN_WALL_10, 30);
		PlaceCavePattern(PatMap1x2_48A610_CRACK_IN_WALL_11, 30);
		PlaceCavePattern(PatMap1x1_48A664_FLOOR_VARIATION_1, 25);
		PlaceCavePattern(PatMap1x1_48A668_FLOOR_VARIATION_2, 25);
		PlaceCavePattern(PatMap1x1_48A66C_FLOOR_VARIATION_3, 25);
		PlaceCavePattern(PatMap1x1_48A670_SWALL_UNM_MIDDLE_VARIATION, 25);
		PlaceCavePattern(PatMap1x1_48A674_SWALL_M_MIDLE_VARIATION, 25);
	}

	for( int i = 0; i < 40*40; i++ ){
		AltMap[ 0 ][ i ] = Map[ 0 ][ i ];
	}

	ClearObjectMaps();
	AddDungeonQuestPatternToWallMap(StartPatternRow40, StartPatternCol40);
}

//----- (00412D4D) --------------------------------------------------------
void InitCaveMaps()
{
	memset( Map, 0, sizeof Map );
	memset( FixedMap, 0, sizeof FixedMap );
}

//----- (00412D83) --------------------------------------------------------
bool __fastcall MakeSerratedCaveBinaryPatternRoom( int startRow, int startCol, int endRow, int endCol )
{
	if( startRow <= 1 || endRow >= 34 || startCol <= 1 || endCol >= 38 ){// странная верхняя граница
		return false;
	}
	for( int col = startCol; col <= endCol; col++ ){
		for( int row = startRow; row <= endRow; row++ ){
			if( Map[ row ][ col ] ){
				return false;
			}
		}
	}
	for( int col = startCol + 1; col < endCol; col++ ){
		for( int row = startRow + 1; row < endRow; row++ ){
			Map[ row ][ col ]	= 1;
		}
	}
	for( int col = startCol; col <= endCol; col++ ){
		if( RangeRND(0, 2) ){
			Map[ startRow ][ col ] = 1;
		}
		if( RangeRND(0, 2) ){
			Map[ endRow ][ col ] = 1;
		}
	}

	for( int row = startRow; row <= endRow; row++ ){
		if( RangeRND(0, 2) ){
			Map[ row ][ startCol ] = 1;
		}
		if( RangeRND(0, 2) ){
			Map[ row ][ endCol ] = 1;
		}
	}
	return true;
}

//----- (00412EBE) --------------------------------------------------------
void __fastcall RecursiveCaveRoomsGeneration(int startRow, int startCol, int somePrevRoomSize, int maybeOrientation)
{
	// не понимаю как это работает, но оно работает
	int startRowForRoom = somePrevRoomSize;
	int startColForRoom = somePrevRoomSize;
	int currentCol = startCol;
	int currentRow = startRow;
	int endColForRoom = 0;
	int endRowForRoom = 0;
	while( 1 ){
		int roomRowSize = RangeRND(0, 2) + 3;
		int roomColSize = RangeRND(0, 2) + 3;
		switch (maybeOrientation ){
		case 0:
			endColForRoom = currentCol - 1;
			startColForRoom = currentCol - 1 - roomColSize;

			if( roomRowSize < somePrevRoomSize ){
				startRowForRoom = currentRow + RangeRND(0, roomRowSize);
			}else if( roomRowSize == somePrevRoomSize ){
				startRowForRoom = currentRow;
			}else if( roomRowSize > somePrevRoomSize ){
				startRowForRoom = currentRow - RangeRND(0, roomRowSize);
			}

			endRowForRoom = startRowForRoom + roomRowSize;
			break;
		case 1:
			startRowForRoom = currentRow + 1;
			endRowForRoom = currentRow + 1 + roomRowSize;

			if( roomColSize < somePrevRoomSize ){
				startColForRoom = currentCol + RangeRND(0, roomColSize);
			}else if( roomColSize == somePrevRoomSize ){
				startColForRoom = currentCol;
			}else if( roomColSize > somePrevRoomSize ){
				startColForRoom = currentCol - RangeRND(0, roomColSize);
			}

			endColForRoom = startColForRoom + roomColSize;
			break;
		case 2:
			startColForRoom = currentCol + 1;
			endColForRoom = currentCol + 1 + roomColSize;

			if( roomRowSize < somePrevRoomSize ){
				startRowForRoom = currentRow + RangeRND(0, roomRowSize);
			}else if( roomRowSize == somePrevRoomSize ){
				startRowForRoom = currentRow;
			}else if( roomRowSize > somePrevRoomSize ){
				startRowForRoom = currentRow - RangeRND(0, roomRowSize);
			}

			endRowForRoom = startRowForRoom + roomRowSize;
			break;
		case 3:
			endRowForRoom = currentRow - 1;
			startRowForRoom = currentRow - 1 - roomRowSize;

			if( roomColSize < somePrevRoomSize ){
				startColForRoom = currentCol + RangeRND(0, roomColSize);
			}else if( roomColSize == somePrevRoomSize ){
				startColForRoom = currentCol;
			}else if( roomColSize > somePrevRoomSize ){
				startColForRoom = currentCol - RangeRND(0, roomColSize);
			}

			endColForRoom = startColForRoom + roomColSize;
			break;
		}

		if( MakeSerratedCaveBinaryPatternRoom(startRowForRoom, startColForRoom, endRowForRoom, endColForRoom) != 1 ){
			break;
		}
		if( !RangeRND(0, 4) ){
			break;
		}
		if( maybeOrientation != 2 ){
			RecursiveCaveRoomsGeneration(startRowForRoom, startColForRoom, roomColSize, 0);
		}
		if( maybeOrientation != 3 ){
			RecursiveCaveRoomsGeneration(endRowForRoom, startColForRoom, roomRowSize, 1);
		}
		if( maybeOrientation ){
			RecursiveCaveRoomsGeneration(startRowForRoom, endColForRoom, roomColSize, 2);
		}
		if( maybeOrientation == 1 ){
			break;
		}
		maybeOrientation = 3;
		somePrevRoomSize = roomRowSize;
		currentCol = startColForRoom;
		currentRow = startRowForRoom;
	}
}

//----- (004130A9) --------------------------------------------------------
void __fastcall CaveMakeRectRoomInBinPattern(int startRow, int startCol, int endRow, int endCol)
{
	for( int col = startCol; col <= endCol; col++ ){
		for( int row = startRow; row <= endRow; row++ ){
			Map[ row ][ col ] = 1;
		}
	}
}

//----- (004130DD) --------------------------------------------------------
void SomeCaveBinPatternConvert_MaybeLavaRiverConvert()
{
	// если встречается следующий паттерн:
	// 1 0
	// 0 1
	// либо
	// 0 1
	// 1 0
	// то на месте одного из 0й ставится 1. 
	// Возможно сделано чтобы тайлы лавы соединялись строго под острыми углами, не по диагоналям
	
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			uchar& curWafm =			Map[ row + 0 ][ col + 0 ];
			uchar& nextRowWafm =		Map[ row + 1 ][ col + 0 ];
			uchar& nextColWafm =		Map[ row + 0 ][ col + 1 ];
			uchar& nextRowColWafm =		Map[ row + 1 ][ col + 1 ];
			int rectBinPatternMask = BIT(1) * nextRowColWafm + BIT(2) * nextColWafm + BIT(3) * nextRowWafm + BIT(4) * curWafm;

			if( rectBinPatternMask == (BIT(2)|BIT(3)) ){
				if( RangeRND(0, 2) ){
					nextRowColWafm = 1;
				}else{
					curWafm = 1;
				}
			}else if( rectBinPatternMask == (BIT(1)|BIT(4)) ){
				if( RangeRND(0, 2) ){
					nextColWafm = 1;
				}else{
					nextRowWafm = 1;
				}
			}
		}
	}
}

//----- (0041314E) --------------------------------------------------------
void CaveBinLavaLakeConvert()
{
	// если встречается следующий паттерн:
	// 1 1 1
	// 1 0 1
	// 1 1 1
	// то на месте 0ля ставится 1. 

	for( int col = 1; col < 39; col++ ){
		for( int row = 1; row < 39; row++ ){
			uchar& curWafm = Map[ row + 0 ][ col + 0 ];
			if( curWafm == 1 ){
				continue;
			}
			if( Map[ row - 1 ][ col - 1 ] == 0 ||
				Map[ row + 0 ][ col - 1 ] == 0 ||
				Map[ row + 1 ][ col - 1 ] == 0 ){
					continue;
			}
			if( Map[ row - 1 ][ col - 0 ] == 0 ||
				Map[ row + 1 ][ col - 0 ] == 0 ){
					continue;
			}
			if( Map[ row - 1 ][ col + 1 ] == 0 ||
				Map[ row + 0 ][ col + 1 ] == 0 ||
				Map[ row + 1 ][ col + 1 ] == 0 ){
					continue;
			}
			// если все окружающие тайлы - лава, а наш не лава, то конвертируем его в лавовый
			curWafm = 1;
		}
	}
}

//----- (004131AC) --------------------------------------------------------
void MakeSomeLavaBridgeInCaveBinPattern()
{
	// в последовательностях тайлов лавы делает случайные проходы

	int startRow = 0;
	for( int col = 1; col < 39; col++ ){
		int lavaTileSequenceCount = 0;
		for( int curRow = 0; curRow < 37; curRow++ ){
			if( Map[ curRow + 0 ][ col + 0 ] == 1 ||
				Map[ curRow + 0 ][ col + 1 ] == 0 ){
					if( lavaTileSequenceCount > 3 && RangeRND(0, 2) ){
						for( int row = startRow; row < curRow; row++ ){
							Map[ row ][ col ] = RangeRND(0, 2);
						}
					}
					lavaTileSequenceCount = 0;
			}else{
				if( !lavaTileSequenceCount ){
					startRow = curRow;
				}
				lavaTileSequenceCount++;
			}

		}
	}

	startRow = 0;
	for( int col = 0; col < 39; col++ ){
		int lavaTileSequenceCount = 0;
		for( int curRow = 0; curRow < 37; curRow++ ){
			if( Map[ curRow + 0 ][ col + 0 ] == 0 ||
				Map[ curRow + 0 ][ col + 1 ] == 1 ){
					if( lavaTileSequenceCount > 3 && RangeRND(0, 2) ){
						for( int row = startRow; row < curRow; row++ ){
							Map[ row ][ col + 1 ] = RangeRND(0, 2);
						}
					}
					lavaTileSequenceCount = 0;
			}else{
				if( !lavaTileSequenceCount ){
					startRow = curRow;
				}
				lavaTileSequenceCount++;
			}
		}
	}

	int startCol = 0;
	for( int row = 0; row < 39; row++ ){
		int lavaTileSequenceCount = 0;
		for( int curCol = 0; curCol < 37; curCol++ ){
			if( Map[ row + 0 ][ curCol ] == 1 ||
				Map[ row + 1 ][ curCol ] == 0 ){
					if( lavaTileSequenceCount > 3 && RangeRND(0, 2) ){
						for( int col = startCol; col < curCol; col++ ){
							Map[ row ][ col ] = RangeRND(0, 2);
						}
					}
					lavaTileSequenceCount = 0;
			}else{
				if( !lavaTileSequenceCount ){
					startCol = curCol;
				}
				lavaTileSequenceCount++;
			}

		}
	}

	startCol = 0;
	for( int row = 0; row < 39; row++ ){
		int lavaTileSequenceCount = 0;
		for( int curCol = 0; curCol < 37; curCol++ ){
			if( Map[ row + 0 ][ curCol + 0 ]  == 0 ||
				Map[ row + 1 ][ curCol + 0 ] == 1 ){
					if( lavaTileSequenceCount > 3 && RangeRND(0, 2) ){
						for( int col = startCol; col < curCol; col++ ){
							Map[ row + 1 ][ col ] = RangeRND(0, 2);
						}
					}
					lavaTileSequenceCount = 0;
			}else{
				if( !lavaTileSequenceCount ){
					startCol = curCol;
				}
				lavaTileSequenceCount++;
			}
		}
	}
}

//----- (004133B3) --------------------------------------------------------
void SetToZeroLastLinesInCaveBinPattern()
{
	for( int row = 0; row < 40; row++ ){
		Map[ row ][ 39 ] = 0;
	}
	for( int col = 0; col < 40; col++ ){
		Map[ 39 ][ col ] = 0;
	}
}

//----- (004133D4) --------------------------------------------------------
int AreaOfLevelRoomsCave()
{
	int floorCellCount = 0;
	for( int i = 0; i < 40*40; i++ ){
		if( Map[ 0 ][ i ] == 1 ){
			floorCellCount++;
		}
	}
	return floorCellCount;
}

//----- (004133F7) --------------------------------------------------------
void InitCaveWallAndFloorMapFromBynaryPattern()
{
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			uchar& curWafm =			Map[ row + 0 ][ col + 0 ];
			uchar nextRowWafm =		Map[ row + 1 ][ col + 0 ];
			uchar nextColWafm =		Map[ row + 0 ][ col + 1 ];
			uchar nextRowColWafm =		Map[ row + 1 ][ col + 1 ];
			int rectBinPatternMask = BIT(1) * nextRowColWafm + BIT(2) * nextColWafm + BIT(3) * nextRowWafm + BIT(4) * curWafm;

			if( rectBinPatternMask == (BIT(2)|BIT(3)) ){
				if( RangeRND(0, 2) ){
					rectBinPatternMask = 5;
				}else{
					rectBinPatternMask = 12;
				}
			}
			if( rectBinPatternMask == (BIT(1)|BIT(4)) ){
				if( RangeRND(0, 2) ){
					rectBinPatternMask = 14;
				}else{
					rectBinPatternMask = 13;
				}
			}

			curWafm = CaveOrientedWallsAndCorner[rectBinPatternMask];
		}
	}

	for( int col = 0; col < 40; col++ ){
		Map[ 39 ][ col ] = 8;
	}

	for( int row = 0; row < 40; row++ ){
		Map[ row ][ 39 ] = 8;
	}
}

//int lavaRiverRows[ 100 ];
//int lavaRiverCols[ 100 ];
//int lavaRiverTiles[ 100 ];
//int tryesCount;
//int countOfLavaRivers;
//int passingFoundTryesCount;
//int isLavaRiverValid;
//int orientationChangesCount;
//int	banedLavaRiverOrientation;

//----- (00413485) --------------------------------------------------------
void CaveMakeLavaRivers()
{
	enum LAVA_ORIENT{
		LO_0_COL_MINUS = 0,
		LO_1_COL_PLUS = 1,
		LO_2_ROW_PLUS = 2,
		LO_3_ROW_MINUS = 3,
	};
	//VarTable& v = var_table();
	//memcpy( &lavaRiverRows, (void*) v[ var_index( &lavaRiverRows, 2 ) ].adrNew, sizeof lavaRiverRows );
	//memcpy( &lavaRiverCols, (void*) v[ var_index( &lavaRiverCols, 2 ) ].adrNew, sizeof lavaRiverCols );
	//memcpy( &lavaRiverTiles, (void*) v[ var_index( &lavaRiverTiles, 2 ) ].adrNew, sizeof lavaRiverTiles );
	//memcpy( &tryesCount, (void*) v[ var_index( &tryesCount, 2 ) ].adrNew, sizeof tryesCount );
	//memcpy( &countOfLavaRivers, (void*) v[ var_index( &countOfLavaRivers, 2 ) ].adrNew, sizeof countOfLavaRivers );
	//memcpy( &passingFoundTryesCount, (void*) v[ var_index( &passingFoundTryesCount, 2 ) ].adrNew, sizeof passingFoundTryesCount );
	//memcpy( &isLavaRiverValid, (void*) v[ var_index( &isLavaRiverValid, 2 ) ].adrNew, sizeof isLavaRiverValid );
	//memcpy( &orientationChangesCount, (void*) v[ var_index( &orientationChangesCount, 2 ) ].adrNew, sizeof orientationChangesCount );
	//memcpy( &banedLavaRiverOrientation, (void*) v[ var_index( &banedLavaRiverOrientation, 2 ) ].adrNew, sizeof banedLavaRiverOrientation );
	int lavaRiverRows[100];
	int lavaRiverCols[100];
	int lavaRiverTiles[100];

	int tryesCount = 0;
	for( int countOfLavaRivers = 0; countOfLavaRivers < 4 && tryesCount < 200; ){

		int isLavaRiverValid = 0;
		int lavaRiverSize = 0;
		do{
			if( tryesCount >= 200 ){
				break;
			}
			++tryesCount;

			// ищем крайние неугловые тайлы лавовых озер
			int row = 0;
			int col = 0;
			int lavaLakeFoundTryesCount = 0;
			while( 1 ){
				uchar map = Map[row][col];
				if( map >= CAVE_WAFM_25_LAVA && map <= CAVE_WAFM_28_LAVA ){
					break;
				}
				if( lavaLakeFoundTryesCount >= 100 ){
					return;
				}
				row = RangeRND(0, 40);
				col = RangeRND(0, 40);
				++lavaLakeFoundTryesCount;
				while( 1 ){
					uchar mapValue = Map[row][col];
					if( mapValue >= CAVE_WAFM_25_LAVA && mapValue <= CAVE_WAFM_28_LAVA ){
						break;
					}
					if( col >= 40 ){
						break;
					}
					if( ++row >= 40 ){
						row = 0;
						++col;
					}
				}
			}
			if( lavaLakeFoundTryesCount >= 100 ){
				return;
			}

			// в зависимости от найденного тайла лавы выбираем главное направление распространения лавовой реки
			// и запрещаем ей двигаться в противоположном направлении.
			// она может также изгибаться перпендикулятно основному направлению
			int curLavaRiverOrientation;
			int banedLavaRiverOrientation;

			switch ( Map[row][col] ){
			case CAVE_WAFM_25_LAVA:
				curLavaRiverOrientation = LO_3_ROW_MINUS;
				banedLavaRiverOrientation = LO_2_ROW_PLUS;
				lavaRiverTiles[0] = CAVE_WAFM_40_LAVA;
				break;
			case CAVE_WAFM_26_LAVA:
				curLavaRiverOrientation = LO_0_COL_MINUS;
				banedLavaRiverOrientation = LO_1_COL_PLUS;
				lavaRiverTiles[0] = CAVE_WAFM_38_LAVA;
				break;
			case CAVE_WAFM_27_LAVA:
				banedLavaRiverOrientation = LO_0_COL_MINUS;
				curLavaRiverOrientation = LO_1_COL_PLUS;
				lavaRiverTiles[0] = CAVE_WAFM_41_LAVA;
				break;
			case CAVE_WAFM_28_LAVA:
				curLavaRiverOrientation = LO_2_ROW_PLUS;
				banedLavaRiverOrientation = LO_3_ROW_MINUS;
				lavaRiverTiles[0] = CAVE_WAFM_39_LAVA;
				break;
			}
			lavaRiverRows[0] = row;
			lavaRiverCols[0] = col;
			lavaRiverSize = 1;
			int secondaryBannedLavaRiverOrientation = 4;// запрещаем двигаться в сторону противоположную последнему шагу
			int lastLavaRiverOrientation = 4;
			// цикл завершается либо, если река уже слишком длинная, либо если зашли в тупик
			for( int orientationChangesCount = 0; orientationChangesCount < 4 && lavaRiverSize < 100; ){
				
				// выбираем новое направление (первый цикл либо нашли пол) либо следующее направление
				if( orientationChangesCount ){
					curLavaRiverOrientation = (curLavaRiverOrientation + 1) & 3;
				}else{
					curLavaRiverOrientation = RangeRND(0, 4);
				}
				//if( CurVP == 50969 ) __debugbreak();
				// пропускаем два запретных направления. Цикл завершается максимум за 2 оборота.
				while( 1 ){
					++orientationChangesCount;
					if( curLavaRiverOrientation != banedLavaRiverOrientation && curLavaRiverOrientation != secondaryBannedLavaRiverOrientation ){
						break;
					}
					curLavaRiverOrientation = (curLavaRiverOrientation + 1) & 3;
				}

				int oldRow = row;
				int oldCol = col;

				// смещаемся в соответствии с выбранным направлением
				if( curLavaRiverOrientation == LO_0_COL_MINUS && col > 0 ){
					--col;
				}
				if( curLavaRiverOrientation == LO_1_COL_PLUS && col < 40 ){
					++col;
				}
				if( curLavaRiverOrientation == LO_2_ROW_PLUS && row < 40 ){
					++row;
				}
				if( curLavaRiverOrientation == LO_3_ROW_MINUS && row > 0 ){
					--row;
				}

				// река может распространяться только по полу
				if( Map[row][col] == CAVE_WAFM_7_FLOOR ){
					orientationChangesCount = 0;
					lavaRiverSize++;
					// вначале предполагаем, что река идет прямо и ставим случайный тайл прямой реки для данного расположения
					if( curLavaRiverOrientation == LO_0_COL_MINUS || curLavaRiverOrientation == LO_1_COL_PLUS ){
						lavaRiverTiles[lavaRiverSize - 1] = (!RangeRND(0, 2)) ? CAVE_WAFM_17_LAVA_RIVER_HORIZ_1 : CAVE_WAFM_18_LAVA_RIVER_HORIZ_2;
					}
					if( curLavaRiverOrientation == LO_2_ROW_PLUS || curLavaRiverOrientation == LO_3_ROW_MINUS ){
						lavaRiverTiles[lavaRiverSize - 1] = (!RangeRND(0, 2)) ? CAVE_WAFM_15_LAVA_RIVER_VERT_1 : CAVE_WAFM_16_LAVA_RIVER_VERT_2;
					}
					lavaRiverRows[lavaRiverSize - 1] = row;
					lavaRiverCols[lavaRiverSize - 1] = col;
					
					// деоптимизировал для большей понятности

					// проверяем на углы
					if( lavaRiverSize > 2 ){
						if( curLavaRiverOrientation == LO_0_COL_MINUS && lastLavaRiverOrientation == LO_2_ROW_PLUS 
							|| curLavaRiverOrientation == LO_3_ROW_MINUS && lastLavaRiverOrientation == LO_1_COL_PLUS ){
								lavaRiverTiles[lavaRiverSize - 2] = CAVE_WAFM_22_LAVA_RIVER_CORNER;
						}else if( curLavaRiverOrientation == LO_0_COL_MINUS && lastLavaRiverOrientation == LO_3_ROW_MINUS 
							|| curLavaRiverOrientation == LO_2_ROW_PLUS && lastLavaRiverOrientation == LO_1_COL_PLUS ){
								lavaRiverTiles[lavaRiverSize - 2] = CAVE_WAFM_21_LAVA_RIVER_CORNER;
						}else if( curLavaRiverOrientation == LO_1_COL_PLUS && lastLavaRiverOrientation == LO_2_ROW_PLUS 
							|| curLavaRiverOrientation == LO_3_ROW_MINUS && lastLavaRiverOrientation == LO_0_COL_MINUS ){
								lavaRiverTiles[lavaRiverSize - 2] = CAVE_WAFM_20_LAVA_RIVER_CORNER;
						}else if( curLavaRiverOrientation == LO_1_COL_PLUS && lastLavaRiverOrientation == LO_3_ROW_MINUS
							|| curLavaRiverOrientation == LO_2_ROW_PLUS && lastLavaRiverOrientation == LO_0_COL_MINUS ){
								lavaRiverTiles[lavaRiverSize - 2] = CAVE_WAFM_19_LAVA_RIVER_CORNER;
						}
					}
					// запрещаем двигаться обратно
					switch (curLavaRiverOrientation ){
						case LO_0_COL_MINUS:	secondaryBannedLavaRiverOrientation = LO_1_COL_PLUS;	break;
						case LO_1_COL_PLUS:		secondaryBannedLavaRiverOrientation = LO_0_COL_MINUS;	break;
						case LO_2_ROW_PLUS:		secondaryBannedLavaRiverOrientation = LO_3_ROW_MINUS;	break;
						case LO_3_ROW_MINUS:	secondaryBannedLavaRiverOrientation = LO_2_ROW_PLUS;	break;
					}
					lastLavaRiverOrientation = curLavaRiverOrientation;
				}else{
					row = oldRow;
					col = oldCol;
				}


			}

			// устанавливаем спецокончание реки - лава текущая из стены, если река оканчивается в навправлении стены за которой бейонд
			// если же река не уперлась в стену, значит отменяем её
			switch (curLavaRiverOrientation ){
				case LO_0_COL_MINUS:
					if( Map[row][col - 1] == CAVE_WAFM_10_SWALL_M_MIDLE && Map[row][col - 2] == CAVE_WAFM_8_BEYOND ){
						lavaRiverRows[lavaRiverSize] = row;
						lavaRiverCols[lavaRiverSize] = col - 1;
						lavaRiverTiles[lavaRiverSize] = CAVE_WAFM_24_LAVA_FROM_WALL;
						if( lastLavaRiverOrientation == LO_2_ROW_PLUS ){
							lavaRiverTiles[lavaRiverSize-1] = CAVE_WAFM_22_LAVA_RIVER_CORNER;
						}else if( lastLavaRiverOrientation == LO_3_ROW_MINUS ){
							lavaRiverTiles[lavaRiverSize-1] = CAVE_WAFM_21_LAVA_RIVER_CORNER;
						}
						isLavaRiverValid = 1;
					}
					break;
				case LO_1_COL_PLUS:
					if( Map[row][col + 1] == CAVE_WAFM_2_WALL_IN_LD && Map[row][col + 2] == CAVE_WAFM_8_BEYOND ){
						lavaRiverRows[lavaRiverSize] = row;
						lavaRiverCols[lavaRiverSize] = col + 1;
						lavaRiverTiles[lavaRiverSize] = CAVE_WAFM_42_LAVA_FROM_WALL;
						if( lastLavaRiverOrientation == LO_2_ROW_PLUS ){
							lavaRiverTiles[lavaRiverSize-1] = CAVE_WAFM_20_LAVA_RIVER_CORNER;
						}
						if( lastLavaRiverOrientation == LO_3_ROW_MINUS ){
							lavaRiverTiles[lavaRiverSize-1] = CAVE_WAFM_19_LAVA_RIVER_CORNER;
						}
						isLavaRiverValid = 1;
					}
					break;
				case LO_2_ROW_PLUS:
					if( Map[row+1][col] == CAVE_WAFM_4_WALL_IN_RD && Map[row+2][col] == CAVE_WAFM_8_BEYOND ){
						lavaRiverRows[lavaRiverSize] = row + 1;
						lavaRiverCols[lavaRiverSize] = col;
						lavaRiverTiles[lavaRiverSize] = CAVE_WAFM_43_LAVA_FROM_WALL;
						if( lastLavaRiverOrientation == LO_0_COL_MINUS ){
							lavaRiverTiles[lavaRiverSize-1] = CAVE_WAFM_19_LAVA_RIVER_CORNER;
						}else if( lastLavaRiverOrientation == LO_1_COL_PLUS ){
							lavaRiverTiles[lavaRiverSize-1] = CAVE_WAFM_21_LAVA_RIVER_CORNER;
						}
						isLavaRiverValid = 1;
					}
					break;
				case LO_3_ROW_MINUS:
					if( Map[row-1][col] == CAVE_WAFM_9_SWALL_UNM_MIDDLE && Map[row - 2][col] == CAVE_WAFM_8_BEYOND ){
						lavaRiverRows[lavaRiverSize] = row - 1;
						lavaRiverCols[lavaRiverSize] = col;
						lavaRiverTiles[lavaRiverSize] = CAVE_WAFM_23_LAVA_FROM_WALL;
						if( lastLavaRiverOrientation == LO_0_COL_MINUS ){
							lavaRiverTiles[lavaRiverSize-1] = CAVE_WAFM_20_LAVA_RIVER_CORNER;
						}else if( lastLavaRiverOrientation == LO_1_COL_PLUS ){
							lavaRiverTiles[lavaRiverSize-1] = CAVE_WAFM_22_LAVA_RIVER_CORNER;
						}
						isLavaRiverValid = 1;
					}
					break;
			}

		}while( !isLavaRiverValid );

		int passingIndex;
		if( isLavaRiverValid == 1 ){
			// короткая река, не подходит
			if( lavaRiverSize < 7 ){
				isLavaRiverValid = 0;
			}
			if( isLavaRiverValid == 1 ){
				// выбираем где расположить брод через реку
				isLavaRiverValid = 0;
				int passingFoundTryesCount = 0;
				do{
					if( passingFoundTryesCount >= 30 ){
						break;
					}
					++passingFoundTryesCount;
					passingIndex = RangeRND(0, lavaRiverSize);
					int riverTile = lavaRiverTiles[passingIndex];
					if( riverTile == CAVE_WAFM_15_LAVA_RIVER_VERT_1 || riverTile == CAVE_WAFM_16_LAVA_RIVER_VERT_2 ){
						int row = lavaRiverRows[passingIndex];
						int col = lavaRiverCols[passingIndex];
						if( Map[row][col - 1] == CAVE_WAFM_7_FLOOR && Map[row][col + 1] == CAVE_WAFM_7_FLOOR ){
								isLavaRiverValid = 1;
						}
					}
					if( riverTile == CAVE_WAFM_17_LAVA_RIVER_HORIZ_1 || riverTile == CAVE_WAFM_18_LAVA_RIVER_HORIZ_2 ){
						int row = lavaRiverRows[passingIndex];
						int col = lavaRiverCols[passingIndex];
						if( Map[row - 1][col] == CAVE_WAFM_7_FLOOR && Map[row + 1][col] == CAVE_WAFM_7_FLOOR ){
							isLavaRiverValid = 2;
						}
					}
					// странная проверка брода
					for( int curRiverTileIndex = 0; curRiverTileIndex < lavaRiverSize && isLavaRiverValid; curRiverTileIndex++ ){
						int row = lavaRiverRows[curRiverTileIndex];
						int col = lavaRiverCols[curRiverTileIndex];
						if( isLavaRiverValid == 1 ){
							int passingCol = lavaRiverCols[passingIndex];
							if( passingCol - 1 == col || passingCol + 1 == col ){
								if( lavaRiverRows[passingIndex] == row ){
									isLavaRiverValid = 0;
								}
							}
						}
						if( isLavaRiverValid == 2 ){
							int passingRow = lavaRiverRows[passingIndex];
							if( passingRow - 1 == row || passingRow + 1 == row ){
								if( lavaRiverCols[passingIndex] == col )
									isLavaRiverValid = 0;
							}
						}
					}
				}while( !isLavaRiverValid );

				// после всех проверок можно наконец построить реку
				if( isLavaRiverValid ){
					lavaRiverTiles[ passingIndex ] = isLavaRiverValid == 1 ? CAVE_WAFM_44_LAVA_RIVER_VERT_PASSING : CAVE_WAFM_45_LAVA_RIVER_HORIZ_PASSING;
					++countOfLavaRivers;
					for( int curRiverTileIndex = 0; curRiverTileIndex <= lavaRiverSize; curRiverTileIndex++ ){
						int row = lavaRiverRows[ curRiverTileIndex ];
						int col = lavaRiverCols[ curRiverTileIndex ];
						//if( countOfLavaRivers == 2 ) __debugbreak();
						Map[ row ][ col ] = lavaRiverTiles[ curRiverTileIndex ];
					}
				}
			}
		}
	}
}

//----- (00413AB9) --------------------------------------------------------
void CaveMakeSomeLavaLakes()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){

			uchar& wafm = Map[ row ][ col ];
			uchar*v16 = &Map[ row ][ col ];

			if( wafm != CAVE_WAFM_8_BEYOND ){
				continue;
			}
			wafm |= BIT(8);
			int someRadius = 1;

			int isOutOfMap;

			if( row + 1 >= 40 ){
				isOutOfMap = 1;
			}else{
				isOutOfMap = IsCaveTileLinkedWithOutOfMap(row + 1, col, &someRadius);
			}
			if( row - 1 <= 0 || isOutOfMap ){
				isOutOfMap = 1;
			}else{
				isOutOfMap = IsCaveTileLinkedWithOutOfMap(row - 1, col, &someRadius);
			}
			if( col + 1 >= 40 || isOutOfMap ){
				isOutOfMap = 1;
			}else{
				isOutOfMap = IsCaveTileLinkedWithOutOfMap(row, col + 1, &someRadius);
			}
			if( col - 1 <= 0 || isOutOfMap ){
				isOutOfMap = 1;
			}else{
				isOutOfMap = IsCaveTileLinkedWithOutOfMap(row, col - 1, &someRadius);
			}
			int randomFactor = RangeRND(0, 100);

			for( int curCol = col - someRadius; curCol < (col + someRadius); curCol++ ){
				for( int curRow = row - someRadius; curRow < (row + someRadius); curRow++ ){
					uchar& curWafm = Map[ curRow ][ curCol ];
					// при достижении Map значений больше 128 бит 8 становится 1
					if( !(curWafm & BIT(8)) || curCol < 0 || curCol >= 40 || curRow < 0 || curRow >= 40 ){
						continue;
					}
					curWafm &= ~BIT(8);
					if( someRadius > 4 && randomFactor < 25 && !isOutOfMap ){
						int newTileNumber = CaveLavaMakingArray[curWafm];
						if( newTileNumber && newTileNumber <= CAVE_WAFM_37_LAVA ){
							curWafm = newTileNumber;
						}
						MaybeHasLavaTiles = 1;
					}
				}
			}
		}
	}
}

//----- (00413C12) --------------------------------------------------------
int __fastcall IsCaveTileLinkedWithOutOfMap(int row, int col, int* someRadius)
{
	#ifndef REFACKTOR
	int *someRadius_1; // ebp@1
	int col_1; // edi@1
	int row_1; // esi@1
	uchar wafm; // eax@6
	int v7; // eax@19
	//int *someRadiusa; // [sp+14h] [bp+4h]@9

	someRadius_1 = someRadius;
	col_1 = col;
	row_1 = row;
	if( *someRadius <= 40 && row >= 0 && col >= 0 && row < 40 && col < 40 ){
		wafm = Map[ row ][ col ];
		if( wafm & 0x80 ){
			return 0;
		}
		if( wafm <= 0xFu ){
			Map[ row ][ col ] = wafm | 0x80;
			++*someRadius;
			if( wafm == 8 ){
				if( IsCaveTileLinkedWithOutOfMap( row + 1, col, someRadius ) == 1
					|| IsCaveTileLinkedWithOutOfMap( row_1 - 1, col_1, someRadius ) == 1
					|| IsCaveTileLinkedWithOutOfMap( row_1, col_1 + 1, someRadius ) == 1 ){
					return 1;
				}
				v7 = IsCaveTileLinkedWithOutOfMap( row_1, col_1 - 1, someRadius );
			LABEL_24:
				if( v7 == 1 ){
					return 1;
				}
				return 0;
			}
			if( CaveLavaFlags2[ wafm ] & 8 ){
				if( IsCaveTileLinkedWithOutOfMap_2( row, col - 1, someRadius_1 ) == 1 ){
					return 1;
				}
			}
			if( CaveLavaFlags2[ wafm ] & 4 ){
				if( IsCaveTileLinkedWithOutOfMap_2( row_1, col_1 + 1, someRadius_1 ) == 1 ){
					return 1;
				}
			}
			if( !(CaveLavaFlags2[wafm] & 2) ){
				goto LABEL_18;
			}
			if( IsCaveTileLinkedWithOutOfMap_2( row_1 + 1, col_1, someRadius_1 ) != 1 ){
			LABEL_18:
				if( CaveLavaFlags2[wafm] & 1 ){
					v7 = IsCaveTileLinkedWithOutOfMap_2( row_1 - 1, col_1, someRadius_1 );
					goto LABEL_24;
				}
				return 0;
			}
			return 1;
		}
	}
	return 1;
	#else
	if( *someRadius > 40 || row < 0 || col < 0 || row >= 40 || col >= 40 ){
		return 0;
	}
	uchar wafm = Map[ row ][ col ];
	if( wafm & BIT(8) ){
		return 0;
	}
	if( wafm > 15 ){
		return 0;
	}
	Map[ row ][ col ] |= BIT(8);
	++someRadius;
	if( wafm == CAVE_WAFM_8_BEYOND ){
		if( IsCaveTileLinkedWithOutOfMap(row + 1, col, someRadius) 
		 || IsCaveTileLinkedWithOutOfMap(row - 1, col, someRadius) 
		 || IsCaveTileLinkedWithOutOfMap(row, col + 1, someRadius) 
		 || IsCaveTileLinkedWithOutOfMap(row, col - 1, someRadius) ){
			return 1;
		}else{
			return 0;
		}
	}
	uchar someBitMask = CaveLavaFlags2[wafm];
	if( someBitMask & BIT(4) && IsCaveTileLinkedWithOutOfMap_2(row, col - 1, someRadius)
	 || someBitMask & BIT(3) && IsCaveTileLinkedWithOutOfMap_2(row, col + 1, someRadius)
	 || someBitMask & BIT(2) && IsCaveTileLinkedWithOutOfMap_2(row + 1, col, someRadius)
	 || someBitMask & BIT(1) && IsCaveTileLinkedWithOutOfMap_2(row - 1, col, someRadius) ){
		return 1;
	}
	return 0;
	#endif
}

//----- (00413D41) --------------------------------------------------------
int __fastcall IsCaveTileLinkedWithOutOfMap_2(int row, int col, int* someRadius)
{
	#ifndef REFACKTOR
	int col_1; // edi@1
	int row_1; // esi@1
	unsigned __int8 wafm; // cl@6
	int wafm_1; // ebx@8
	int result; // eax@24

	col_1 = col;
	row_1 = row;
	result = 1;
	if( *someRadius <= 40 && row >= 0 && col >= 0 && row < 40 && col < 40 ){
		wafm = Map[ row ][ col ];
		if( wafm & 0x80
			|| wafm <= 0xFu
			&& ((wafm_1 = wafm, Map[ row_1 ][ col ] = wafm | 0x80, ++*someRadius, !(CaveLavaFlags[ wafm ] & 8))
				 || IsCaveTileLinkedWithOutOfMap_2( row_1, col - 1, someRadius ) != 1)
			&& (!(CaveLavaFlags[ wafm_1 ] & 4) || IsCaveTileLinkedWithOutOfMap_2( row_1, col_1 + 1, someRadius ) != 1)
			&& (!(CaveLavaFlags[ wafm_1 ] & 2) || IsCaveTileLinkedWithOutOfMap_2( row_1 + 1, col_1, someRadius ) != 1)
			&& (!(CaveLavaFlags[ wafm_1 ] & 1) || IsCaveTileLinkedWithOutOfMap_2( row_1 - 1, col_1, someRadius ) != 1)
			&& (!(CaveLavaFlags[ wafm_1 ] & 0x80) || IsCaveTileLinkedWithOutOfMap( row_1, col_1 - 1, someRadius ) != 1)
			&& (!(CaveLavaFlags[ wafm_1 ] & 0x40) || IsCaveTileLinkedWithOutOfMap( row_1, col_1 + 1, someRadius ) != 1)
			&& (!(CaveLavaFlags[ wafm_1 ] & 0x20) || IsCaveTileLinkedWithOutOfMap( row_1 + 1, col_1, someRadius ) != 1)
			&& (!(CaveLavaFlags[ wafm_1 ] & 0x10) || IsCaveTileLinkedWithOutOfMap( row_1 - 1, col_1, someRadius ) != 1) ){
			result = 0;
		}
	}
	return result;
	#else
	if( *someRadius > 40 || row < 0 || col < 0 || row >= 40 || col >= 40 ){
		return 1;
	}
	uchar wafm = Map[ row ][ col ];
	if( (wafm & BIT(8)) ){
		return 0;
	}
	if( wafm > 15 ){
		return 1;
	}
	Map[ row ][ col ] |= BIT(8);
	*someRadius;
	uchar someBitMask = CaveLavaFlags[wafm];
	if( someBitMask & BIT(4) && IsCaveTileLinkedWithOutOfMap_2(row, col - 1, someRadius)
	 || someBitMask & BIT(3) && IsCaveTileLinkedWithOutOfMap_2(row, col + 1, someRadius)
	 || someBitMask & BIT(2) && IsCaveTileLinkedWithOutOfMap_2(row + 1, col, someRadius)
	 || someBitMask & BIT(1) && IsCaveTileLinkedWithOutOfMap_2(row - 1, col, someRadius)
	 || someBitMask & BIT(8) && IsCaveTileLinkedWithOutOfMap(row, col - 1, someRadius)
	 || someBitMask & BIT(7) && IsCaveTileLinkedWithOutOfMap(row, col + 1, someRadius)
	 || someBitMask & BIT(6) && IsCaveTileLinkedWithOutOfMap(row + 1, col, someRadius)
	 || someBitMask & BIT(5) && IsCaveTileLinkedWithOutOfMap_2(row - 1, col, someRadius) ){
		return 1;
	}
	return 0;
	#endif
}

//----- (00413E8B) --------------------------------------------------------
void CaveLavaConvert_SomeBeyondIntoLava()
{
	for( int col = 1; col < 39; col++ ){// отсебятина. Заменил 0-40 на 1-39 иначе, читает за границе массива
		for( int row = 1; row < 39; row++ ){
			uchar& curRowCurCol  = Map[ row + 0 ][ col + 0 ];
			uchar prevRowNextCol = Map[ row - 1 ][ col + 1 ];
			uchar prevRowCurCol  = Map[ row - 1 ][ col + 0 ];
			uchar prevRowPrevCol = Map[ row - 1 ][ col - 1 ];
			uchar curRowNextCol  = Map[ row + 0 ][ col + 1 ];
			uchar curRowPrevCol  = Map[ row + 0 ][ col - 1 ];
			uchar nextRowNextCol = Map[ row + 1 ][ col + 1 ];
			uchar nextRowCurCol  = Map[ row + 1 ][ col + 0 ];
			uchar nextRowPrevCol = Map[ row + 1 ][ col - 1 ];
			if( curRowCurCol == CAVE_WAFM_8_BEYOND ){ // работает неверно, поскольку пропускает случаи когда 2+ тайлов бейонда стоят рядом
				if( InSegment(prevRowPrevCol, CAVE_WAFM_25_LAVA, CAVE_WAFM_41_LAVA) 
				 && InSegment(prevRowCurCol , CAVE_WAFM_25_LAVA, CAVE_WAFM_41_LAVA)
				 && InSegment(prevRowNextCol, CAVE_WAFM_25_LAVA, CAVE_WAFM_41_LAVA)
				 && InSegment(curRowPrevCol , CAVE_WAFM_25_LAVA, CAVE_WAFM_41_LAVA)
				 && InSegment(curRowNextCol , CAVE_WAFM_25_LAVA, CAVE_WAFM_41_LAVA)
				 && InSegment(nextRowPrevCol, CAVE_WAFM_25_LAVA, CAVE_WAFM_41_LAVA)
				 && InSegment(nextRowCurCol , CAVE_WAFM_25_LAVA, CAVE_WAFM_41_LAVA)
				 && InSegment(nextRowNextCol, CAVE_WAFM_25_LAVA, CAVE_WAFM_41_LAVA)	){
						curRowCurCol = CAVE_WAFM_33_LAVA;
				}
			}
		}
	}
}

//----- (00413F0E) --------------------------------------------------------
bool __fastcall PlaceCavePatMap(uchar* patternPtr, int minPatternsToPlace, int maxPatternsToPlace, int a4, int a5, int resetPlayerPosition, int a7)
{
	int patternRowSize = *(uchar*)patternPtr;
	int patternColSize = *(uchar*)(patternPtr + 1);

	char* beforePattern = ((char*)patternPtr + 2);
	char* afterPattern = beforePattern + patternRowSize * patternColSize;

	//здесь определяется сколько копий объекта понатыкать на карте
	int numberOfPatternsToPlace;
	if( maxPatternsToPlace - minPatternsToPlace ){
		numberOfPatternsToPlace = RangeRND(0, maxPatternsToPlace - minPatternsToPlace );
	}else{
		numberOfPatternsToPlace = 1;
	}

	int col;
	int row;
	int mapRowsLimit = 40 - patternRowSize;
	int mapColumnsLimit = 40 - patternColSize;
	int continueFlag;

	for( int patternsPlaced = 0; patternsPlaced < numberOfPatternsToPlace; patternsPlaced++ ){
		bool isPatternPlaced = false;
		row = RangeRND(0, mapRowsLimit);
		col = RangeRND(0, mapColumnsLimit);
		int tryesCounter = 0;

		do{
			if( ++tryesCounter >= 200 ){
				return 1;
			}

			continueFlag = 1;
			if( a4 != -1 ){
				if( row >= a4 - patternRowSize && row <= a4 + 12 ){
					row = RangeRND(0, mapRowsLimit);
					col = RangeRND(0, mapColumnsLimit);
					continueFlag = 0;
				}
			}
			if( a5 != -1 ){
				if( col >= a5 - patternColSize && col <= a5 + 12 ){
					row = RangeRND(0, mapRowsLimit);
					col = RangeRND(0, mapColumnsLimit);
					continueFlag = 0;
				}
			}

			// проверка на соответствие паттерну
			for( int colOffset = 0; colOffset < patternColSize && continueFlag; colOffset++ ){
				for( int rowOffset = 0; rowOffset < patternRowSize && continueFlag; rowOffset++ ){
					uchar neededTile = beforePattern[colOffset*patternRowSize+rowOffset];
					int mapCell = (row+rowOffset)*40 + (col+colOffset);
					if( (neededTile && (Map[ 0 ][ mapCell ] != neededTile)) || FixedMap[ 0 ][ mapCell ] ){
						continueFlag = 0; //бида бида, паттерн не соблюдается, надо искать другое место
					}
				}
			}

			if( continueFlag ){
				//матерь божья, мы нашли подходящее место для установки объекта, копируем ка его паттерн быстренько на карту
				for( int colOffset = 0; colOffset < patternColSize; colOffset++ ){
					for( int rowOffset = 0; rowOffset < patternRowSize; rowOffset++ ){
						uchar newTile = afterPattern[colOffset*patternRowSize+rowOffset];
						int mapCell = (row+rowOffset)*40 + (col+colOffset);
						if( newTile ){
							Map[ 0 ][ mapCell ] = newTile;
						}
					}
				}
				isPatternPlaced = true;
			}

			// следующая клетка
			if( !isPatternPlaced ){
				if( ++row == mapRowsLimit ){
					row = 0;
					if( ++col == mapColumnsLimit ){			
						col = 0;
					}
				}
			}

		}while( !isPatternPlaced);

	}

	if( resetPlayerPosition == 1 ){
		PlayerRowPos = 2 * row + 17;
		PlayerColPos = 2 * col + 19;
	}
	if( !a7 ){
		SomeXPos2 = 2 * row + 17;
		SomeYPos2 = 2 * col + 19;
	}
	return 0;
}

//----- (00414118) --------------------------------------------------------
void __fastcall PlaceCavePattern(uchar* patternPtr, int chanceToPlace)
{
	int patternRowSize = *patternPtr;
	int patternColSize = *(patternPtr + 1);
	int mapColumnsLimit = 40 - patternColSize;
	int mapRowsLimit = 40 - patternRowSize;
	uchar* beforePattern = patternPtr + 2;
	uchar* afterPattern = beforePattern + patternRowSize * patternColSize;
	if( mapColumnsLimit <= 0 || mapRowsLimit <= 0 ){
		return;
	}
	for( int col = 0; col < mapColumnsLimit; col++ ){
		for( int row = 0; row < mapRowsLimit; row++ ){
			bool continueFlag = 1;
			// проверка на соответствие паттерну
			for( int colOffset = 0; colOffset < patternColSize && continueFlag; colOffset++ ){
				for( int rowOffset = 0; rowOffset < patternRowSize && continueFlag; rowOffset++ ){
					uchar neededTile = beforePattern[colOffset*patternRowSize+rowOffset];
					int mapCell = (row+rowOffset)*40 + (col+colOffset);
					if( (neededTile && (Map[ 0 ][ mapCell ] != neededTile)) || FixedMap[ 0 ][ mapCell ] ){
						continueFlag = 0; //бида бида, паттерн не соблюдается, надо искать другое место
					}
				}
			}
			if( !continueFlag ){
				continue;
			}
			// предотвращение установки нескольких трещин рядом
			uchar afterPatternStart = afterPattern[0];
			if( afterPatternStart >= CAVE_WAFM_84_CRACK_IN_WALL_1 && afterPatternStart <= CAVE_WAFM_100_CRACK_IN_WALL_11 ){
				// фикс морфинга подземелий (+ пробная заглушка эмулирующая баг th1 при сверке)
				uchar prevRowCurCol = row < 1 ?
					//#ifdef TH1
					//(IsExeValidating ? Exe::Map[ row - 1 ][ col + 0 ] : 0) : Map[ row - 1 ][ col + 0 ];
					//#else
				    0 : Map[ row - 1 ][ col + 0 ];
					//#endif
				uchar curRowNextCol = Map[ row + 0 ][ col + 1 ];
				uchar curRowPrevCol = col < 1 ?
					//#ifdef TH1
					//(IsExeValidating ? Exe::Map[ row + 0 ][ col - 1 ] : 0) : Map[ row + 0 ][ col - 1 ];
					//#else
					0 : Map[ row + 0 ][ col - 1 ];
					//#endif
				uchar nextRowCurCol = Map[ row + 1 ][ col + 0 ];
				if( prevRowCurCol <= CAVE_WAFM_100_CRACK_IN_WALL_11 ){
					if( prevRowCurCol >= CAVE_WAFM_84_CRACK_IN_WALL_1 ){
						continueFlag = 0;
					}
					if( nextRowCurCol >= CAVE_WAFM_84_CRACK_IN_WALL_1 ){
						continueFlag = 0;
					}
					if( curRowNextCol >= CAVE_WAFM_84_CRACK_IN_WALL_1 ){
						continueFlag = 0;
					}
					if( curRowPrevCol >= CAVE_WAFM_84_CRACK_IN_WALL_1 ){
						continueFlag = 0;
					}
				}
			}

			if( continueFlag == 1 ){
				if( RangeRND(0, 100) < chanceToPlace ){
					for( int colOffset = 0; colOffset < patternColSize; colOffset++ ){
						for( int rowOffset = 0; rowOffset < patternRowSize; rowOffset++ ){
							uchar newTile = afterPattern[colOffset*patternRowSize+rowOffset];
							int mapCell = (row+rowOffset)*40 + (col+colOffset);
							if( newTile ){
								Map[ 0 ][ mapCell ] = newTile;
							}
						}
					}
				}
			}
		}
	}
}

//----- (00414296) --------------------------------------------------------
int __fastcall PlaceAbyssWallPattern(uchar* patternPtr, int chanceToPlace)
{
	unsigned __int8 *v2; // ebx@1
	int v3; // edi@1
	int result; // eax@1
	int v5; // ecx@1
	unsigned __int8 *map_1; // ecx@4
	int v7; // esi@5
	int i; // edx@5
	unsigned __int8 v9; // cl@10
	int v10; // esi@18
	unsigned __int8 v11; // al@18
	unsigned __int8 map; // al@21
	int v13; // edx@35
	int v14; // edi@37
	unsigned __int8 v15; // cl@38
	bool v16; // zf@44
	int v17; // [sp+8h] [bp-30h]@1
	int v18; // [sp+Ch] [bp-2Ch]@1
	int v19; // [sp+10h] [bp-28h]@4
	int v20; // [sp+14h] [bp-24h]@7
	int v21; // [sp+18h] [bp-20h]@2
	int v22; // [sp+1Ch] [bp-1Ch]@1
	int v23; // [sp+20h] [bp-18h]@1
	unsigned __int8 *v24; // [sp+24h] [bp-14h]@4
	int v25; // [sp+28h] [bp-10h]@4
	int v26; // [sp+2Ch] [bp-Ch]@1
	int v27; // [sp+30h] [bp-8h]@5
	char j; // [sp+37h] [bp-1h]@1

	v2 = patternPtr;
	j = 0;
	v18 = chanceToPlace;
	v3 = patternPtr[ 1 ];
	result = *patternPtr;
	v5 = 0;
	v26 = result;
	v22 = 40 - v3;
	v17 = v3;
	v23 = 0;
	if( 40 - v3 > 0 ){
		v21 = 40 - result;
		while( 1 ){
			result = v21;
			if( v21 > 0 ){
				break;
			}
		LABEL_45:
			v5 = v23++ + 1;
			if( v23 >= v22 ){
				goto LABEL_46;
			}
		}
		v25 = 0;
		map_1 = (unsigned __int8 *) Map + v5;
		v24 = map_1;
		v19 = v21;
		while( 1 ){
			v7 = 0;
			v27 = 1;
			for( i = 2; v7 < v3; ++v7 ){
				if( v27 != 1 ){
					break;
				}
				v20 = 0;
				if( v26 > 0 ){
					result = v25 + v7 + v23;
					do{
						if( v27 != 1 ){
							break;
						}
						v9 = v2[ i ];
						if( v9 && Map[ 0 ][ result ] != v9 ){
							v27 = 0;
						}
						if( FixedMap[ 0 ][ result ] ){
							v27 = 0;
						}
						++i;
						++v20;
						result += 40;
					} while( v20 < v26 );
					map_1 = v24;
				}
			}
			v10 = v26 * v3 + 2;
			v11 = v2[ v10 ];
			if( v11 < 84u || v11 > 100u ){
				goto LABEL_33;
			}
			if( v27 == 1 ){
				break;
			}
		LABEL_44:
			v25 += 40;
			map_1 += 40;
			v16 = v19-- == 1;
			v24 = map_1;
			if( v16 ){
				goto LABEL_45;
			}
		}
		map = *(map_1 - 40);
		if( map >= 84u && map <= 100u ){
			v27 = 0;
		}
		if( map_1[ 40 ] >= 84u && map <= 100u ){
			v27 = 0;
		}
		if( map_1[ 1 ] >= 84u && map <= 100u ){
			v27 = 0;
		}
		if( *(map_1 - 1) >= 84u && map <= 100u ){
			v27 = 0;
		}
	LABEL_33:
		if( v27 == 1 ){
			result = RangeRND( 0, 100 );
			if( result < v18 ){
				v13 = 0;
				for( j = 1; v13 < v3; ++v13 ){
					if( v26 > 0 ){
						v14 = v26;
						result = (int) Map + v13 + v23 + v25;
						do{
							v15 = v2[ v10 ];
							if( v15 ){
								*(uchar*) result = v15;
							}
							++v10;
							result += 40;
							--v14;
						} while( v14 );
						v3 = v17;
					}
				}
			}
			map_1 = v24;
		}
		goto LABEL_44;
	}
LABEL_46:
	result = j;
	return result;
}

//----- (00414425) --------------------------------------------------------
void MakeSomeCaveWoodenWallsCrossWallsAndDoors()
{
	// покрыть часть каменных стен досками
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){

			uchar& curRowCurCol = Map[ row ][ col ];

			if( curRowCurCol == CAVE_WAFM_10_SWALL_M_MIDLE ){
				if( !RangeRND(0, 2) ){
					continue;
				}
				int startRow = row + 1;
				int endRow = row;

				do{
					++endRow;
				}while( Map[ endRow ][ col ] == CAVE_WAFM_10_SWALL_M_MIDLE );

				endRow--;
				if( endRow <= row ){
					continue;
				}
				curRowCurCol = CAVE_WAFM_127_M_STONE_WITH_WOOD_UP_END;
				for( int curRow = startRow; curRow < endRow; curRow++ ){
					int newTileIndex;
					if( RangeRND(0, 2) ){
						newTileIndex = CAVE_WAFM_126_M_STONE_WITH_WOOD_MIDDLE;
					}else{
						newTileIndex = CAVE_WAFM_129_M_STONE_WITH_WOOD_MIDDLE_BROKEN;
					}
					Map[ curRow ][ col ] = newTileIndex;
				}
				Map[ endRow ][ col ] = CAVE_WAFM_128_M_STONE_WITH_WOOD_DOWN_END;
			}else if( curRowCurCol == CAVE_WAFM_9_SWALL_UNM_MIDDLE ){
				if( !RangeRND(0, 2) ){
					continue;
				}
				int startCol = col + 1;
				int endCol = col;
				do{
					++endCol;
				}while( Map[ 0 ][ row*40 + endCol ] == CAVE_WAFM_9_SWALL_UNM_MIDDLE );
				endCol--;
				if( endCol <= col ){
					continue;
				}
				curRowCurCol = CAVE_WAFM_123_UNM_STONE_WITH_WOOD_UP_END;
				for( int curCol = startCol; curCol < endCol; curCol++ ){
					int newTileIndex;
					if( RangeRND(0, 2) ){
						newTileIndex = CAVE_WAFM_121_UNM_STONE_WITH_WOOD_MIDDLE;
					}else{
						newTileIndex = CAVE_WAFM_124_UNM_STONE_WITH_WOOD_MIDDLE_BROKEN;
					}
					Map[ row ][ curCol ] = newTileIndex;
				}
				Map[ row ][ endCol ] = CAVE_WAFM_122_UNM_STONE_WITH_WOOD_DOWN_END;
			}else if( curRowCurCol == CAVE_WAFM_11_CORNER_IN_UP ){
				uchar curRowNextCol =	Map[ row + 0 ][ col + 1 ];
				uchar nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
				if( nextRowCurCol != CAVE_WAFM_10_SWALL_M_MIDLE || curRowNextCol != CAVE_WAFM_9_SWALL_UNM_MIDDLE ){
					continue;
				}
				if( !RangeRND(0, 2) ){
					continue;
				}
				curRowCurCol = CAVE_WAFM_125_TEMP_ENTER_TO_TOWN_AND_STONE_WITH_WOOD_CORNER;
				int startRow = row + 1;
				int endRow = row + 1;
				while( Map[ endRow ][ col ] == CAVE_WAFM_10_SWALL_M_MIDLE ){
					endRow++;
				};
				endRow--;
				for( int curRow = startRow; curRow < endRow; curRow++ ){
					int newTileIndex;
					if( RangeRND(0, 2) ){
						newTileIndex = CAVE_WAFM_126_M_STONE_WITH_WOOD_MIDDLE;
					}else{
						newTileIndex = CAVE_WAFM_129_M_STONE_WITH_WOOD_MIDDLE_BROKEN;
					}
					Map[ curRow ][ col ] = newTileIndex;
				}
				Map[ endRow ][ col ] = CAVE_WAFM_128_M_STONE_WITH_WOOD_DOWN_END;
				int startCol = col + 1;
				int endCol = col + 1;
				
				while( Map[ row ][ endCol ] == CAVE_WAFM_9_SWALL_UNM_MIDDLE ){
					endCol++;
				}
				endCol--;
				for( int curCol = startCol; curCol < endCol; curCol++ ){
					int newTileIndex;
					if( RangeRND(0, 2) ){
						newTileIndex = CAVE_WAFM_121_UNM_STONE_WITH_WOOD_MIDDLE;
					}else{
						newTileIndex = CAVE_WAFM_124_UNM_STONE_WITH_WOOD_MIDDLE_BROKEN;
					}
					Map[ row ][ curCol ] = newTileIndex;
				}
				Map[ row ][ endCol ] = CAVE_WAFM_122_UNM_STONE_WITH_WOOD_DOWN_END;
			}

			
		}
	}

	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){

			if( Map[ row ][ col ] != CAVE_WAFM_7_FLOOR ){
				continue;
			}
			if( RangeRND(0, 1) ){// пустое условие. никогда не выполняется
				continue;
			}
			if( !IsCoordinateNotNearAloneRoom(row, col) ){
				continue;
			}
			if( !RangeRND(0, 2) ){
				
				int startCol = col;
				while( IsNotMainDiagonalWoodenWallStart(row, startCol) ){
					startCol--;
				}
				startCol++;

				int endCol = col;
				while( IsNotMainDiagonalWoodenWallEnd(row, endCol) ){
					endCol++;
				}
				endCol--;

				if( Map[ row ][ startCol ] == CAVE_WAFM_7_FLOOR ){
					continue;
				}
				if( Map[ row ][ endCol ] == CAVE_WAFM_7_FLOOR ){
					continue;
				}
				if( endCol <= startCol + 1 ){
					continue;
				}
				int doorCol = RangeRND(0, endCol - startCol - 1) + startCol + 1;
				for( int curCol = startCol; curCol <= endCol; curCol++ ){
					if( curCol == doorCol ){// тайл двери остаётся пустым. Впоследстствии туда в другой функции дверь запихнётся
						continue;
					}
					uchar& wafm = Map[ row ][ curCol ];
					int newTileIndex = 0;
					switch (wafm ){
						case CAVE_WAFM_10_SWALL_M_MIDLE:						newTileIndex = CAVE_WAFM_131_WOOD_WALL_CORNER_M_STONE_UNM_WOOD;	break;
						case CAVE_WAFM_126_M_STONE_WITH_WOOD_MIDDLE:			newTileIndex = CAVE_WAFM_133_WOOD_WALL_CORNER_M_STONE_UNM_WOOD;	break;
						case CAVE_WAFM_129_M_STONE_WITH_WOOD_MIDDLE_BROKEN:		newTileIndex = CAVE_WAFM_133_WOOD_WALL_CORNER_M_STONE_UNM_WOOD;	break;
						case CAVE_WAFM_2_WALL_IN_LD:							newTileIndex = CAVE_WAFM_139_WOOD_WALL_BROKEN_WOOD_CORNER;	break;
						case CAVE_WAFM_134_WOOD_WALL_M_MIDDLE:
						case CAVE_WAFM_136_WOOD_WALL_M_MIDDLE_BROKEN:			newTileIndex = CAVE_WAFM_138_WOOD_WALL_WOOD_CORNER;	break;
						case CAVE_WAFM_7_FLOOR:			
							if( RangeRND(0, 2) ){
								newTileIndex = CAVE_WAFM_135_WOOD_WALL_UNM_MIDDLE;
							}else{
								newTileIndex = CAVE_WAFM_137_WOOD_WALL_UNM_MIDDLE_BROKEN;
							}
							break;
					}
					if( newTileIndex ){
						wafm = newTileIndex;
					}
				}
			}else{

				int startRow = row;
				while( IsNotUnmainDiagonalWoodenWallStart(startRow, col) ){
					startRow--;
				}
				startRow++;

				int endRow = row;
				while( IsNotUnmainDiagonalWoodenWallEnd(endRow, col) ){
					endRow++;
				}
				endRow--;

				

				if( Map[ startRow ][ col ] == CAVE_WAFM_7_FLOOR ){
					continue;
				}
				if( Map[ endRow ][ col ] == CAVE_WAFM_7_FLOOR ){
					continue;
				}

				if( endRow <= startRow + 1 ){
					continue;
				}

				int doorRow = RangeRND(0, endRow - startRow - 1) + startRow + 1;
				for( int curRow = startRow; curRow <= endRow; curRow++ ){
					if( curRow == doorRow ){// тайл двери остаётся пустым. Впоследстствии туда в другой функции дверь запихнётся
						continue;
					}
					uchar& wafm = Map[ curRow ][ col ];
					int newTileIndex = 0;
					switch (wafm ){
						case CAVE_WAFM_9_SWALL_UNM_MIDDLE:						newTileIndex = CAVE_WAFM_130_WOOD_WALL_CORNER_UNM_STONE_M_WOOD;	break;
						case CAVE_WAFM_121_UNM_STONE_WITH_WOOD_MIDDLE:			newTileIndex = CAVE_WAFM_132_WOOD_WALL_CORNER_UNM_STONE_M_WOOD;	break;
						case CAVE_WAFM_124_UNM_STONE_WITH_WOOD_MIDDLE_BROKEN:	newTileIndex = CAVE_WAFM_132_WOOD_WALL_CORNER_UNM_STONE_M_WOOD;	break;
						case CAVE_WAFM_4_WALL_IN_RD:							newTileIndex = CAVE_WAFM_140_WOOD_WALL_BROKEN_WOOD_CORNER;	break;
						case CAVE_WAFM_135_WOOD_WALL_UNM_MIDDLE:
						case CAVE_WAFM_137_WOOD_WALL_UNM_MIDDLE_BROKEN:			newTileIndex = CAVE_WAFM_138_WOOD_WALL_WOOD_CORNER;	break;
						case CAVE_WAFM_7_FLOOR:			
							if( RangeRND(0, 2) ){
								newTileIndex = CAVE_WAFM_134_WOOD_WALL_M_MIDDLE;
							}else{
								newTileIndex = CAVE_WAFM_136_WOOD_WALL_M_MIDDLE_BROKEN;
							}
							break;
					}
					if( newTileIndex ){
						wafm = newTileIndex;
					}

				}
			}



		}
	}

	MakeDoorsInWoodWalls();
	DeleteUnwantedWoodenDoorTiles();
}

//----- (00414850) --------------------------------------------------------
bool __fastcall IsNotMainDiagonalWoodenWallStart(int row, int col)
{
	uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
	uchar nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
	uchar prevRowCurCol =	Map[ row - 1 ][ col + 0 ];

	if( IsWoodWall(nextRowCurCol) ){
		return false;
	}
	
	if( IsWoodWall(prevRowCurCol) ){
		return false;
	}

	return curRowCurCol == CAVE_WAFM_7_FLOOR 
		|| curRowCurCol == CAVE_WAFM_10_SWALL_M_MIDLE 
		|| curRowCurCol == CAVE_WAFM_126_M_STONE_WITH_WOOD_MIDDLE 
		|| curRowCurCol == CAVE_WAFM_129_M_STONE_WITH_WOOD_MIDDLE_BROKEN 
		|| curRowCurCol == CAVE_WAFM_134_WOOD_WALL_M_MIDDLE 
		|| curRowCurCol == CAVE_WAFM_136_WOOD_WALL_M_MIDDLE_BROKEN;
}

//----- (0041489D) --------------------------------------------------------
bool __fastcall IsNotMainDiagonalWoodenWallEnd(int row, int col)
{
	uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
	uchar nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
	uchar prevRowCurCol =	Map[ row - 1 ][ col + 0 ];
	
	if( IsWoodWall(nextRowCurCol) ){
		return false;
	}

	if( IsWoodWall(prevRowCurCol) ){
		return false;
	}

	return curRowCurCol == CAVE_WAFM_7_FLOOR 
		|| curRowCurCol == CAVE_WAFM_2_WALL_IN_LD 
		|| curRowCurCol == CAVE_WAFM_134_WOOD_WALL_M_MIDDLE 
		|| curRowCurCol == CAVE_WAFM_136_WOOD_WALL_M_MIDDLE_BROKEN;
}

//----- (004148E2) --------------------------------------------------------
bool __fastcall IsNotUnmainDiagonalWoodenWallStart(int row, int col)
{
	uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
	uchar curRowNextCol =	Map[ row + 0 ][ col + 1 ];
	uchar curRowPrevCol =	Map[ row + 0 ][ col - 1 ];

	if( IsWoodWall(curRowNextCol) ){
		return false;
	}

	if( IsWoodWall(curRowPrevCol) ){
		return false;
	}

	return curRowCurCol == CAVE_WAFM_7_FLOOR || curRowCurCol == CAVE_WAFM_9_SWALL_UNM_MIDDLE || curRowCurCol == CAVE_WAFM_121_UNM_STONE_WITH_WOOD_MIDDLE || curRowCurCol == CAVE_WAFM_124_UNM_STONE_WITH_WOOD_MIDDLE_BROKEN || curRowCurCol == CAVE_WAFM_135_WOOD_WALL_UNM_MIDDLE || curRowCurCol == CAVE_WAFM_137_WOOD_WALL_UNM_MIDDLE_BROKEN;
}

//----- (0041492F) --------------------------------------------------------
bool __fastcall IsNotUnmainDiagonalWoodenWallEnd(int row, int col)
{
	uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
	uchar curRowNextCol =	Map[ row + 0 ][ col + 1 ];
	uchar curRowPrevCol =	Map[ row + 0 ][ col - 1 ];

	if( IsWoodWall(curRowNextCol) ){
		return false;
	}

	if( IsWoodWall(curRowPrevCol) ){
		return false;
	}

	return curRowCurCol == CAVE_WAFM_7_FLOOR || curRowCurCol == CAVE_WAFM_4_WALL_IN_RD || curRowCurCol == CAVE_WAFM_135_WOOD_WALL_UNM_MIDDLE || curRowCurCol == CAVE_WAFM_137_WOOD_WALL_UNM_MIDDLE_BROKEN;
}

//----- (00414974) --------------------------------------------------------
void InitCaveLevelTiles()
{
	TileSquare* currentLevelTilesFile = (TileSquare*)CurrentLevelTilesFile;
	TileSquare& beyondTile = currentLevelTilesFile[ CAVE_WAFM_8_BEYOND-1 ];

	// заполняем всю карту тайлами бейонда
	for( int col = 0; col < 112; col += 2 ){
		for( int row = 0; row < 112; row += 2 ){
			FineMap[ row + 0 ][ col + 0 ] = beyondTile.up + 1;
			FineMap[ row + 1 ][ col + 0 ] = beyondTile.left + 1;
			FineMap[ row + 0 ][ col + 1 ] = beyondTile.right + 1;
			FineMap[ row + 1 ][ col + 1 ] = beyondTile.down + 1;
		}
	}

	// проходим по всем клеткам и заполняем их значениями из загруженного TIL файла
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar wafm = Map[ row ][ col ];
			ushort up = 0;
			ushort left = 0;
			ushort right = 0;
			ushort down = 0;
			if( wafm ){
				TileSquare& currentTile = currentLevelTilesFile[ wafm-1 ];
				up = currentTile.up + 1;
				left = currentTile.left + 1;
				right = currentTile.right + 1;
				down = currentTile.down + 1;
			}
			FineMap[ 2*row + 0 + 16 ][ 2*col + 0 + 16 ] = up;
			FineMap[ 2*row + 1 + 16 ][ 2*col + 0 + 16 ] = left;
			FineMap[ 2*row + 0 + 16 ][ 2*col + 1 + 16 ] = right;
			FineMap[ 2*row + 1 + 16 ][ 2*col + 1 + 16 ] = down;
		}
	}
}

//----- (00414A7C) --------------------------------------------------------
void __fastcall LoadQuestDungeonMainMapCave( char* dunNamePtr, int a2, int a3 )
{
	InitCaveMaps();
	MapStartRow = 16;
	MapStartCol = 16;
	MapEndRow = 96;
	MapEndCol = 96;
	ClearWallsTransparency();

	ushort* dunData = (ushort*)LoadFile(dunNamePtr, NULL);
	ushort rowSize = dunData[0];
	ushort colSize = dunData[1];
	ushort* dunArray = &dunData[2];
	// заполняем карту архитектуры из дуна
	for( int col = 0; col < colSize; col++ ){
		for( int row = 0; row < rowSize; row++ ){
			ushort wallAndFloorMapValue = dunArray[row + col * rowSize];
			if( wallAndFloorMapValue ){
				Map[ row ][ col ] = (uchar)wallAndFloorMapValue;
			}else{
				Map[ row ][ col ] = CAVE_WAFM_7_FLOOR;
			}
		}
	}


	// не заполненные тайлы заполняем бейондом
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar& wafm = Map[ row ][ col ];
			if( !wafm ){
				wafm = CAVE_WAFM_8_BEYOND;
			}
		}
	}

	MapSize = 112;
	InitCaveLevelTiles();
	ClearObjectMaps();
	PlayerRowPos = 31;
	PlayerColPos = 83;
	AddQuestMonsters((ushort*)dunData, 0, 0);
	AddQuestItems((int)dunData, 0, 0);

	if( QuestFloorIndex != QF_16_ISLAND && (/*IsExeValidating ||*/ QuestFloorIndex != QF_15_FROZEN_LOCH) ){
		for( int col = 0; col < 112; col++ ){
			for( int row = 0; row < 112; row++ ){
				int dmap = FineMap[ row ][ col ];
				if( dmap >= 56 && dmap <= 147 || dmap >= 154 && dmap <= 161 || dmap == 150 || dmap == 152 ){
					ApplyLightSource(row, col, 7, -1); // свет от лавы в квестовых уровнях
				}
			}
		}
	}

	FreeMem((char*)dunData);
}

//----- (00414BC7) --------------------------------------------------------
void __fastcall LoadQuestDungeonAltMapCave( char* dunNamePtr, int a2, int a3 )
{
	InitCaveMaps();
	ClearWallsTransparency();
	ushort* dunData = (ushort*)LoadFile(dunNamePtr, NULL);
	ushort rowSize = dunData[0];
	ushort colSize = dunData[1];
	ushort* dunArray = &dunData[2];

	// заполняем карту архитектуры из дуна
	for( int col = 0; col < colSize; col++ ){
		for( int row = 0; row < rowSize; row++ ){
			ushort wallAndFloorMapValue = dunArray[row + col * rowSize];
			if( wallAndFloorMapValue ){
				Map[ row ][ col ] = (uchar)wallAndFloorMapValue;
			}else{
				Map[ row ][ col ] = CAVE_WAFM_7_FLOOR;
			}
		}
	}

	// не заполненные тайлы заполняем бейондом
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar& wafm = Map[ row ][ col ];
			if( !wafm ){
				wafm = CAVE_WAFM_8_BEYOND;
			}
		}
	}

	memcpy( AltMap, Map, sizeof Map );
	FreeMem((char*)dunData);
}

//----- (00414C6D) --------------------------------------------------------
void LoadHellQuestMaps()
{
	LoadedQuestDungeonMap = 0;
	if( IsQuestOnLevel(Q_11_WARLORD_OF_BLOOD) ){
		QuestPatternPtr = (char*)LoadFile("Levels\\L4Data\\Warlord.DUN", NULL);
		LoadedQuestDungeonMap = 1;
	}
	if( IsQuestOnLevel(Q_21_FLESHDOOM) ){
		QuestPatternPtr = (char*)LoadFile("levels\\l4data\\FDEntry.dun", NULL);
		LoadedQuestDungeonMap = 1;
	}
	if( DungeonLevel == 15 && MaxCountOfPlayersInGame != 1 ){
		QuestPatternPtr = (char*)LoadFile("Levels\\L4Data\\Vile1.DUN", NULL);
		LoadedQuestDungeonMap = 1;
	}
}

//----- (00414CC5) --------------------------------------------------------
void FreeQuestDungeonMapPtr2()
{
	FreeMem(QuestPatternPtr);
	QuestPatternPtr = 0;
}

//----- (00414CD7) --------------------------------------------------------
void __fastcall CopyQuestPatternToHellMap(int row, int col)
{
	ushort* questPatternPtr = (ushort*)QuestPatternPtr;
	StartPatternRow40 = row;
	StartPatternCol40 = col;
	PatternMapRows = questPatternPtr[0];
	PatternMapCols = questPatternPtr[1];

	int patMapOffset = 2;
	for( int colOffset = 0; colOffset < PatternMapCols; colOffset++ ){
		for( int rowOffset = 0; rowOffset < PatternMapRows; rowOffset++ ){
			int cell = col + colOffset + 40 * (row + rowOffset);
			uchar newTile = (uchar) questPatternPtr[patMapOffset];
			if( newTile ){
				FixedMap[ 0 ][ cell ] |= BIT(8);
				Map[ 0 ][ cell ] = newTile;
			}else{
				Map[ 0 ][ cell ] = HELL_WAFM_6_FLOOR;
			}
			patMapOffset++;
		}
	}
}

//----- (00414D5C) --------------------------------------------------------
void FixingHellPandemoniumTiles()
{
	for( int col = 0; col < 14; col++ ){
		for( int row = 0; row < 14; row++ ){
			FixedMap[ MapXOffset + row ][ MapYOffset + col ] = 1;
			FixedMap[ 39 -MapXOffset - row ][ MapYOffset + col ] = 1;
			FixedMap[ MapXOffset + row ][ 39 - MapYOffset - col ] = 1;
			FixedMap[ 39 -MapXOffset - row ][ 39 - MapYOffset - col ] = 1;
		}
	}
}

//----- (00414DD9) --------------------------------------------------------
void __fastcall CopyQuestPatternToHellMap2(char* patternPtr, int row, int col)
{
	ushort* questPatternPtr = (ushort*)patternPtr;
	int patternMapRows = questPatternPtr[0];
	int patternMapCols = questPatternPtr[1];

	int patMapOffset = 2;
	for( int colOffset = 0; colOffset < patternMapCols; colOffset++ ){
		for( int rowOffset = 0; rowOffset < patternMapRows; rowOffset++ ){
			int cell = col + colOffset + 40 * (row + rowOffset);
			uchar newTile = (uchar)questPatternPtr[patMapOffset];
			if( newTile ){
				FixedMap[ 0 ][ cell ] |= BIT(8);
				Map[ 0 ][ cell ] = newTile;
			}else{
				Map[ 0 ][ cell ] = HELL_WAFM_6_FLOOR;
			}
			patMapOffset++;
		}
	}
}

//----- (00414E37) --------------------------------------------------------
void __fastcall MakePandemium(int isAltDun)
{
	char* diab1Ptr = (char*)LoadFile("Levels\\L4Data\\diab1.DUN", NULL);
	DUNDiab1XOffset = MapXOffset + 4;
	DUNDiab1YOffset = MapYOffset + 4;
	CopyQuestPatternToHellMap2(diab1Ptr, DUNDiab1XOffset, DUNDiab1YOffset);
	FreeMem(diab1Ptr);

	char* diab2Name;
	if( isAltDun ){
		diab2Name = "Levels\\L4Data\\diab2b.DUN";
	}else{
		diab2Name = "Levels\\L4Data\\diab2a.DUN";
	}
	char* diab2Ptr = (char*)LoadFile(diab2Name, NULL);
	DUNDiab2YOffset = MapYOffset + 1;
	DUNDiab2XOffset = 27 - MapXOffset;
	CopyQuestPatternToHellMap2(diab2Ptr, 27 - MapXOffset, MapYOffset + 1);
	FreeMem(diab2Ptr);

	char* diab3Name;
	if( isAltDun ){
		diab3Name = "Levels\\L4Data\\diab3b.DUN";
	}else{
		diab3Name = "Levels\\L4Data\\diab3a.DUN";
	}
	char* diab3Ptr = (char*)LoadFile(diab3Name, NULL);
	DUNDiab3XOffset = MapXOffset + 1;
	DUNDiab3YOffset = 27 - MapYOffset;
	CopyQuestPatternToHellMap2(diab3Ptr, MapXOffset + 1, 27 - MapYOffset);
	FreeMem(diab3Ptr);

	char* diab4Name;
	if( isAltDun ){
		diab4Name = "Levels\\L4Data\\diab4b.DUN";
	}else{
		diab4Name = "Levels\\L4Data\\diab4a.DUN";
	}
	char* diab4Ptr = (char*)LoadFile(diab4Name, NULL);
	DUNDiab4YOffset = 28 - MapYOffset;
	DUNDiab4XOffset = 28 - MapXOffset;
	CopyQuestPatternToHellMap2(diab4Ptr, 28 - MapXOffset, 28 - MapYOffset);
	FreeMem(diab4Ptr);
}

//----- (00414F46) --------------------------------------------------------
bool __fastcall IsHellBeyondTileWithWallsContinueInLuAndLd(char hellWafm)
{
	return hellWafm == HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT 
		|| hellWafm == HELL_WAFM_25_BEYOND
		|| hellWafm == HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT;
}

//----- (00414F5D) --------------------------------------------------------
bool __fastcall IsHellBeyondTileWithWallsContinueInRuAndRd(char hellWafm)
{
	return hellWafm == HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT 
		|| hellWafm == HELL_WAFM_26_BEYOND
		|| hellWafm == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT;
}

//----- (00414F74) --------------------------------------------------------
void SetToZeroFirstLinesInHellBinPattern()
{
	for( int row = 0; row < 20; row++ ){
		BinaryHellMap[ row ][ 0 ] = 0;
	}

	for( int col = 0; col < 20; col++ ){
		BinaryHellMap[ 0 ][ col ] = 0;
	}
}

//----- (00414F92) --------------------------------------------------------
void SomeStrangeHellTilesConvert()
{
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			uchar& curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];

			if( curRowCurCol == HELL_WAFM_24 || curRowCurCol == HELL_WAFM_122 ){
				if( nextRowCurCol == HELL_WAFM_2 && curRowNextCol == HELL_WAFM_5 ){
					curRowCurCol = HELL_WAFM_17;
				}
			}
		}
	}
}

//----- (00414FC7) --------------------------------------------------------
void __fastcall CreateHellTypeLabyrinth(int levelRandomSeed, int loadingMode)
{
	InitRandomSeed(levelRandomSeed);
	// оптимизировать генерацию уровней можно всегда
	if( true /*IsExeValidating*/ && StartLevelSeed[ DungeonLevel ] == RandomSeed && MatchLevelSeed[ DungeonLevel ] ){
		RandomSeed = MatchLevelSeed[ DungeonLevel ];
	}else{
		StartLevelSeed[ DungeonLevel ] = RandomSeed;
		MatchLevelSeed[ DungeonLevel ] = 0;
	}
	MapStartRow = 16;
	MapStartCol = 16;
	MapEndRow = 96;
	MapEndCol = 96;
	PlayerRowPos = 40;
	PlayerColPos = 40;
	ResetPatternMapPos();
	LoadHellQuestMaps();
	HellLevelGeneration(loadingMode);
	InitHellLevelTiles();
	FreeQuestDungeonMapPtr2();
	MarkPatternPositionOnMap();
}

//----- (00415018) --------------------------------------------------------
void __fastcall HellLevelGeneration(int loadingMode)
{
	bool isGenerationEnd;
	do{
		ClearWallsTransparency();
		int levelArea = 0;
		int levelSeed = 0;
		do{
			levelSeed = RandomSeed;
			InitHellMaps();
			ConstructHellRooms();
			SetToZeroFirstLinesInHellBinPattern();
			levelArea = AreaOfLevelRoomsHell();
		}while( levelArea < 173 );
		if( !MatchLevelSeed[ DungeonLevel ] && StartLevelSeed[ DungeonLevel ] ){
			MatchLevelSeed[ DungeonLevel ] = levelSeed;
		}
		if( levelArea >= 173 ){
			SomeStrangeHellBinaryMapChenges();
		}
		CopyHellInitalRoomsScheme();
		InitHellWallAndFloorMapFromBynaryPattern();
		HellLevelWallsConverting();
		if( DungeonLevel == 16 ){
			FixingHellPandemoniumTiles();
		}
		if( IsQuestOnLevel(Q_11_WARLORD_OF_BLOOD)
	     || IsQuestOnLevel(Q_21_FLESHDOOM)
	     || DungeonLevel == Quests[Q_15_ARCHBISHOP_LAZARUS].dungeonLevel && MaxCountOfPlayersInGame != 1 ){
			for( int col = Map40x40gStartCol; col < Map40x40gEndCol; col++ ){
				for( int row = Map40x40gStartRow; row < Map40x40gEndRow; row++ ){
					FixedMap[ row ][ col ] = 1;
				}
			}
		}
		HellMakeSomeCrossWalls();
		InitHellWallsTransparency();
		HellSetAdditionalWallsTransparency();
		if( LoadedQuestDungeonMap ){
			CopyQuestPatternToHellMap(Map40x40gStartRow, Map40x40gStartCol);
		}
		if( DungeonLevel == 16 ){
			MakePandemium(1);// альтернативные дуны 16го
		}
		bool goFromUp = loadingMode == 0;
		bool goFromDown = loadingMode == 1;
		bool goFromTown = loadingMode > 1;

		if( IsQuestOnLevel( Q_11_WARLORD_OF_BLOOD ) ){
			isGenerationEnd = PlaceHellPatMap( (int)PatMap4x5_48AA48_HellDungeonEnterToUp, 1, 1, -1, -1, goFromUp, 0 );
			if( isGenerationEnd && DungeonLevel == 13 ){
				isGenerationEnd = PlaceHellPatMap( (int)PatMap4x5_48AA78_HellDungeonEnterToTown, 1, 1, -1, -1, goFromTown, 6 );
			}
			if( goFromDown ){
				PlayerRowPos = 2 * StartPatternRow40 + 22;
				PlayerColPos = 2 * StartPatternCol40 + 22;
			}else{
				++PlayerRowPos;
			}
		}else{
			if( DungeonLevel == 15 ){
				isGenerationEnd = PlaceHellPatMap( (int)PatMap4x5_48AA48_HellDungeonEnterToUp, 1, 1, -1, -1, goFromUp, 0 );
				if( isGenerationEnd ){
					int pandemiumEnterType = 0;
					if( MaxCountOfPlayersInGame != 1 || Quests[Q_5_DIABLO].status == QS_2_IN_PROGRESS ){
						pandemiumEnterType = (int)PatMap5x5_48AB18_PandemiumEnterActivated;
					}else{
						pandemiumEnterType = (int)PatMap5x5_48AAE0_PandemiumEnterDesactivated;
					}
					isGenerationEnd = PlaceHellPatMap( pandemiumEnterType, 1, 1, -1, -1, ! goFromUp, 1 );
				}
				if( goFromUp ){
					++PlayerRowPos;
				}else{
					++PlayerColPos;
				}
			}else{
				isGenerationEnd = PlaceHellPatMap( (int)PatMap4x5_48AA48_HellDungeonEnterToUp, 1, 1, -1, -1, goFromUp, 0 );
				if( isGenerationEnd ){
					if( DungeonLevel != 16 ){
						isGenerationEnd = PlaceHellPatMap( (int)PatMap5x5_48AAA8_HellDungeonEnterToDown, 1, 1, -1, -1, goFromDown, 1 );
						if( isGenerationEnd && DungeonLevel == 13 ){
							isGenerationEnd = PlaceHellPatMap( (int)PatMap4x5_48AA78_HellDungeonEnterToTown, 1, 1, -1, -1, goFromTown, 6 );
						}
					}
				}
				if( goFromDown ){
					if( DungeonLevel == 16 && isGenerationEnd ){
						PlayerRowPos = 2 * DUNDiab4XOffset + 27;
						PlayerColPos = 2 * DUNDiab4YOffset + 24;
					}
					++PlayerColPos;
				}else{
					++PlayerRowPos;
				}
			}
		}

		if( !isGenerationEnd ){
			MatchLevelSeed[ DungeonLevel ] = 0;
		}
	}while( !isGenerationEnd );
	
	SomeStrangeHellTilesConvert();

	if( DungeonLevel != 16 ){
		CreateRooms(7, 10, HELL_WAFM_6_FLOOR, 8, 1);
	}
	CreateSomeStaticHellShadow();
	SomeHellBeyondTilesConvert();
	HellTilesVariationsChange();
	ClearObjectMaps();

	if( IsQuestOnLevel(Q_11_WARLORD_OF_BLOOD) ){
		for( int i = 0; i < 40*40; i++ ){
			AltMap[ 0 ][ i ] = Map[ 0 ][ i ];
		}
	}

	AddDungeonQuestPatternToWallMap(Map40x40gStartRow, Map40x40gStartCol);

	if( DungeonLevel == 15 ){
		for( int col = 0; col < 40; col++ ){
			for( int row = 0; row < 40; row++ ){
				uchar& curWallAndFloorMap = Map[ row ][ col ];
				if( curWallAndFloorMap == HELL_WAFM_98_PANDEMIUM_ENTER_DEACTIVATED || curWallAndFloorMap == HELL_WAFM_107_PANDEMIUM_ENTER_ACTIVATED ){
					MarkPandemiumPositionOnMap(row - 1, col - 1, 5, 5);
				}
			}
		}
	}

	if( DungeonLevel == 16 ){
		for( int i = 0; i < 40*40; i++ ){
			AltMap[ 0 ][ i ] = Map[ 0 ][ i ];
		}
		MakePandemium(0);// основные дуны 16го
	}
}

//----- (0041545B) --------------------------------------------------------
void CreateSomeStaticHellShadow()
{
	for( int col = 1; col < 40; col++ ){
		for( int row = 1; row < 40; row++ ){
			uchar& curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& prevRowCurCol =	Map[ row - 1 ][ col + 0 ];
			uchar& prevRowPrevCol =	Map[ row - 1 ][ col - 1 ];

			if( curRowCurCol == HELL_WAFM_3 
				|| curRowCurCol == HELL_WAFM_4 
				|| curRowCurCol == HELL_WAFM_8 
				|| curRowCurCol == HELL_WAFM_15 ){
					if( prevRowCurCol == HELL_WAFM_6_FLOOR ){
						prevRowCurCol = HELL_WAFM_47;
					}
					if( prevRowPrevCol == HELL_WAFM_6_FLOOR ){
						prevRowPrevCol = HELL_WAFM_48;
					}
			}
		}
	}
}

//----- (004154B4) --------------------------------------------------------
void InitHellMaps()
{
	memset(BinaryHellMap, 0, sizeof (BinaryHellMap));
	memset(InitalHellWallScheme, 0, sizeof (InitalHellWallScheme));
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			FixedMap[ row ][ col ] = 0;
			Map[ row ][ col ] = HELL_WAFM_30_BEYOND;
		}
	}
}

//----- (004154FE) --------------------------------------------------------
void InitHellWallAndFloorMapFromBynaryPattern()
{
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			int row80 = 2 * row + 1;
			int col80 = 2 * col + 1;
			int var1 = InitalHellWallScheme[ row80 + 0 ][ col80 + 0 ];
			int var2 = InitalHellWallScheme[ row80 + 1 ][ col80 + 0 ];
			int var3 = InitalHellWallScheme[ row80 + 0 ][ col80 + 1 ];
			int var4 = InitalHellWallScheme[ row80 + 1 ][ col80 + 1 ];
			Map[ row ][ col ] = HellOrientedWallsAndCorner[var1 + 2*var2 + 4*var3 + 8*var4];
		}
	}
}

//----- (0041555A) --------------------------------------------------------
void HellMakeSomeCrossWalls()
{
	#ifndef REFUCKTOR
	int col; // edi@1
	int row; // esi@2
	int cell; // ebx@2
	int v3; // eax@6
	int v4; // eax@10
	int v5; // eax@14
	int v6; // eax@18
	int v7; // eax@22
	int v8; // eax@26
	int v9; // eax@30
	int v10; // eax@34
	int v11; // eax@38
	int v12; // eax@42
	int v13; // eax@46
	int v14; // eax@50
	int walls_2; // eax@54
	int walls; // eax@58
	int walls_1; // eax@62

	col = 0;
	do{
		row = 0;
		cell = col;
		do{
			if( !FixedMap[ 0 ][ cell ] ){
				if( Map[ 0 ][ cell ] == 10 && RangeRND( 0, 100 ) < 100 ){
					v3 = HellCountWallInRowFrom( row, col );
					if( v3 != -1 ){
						HellSetVerticalWall( row, col, v3 );
					}
				}
				if( Map[ 0 ][ cell ] == 12 && RangeRND( 0, 100 ) < 100 ){
					v4 = HellCountWallInRowFrom( row, col );
					if( v4 != -1 ){
						HellSetVerticalWall( row, col, v4 );
					}
				}
				if( Map[ 0 ][ cell ] == 13 && RangeRND( 0, 100 ) < 100 ){
					v5 = HellCountWallInRowFrom( row, col );
					if( v5 != -1 ){
						HellSetVerticalWall( row, col, v5 );
					}
				}
				if( Map[ 0 ][ cell ] == 15 && RangeRND( 0, 100 ) < 100 ){
					v6 = HellCountWallInRowFrom( row, col );
					if( v6 != -1 ){
						HellSetVerticalWall( row, col, v6 );
					}
				}
				if( Map[ 0 ][ cell ] == 16 && RangeRND( 0, 100 ) < 100 ){
					v7 = HellCountWallInRowFrom( row, col );
					if( v7 != -1 ){
						HellSetVerticalWall( row, col, v7 );
					}
				}
				if( Map[ 0 ][ cell ] == 21 && RangeRND( 0, 100 ) < 100 ){
					v8 = HellCountWallInRowFrom( row, col );
					if( v8 != -1 ){
						HellSetVerticalWall( row, col, v8 );
					}
				}
				if( Map[ 0 ][ cell ] == 22 && RangeRND( 0, 100 ) < 100 ){
					v9 = HellCountWallInRowFrom( row, col );
					if( v9 != -1 ){
						HellSetVerticalWall( row, col, v9 );
					}
				}
				if( Map[ 0 ][ cell ] == 8 && RangeRND( 0, 100 ) < 100 ){
					v10 = HellCountWallInColFrom( row, col );
					if( v10 != -1 ){
						HellSetHorisontalWall( row, col, v10 );
					}
				}
				if( Map[ 0 ][ cell ] == 9 && RangeRND( 0, 100 ) < 100 ){
					v11 = HellCountWallInColFrom( row, col );
					if( v11 != -1 ){
						HellSetHorisontalWall( row, col, v11 );
					}
				}
				if( Map[ 0 ][ cell ] == 11 && RangeRND( 0, 100 ) < 100 ){
					v12 = HellCountWallInColFrom( row, col );
					if( v12 != -1 ){
						HellSetHorisontalWall( row, col, v12 );
					}
				}
				if( Map[ 0 ][ cell ] == 14 && RangeRND( 0, 100 ) < 100 ){
					v13 = HellCountWallInColFrom( row, col );
					if( v13 != -1 ){
						HellSetHorisontalWall( row, col, v13 );
					}
				}
				if( Map[ 0 ][ cell ] == 15 && RangeRND( 0, 100 ) < 100 ){
					v14 = HellCountWallInColFrom( row, col );
					if( v14 != -1 ){
						HellSetHorisontalWall( row, col, v14 );
					}
				}
				if( Map[ 0 ][ cell ] == 16 && RangeRND( 0, 100 ) < 100 ){
					walls_2 = HellCountWallInColFrom( row, col );
					if( walls_2 != -1 ){
						HellSetHorisontalWall( row, col, walls_2 );
					}
				}
				if( Map[ 0 ][ cell ] == 21 && RangeRND( 0, 100 ) < 100 ){
					walls = HellCountWallInColFrom( row, col );
					if( walls != -1 ){
						HellSetHorisontalWall( row, col, walls );
					}
				}
				if( Map[ 0 ][ cell ] == 23 && RangeRND( 0, 100 ) < 100 ){
					walls_1 = HellCountWallInColFrom( row, col );
					if( walls_1 != -1 ){
						HellSetHorisontalWall( row, col, walls_1 );
					}
				}
			}
			++row;
			cell += 40;
		}while( row < 40 );
		++col;
	}while( col < 40 );
	#else
	// технически похоже, но иногда чуть меньше вызовов RangeRND
	// предполагал что из-за уже исправленных багов в HellSetVerticalWall, HellSetHorisontalWall
	// но вопроизвелось из без них
	for( int col = 0; col < 40; ++col ){
		for( int row = 0; row < 40; ++row ){
			if( FixedMap[ row ][ col ] ){
				continue;
			}
			bool maybeRowWall = false;
			switch (Map[ row ][ col ] ){
			case HELL_WAFM_10:
			case HELL_WAFM_12:
			case HELL_WAFM_13:
			case HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT:
				maybeRowWall = true;
				break;
			case HELL_WAFM_15:
			case HELL_WAFM_16:
			case HELL_WAFM_21:
				maybeRowWall = true;
				break;
			}

			if( maybeRowWall ){
				RangeRND(0, 100);
				int walls = HellCountWallInRowFrom(row, col);
				if( walls != -1 ){
					HellSetVerticalWall(row, col, walls);
				}
			}

			bool maybeColWall = false;
			switch (Map[ row ][ col ] ){
			case HELL_WAFM_8:
			case HELL_WAFM_9:
			case HELL_WAFM_11:
			case HELL_WAFM_14:
			case HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT:
				maybeColWall = true;
				break;
			case HELL_WAFM_15:
			case HELL_WAFM_16:
			case HELL_WAFM_21:
				maybeColWall = true;
				break;
			}

			if( maybeColWall ){
				RangeRND(0, 100);
				int walls = HellCountWallInColFrom(row, col);
				if( walls != -1 ){
					HellSetHorisontalWall(row, col, walls);
				}
			}
		}
	}
	#endif
}

//----- (00415851) --------------------------------------------------------
int __fastcall HellCountWallInRowFrom(int row, int col)
{
	int wallCount;
	uchar wall;
	for( wallCount = 1; wallCount < 40 - row; wallCount++ ){
		wall = Map[ row + wallCount ][ col + 0 ];
		if( wall != HELL_WAFM_6_FLOOR ||
			Map[ row + wallCount ][ col - 1 ] != HELL_WAFM_6_FLOOR ||
			Map[ row + wallCount ][ col + 1 ] != HELL_WAFM_6_FLOOR ||
			FixedMap[ row + wallCount ][ col + 0 ] ){
				break;
		}
	}
	if( (wall == HELL_WAFM_10 || wall == HELL_WAFM_12 || wall == HELL_WAFM_13 || wall == HELL_WAFM_15 || wall == HELL_WAFM_16 || wall == HELL_WAFM_21 || wall == HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT ) && wallCount > 3 ){
		return wallCount;
	}else{
		return -1;
	}
}

//----- (004158E8) --------------------------------------------------------
int __fastcall HellCountWallInColFrom(int row, int col)
{
	int wallCount;
	uchar wall;
	for( wallCount = 1; wallCount < 40 - col; wallCount++ ){
		wall = Map[ row + 0 ][ col + wallCount ];
		if( wall != HELL_WAFM_6_FLOOR ||
			Map[ row - 1 ][ col + wallCount ] != HELL_WAFM_6_FLOOR ||
			Map[ row + 1 ][ col + wallCount ] != HELL_WAFM_6_FLOOR ||
			FixedMap[ row + 0 ][ col + wallCount ] ){
				break;
		}
	}

	if( (wall == HELL_WAFM_8 || wall == HELL_WAFM_9 || wall == HELL_WAFM_11 || wall == HELL_WAFM_14 || wall == HELL_WAFM_15 || wall == HELL_WAFM_16 || wall == HELL_WAFM_21 || wall == HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT ) && wallCount > 3 ){
		return wallCount;
	}else{
		return -1;
	}
}

//----- (00415983) --------------------------------------------------------
void __fastcall HellSetVerticalWall(int startRow, int startCol, int wallsCount)
{
	int startCell = startCol + 40 * startRow;
	int startWallType = 0;
	switch (Map[ 0 ][ startCell ] ){
	case HELL_WAFM_13:	startWallType = HELL_WAFM_17;	break;
	case HELL_WAFM_16:	startWallType = HELL_WAFM_11;	break;
	case HELL_WAFM_12:	startWallType = HELL_WAFM_14;	break;
	}
	if( startWallType ) Map[ 0 ][ startCell ] = startWallType;

	for( int rowOffset = 1; rowOffset < wallsCount; rowOffset++ ){
		Map[ startRow + rowOffset ][ startCol ] = HELL_WAFM_2;
	}

	int endCell = startCol + 40 * (wallsCount + startRow);
	int endWallType = 0;
	switch (Map[ 0 ][ endCell ] ){
	case HELL_WAFM_15:	endWallType = HELL_WAFM_14;	break;
	case HELL_WAFM_10:	endWallType = HELL_WAFM_17;	break;
	case HELL_WAFM_21:	endWallType = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;	break;
	case HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT:	endWallType = HELL_WAFM_29;	break;
	}
	if( endWallType ) Map[ 0 ][ endCell ] = endWallType;

	int doorCell = startCol + 40 * (startRow + RangeRND(0, wallsCount - 3) + 1);
	Map[ 0 ][ doorCell ] = HELL_WAFM_57;
	Map[ 2 ][ doorCell ] = HELL_WAFM_56;
	Map[ 0 ][ doorCell + 40 ] = HELL_WAFM_60;
	if( Map[ 0 ][ doorCell - 1 ] == HELL_WAFM_6_FLOOR ){
		Map[ 0 ][ doorCell - 1 ] = HELL_WAFM_58;
	}
	if( Map[ 0 ][ doorCell + 40 - 1 ] == HELL_WAFM_6_FLOOR ){
		Map[ 0 ][ doorCell + 40 - 1 ] = HELL_WAFM_59;
	}
}

//----- (00415A57) --------------------------------------------------------
void __fastcall HellSetHorisontalWall(int startRow, int startCol, int wallsCount)
{
	int startCell = startCol + 40 * startRow;
	int startWallType = 0;
	switch (Map[ 0 ][ startCell ] ){
	case HELL_WAFM_14:	startWallType = HELL_WAFM_17;	break;
	case HELL_WAFM_8:	startWallType = HELL_WAFM_9;	break;
	case HELL_WAFM_15:	startWallType = HELL_WAFM_10;	break;
	}
	if( startWallType ) Map[ 0 ][ startCell ] = startWallType;

	for( int colOffset = 1; colOffset < wallsCount; colOffset++ ){
		Map[ startRow + 0 ][ startCol + colOffset ] = HELL_WAFM_1;
	}

	int endCell = startRow * 40 + (startCol + wallsCount);
	int endWallType = 0;
	switch (Map[ 0 ][ endCell ] ){
	case HELL_WAFM_11:	endWallType = HELL_WAFM_17;	break;
	case HELL_WAFM_9:	endWallType = HELL_WAFM_10;	break;
	case HELL_WAFM_16:	endWallType = HELL_WAFM_13;	break;
	case HELL_WAFM_21:	endWallType = HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT;	break;
	case HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT:	endWallType = HELL_WAFM_29;	break;
	}
	if( endWallType ) Map[ 0 ][ endCell ] = endWallType;


	int doorCell = 40 * startRow + startCol + RangeRND(0, wallsCount - 3) + 1;
	Map[ 0 ][ doorCell ] = HELL_WAFM_53;
	Map[ 0 ][ doorCell + 2 ] = HELL_WAFM_52;
	Map[ 0 ][ doorCell + 1 ] = HELL_WAFM_6_FLOOR;
	if( Map[ 0 ][ doorCell - 40 ] == HELL_WAFM_6_FLOOR ){
		Map[ 0 ][ doorCell - 40 ] = HELL_WAFM_54;
	}
	if( Map[ 0 ][ doorCell - 41 ] == HELL_WAFM_6_FLOOR ){
		Map[ 0 ][ doorCell - 41 ] = HELL_WAFM_55;
	}
}

//----- (00415B3B) --------------------------------------------------------
void HellLevelWallsConverting()
{

	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			if( curRowCurCol == HELL_WAFM_2 ){
				if( nextRowCurCol == HELL_WAFM_6_FLOOR ){
					nextRowCurCol = HELL_WAFM_5;
				}
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_13;
				}
			}else if( curRowCurCol == HELL_WAFM_1 ){
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_14;
				}
			}

		}
	}
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowPrevCol =	Map[ row + 0 ][ col - 1 ];

			switch (curRowCurCol ){
			case HELL_WAFM_2:
				if( nextRowCurCol == HELL_WAFM_6_FLOOR ){
					nextRowCurCol = HELL_WAFM_2;
				}else if( nextRowCurCol == HELL_WAFM_9 ){
					nextRowCurCol = HELL_WAFM_11;
				}
				break;
			case HELL_WAFM_9:
				if( nextRowCurCol == HELL_WAFM_6_FLOOR ){
					nextRowCurCol = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_14:
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_13;
				}
				break;
			case HELL_WAFM_6_FLOOR:
				if( nextRowCurCol == HELL_WAFM_14 ){
					nextRowCurCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_13 ){
					curRowNextCol = HELL_WAFM_16;
				}
				if( col > 0 ){
					if( curRowPrevCol == HELL_WAFM_1 ){
						curRowPrevCol = HELL_WAFM_1;
					}
				}
				break;
			case HELL_WAFM_1:
				if( curRowNextCol == HELL_WAFM_9 ){
					curRowNextCol = HELL_WAFM_10;
				}
				break;
			}
		}
	}
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowPrevCol =	Map[ row + 0 ][ col - 1 ];
			uchar& prevRowCurCol =	Map[ row - 1 ][ col + 0 ];

			int cell = col + 40 * row;

			switch (curRowCurCol ){
			case HELL_WAFM_13:
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT;
				}
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_9 ){
					curRowNextCol = HELL_WAFM_10;
				}
				break;
			case HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT:
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_19;
				}
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_16;
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_19;
				}
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_16;
				}
				break;
			case HELL_WAFM_1:
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT;
				}
				if( curRowPrevCol == HELL_WAFM_15 ){
					curRowPrevCol = HELL_WAFM_10;
				}
				break;
			case HELL_WAFM_19:
				if( nextRowCurCol == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT ){
					nextRowCurCol = HELL_WAFM_26_BEYOND;
				}
				if( nextRowCurCol == HELL_WAFM_18 ){
					nextRowCurCol = HELL_WAFM_24;
				}
				if( nextRowCurCol == HELL_WAFM_19 ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_30_BEYOND ){
						nextRowCurCol = HELL_WAFM_24;
					}
				}
				if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_2 ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_18 ){
						if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_1 || Map[ 0 ][ cell + 41 ] == HELL_WAFM_13 ){
							nextRowCurCol = HELL_WAFM_17;
						}
					}
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT ){
						if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_1 ){
							nextRowCurCol = HELL_WAFM_17;
						}
					}
				}
				if( nextRowCurCol == HELL_WAFM_10 ){
					nextRowCurCol = HELL_WAFM_17;
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_19;
				}
				if( nextRowCurCol == HELL_WAFM_9 ){
					nextRowCurCol = HELL_WAFM_11;
				}
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_13;
				}
				if( nextRowCurCol == HELL_WAFM_13 ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_6_FLOOR ){
						nextRowCurCol = HELL_WAFM_16;
					}
				}
				break;
			case HELL_WAFM_2:
				if( nextRowCurCol == HELL_WAFM_15 ){
					nextRowCurCol = HELL_WAFM_14;
				}
				if( nextRowCurCol == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_9 ){
						nextRowCurCol = HELL_WAFM_29;
					}
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT;
				}
				if( nextRowCurCol == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_30_BEYOND ){
						nextRowCurCol = HELL_WAFM_29;
					}
				}
				if( nextRowCurCol == HELL_WAFM_18 ){
					nextRowCurCol = HELL_WAFM_25_BEYOND;
				}
				if( nextRowCurCol == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_2 ){
						nextRowCurCol = HELL_WAFM_29;
					}
				}
				if( nextRowCurCol == HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_6_FLOOR ){
						nextRowCurCol = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;
					}
				}
				break;
			case HELL_WAFM_14:
				if( nextRowCurCol == HELL_WAFM_15 ){
					nextRowCurCol = HELL_WAFM_14;
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					if( curRowNextCol == HELL_WAFM_6_FLOOR ){
						nextRowCurCol = HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT;
					}
				}
				if( nextRowCurCol == HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT ){
					if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_1 ){
						nextRowCurCol = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;
					}
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_30_BEYOND ){
						nextRowCurCol = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;
					}
				}
				if( nextRowCurCol == HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT ){
					if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_30_BEYOND )
						nextRowCurCol = HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT;
				}
				if( nextRowCurCol == HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT ){
					if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_30_BEYOND ){
						if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_6_FLOOR ){
							nextRowCurCol = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;
						}
					}
				}
				break;
			case HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT:
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_16;
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_19;
				}
				if( curRowNextCol == HELL_WAFM_9 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_18;
				}
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( nextRowCurCol == HELL_WAFM_9 ){
					nextRowCurCol = HELL_WAFM_11;
				}
				break;
			case HELL_WAFM_6_FLOOR:
				if( nextRowCurCol == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT ){
					if( Map[ 0 ][ cell + 41 ] ){
						nextRowCurCol = HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT;
					}
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_6_FLOOR ){
						nextRowCurCol = HELL_WAFM_21;
					}
				}
				break;
			case HELL_WAFM_21:
				if( nextRowCurCol == HELL_WAFM_1 ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_1 ){
						nextRowCurCol = HELL_WAFM_13;
					}
				}
				if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_2 ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_18 ){
						if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_1 )
							nextRowCurCol = HELL_WAFM_17;
					}
				}
				if( Map[ 0 ][ cell + 40 + 1 ] == HELL_WAFM_1 ){
					if( Map[ 0 ][ cell + 40 - 1 ] == HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT ){
						if( Map[ 2 ][ cell ] == HELL_WAFM_3 ){
							nextRowCurCol = HELL_WAFM_17;
						}
					}
				}
				if( Map[ 0 ][ cell + 40 - 1 ] == HELL_WAFM_21 ){
					nextRowCurCol = HELL_WAFM_24;
				}
				if( nextRowCurCol == HELL_WAFM_9 ){
					if( Map[ 2 ][ cell ] == HELL_WAFM_2 ){
						nextRowCurCol = HELL_WAFM_11;
					}
				}
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_9 ){
					curRowNextCol = HELL_WAFM_10;
				}
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_18;
				}
				if( nextRowCurCol == HELL_WAFM_18 ){
					if( Map[ 2 ][ cell ] == HELL_WAFM_30_BEYOND ){
						nextRowCurCol = HELL_WAFM_24;
					}
				}
				if( nextRowCurCol == HELL_WAFM_9 ){
					if( Map[ 0 ][ cell + 40 + 1 ] == HELL_WAFM_1 ){
						nextRowCurCol = HELL_WAFM_16;
					}
				}
				if( nextRowCurCol == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT ){
					nextRowCurCol = HELL_WAFM_26_BEYOND;
				}
				if( nextRowCurCol == HELL_WAFM_18 ){
					nextRowCurCol = HELL_WAFM_24;
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_19;
				}
				break;
			case HELL_WAFM_16:
				if( nextRowCurCol == HELL_WAFM_6_FLOOR ){
					if( curRowNextCol == HELL_WAFM_30_BEYOND ){
						curRowNextCol = HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT;
					}
				}
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					if( Map[ 0 ][ cell + 40 + 1 ] == HELL_WAFM_30_BEYOND ){
						curRowNextCol = HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT;
					}
				}
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_18;
				}
				break;
			case HELL_WAFM_9:
				if( nextRowCurCol == HELL_WAFM_15 ){
					nextRowCurCol = HELL_WAFM_14;
				}
				if( nextRowCurCol == HELL_WAFM_15 ){
					nextRowCurCol = HELL_WAFM_14;
				}
				break;
			case HELL_WAFM_15:
				if( nextRowCurCol == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT ){
					if( Map[ 0 ][ cell + 40 + 1 ] == HELL_WAFM_2 ){
						nextRowCurCol = HELL_WAFM_29;
					}
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT;
				}
				if( nextRowCurCol == HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT ){
					if( Map[ 2 ][ cell ] == HELL_WAFM_30_BEYOND ){
						if( Map[ 0 ][ cell + 40 - 1 ] == HELL_WAFM_6_FLOOR ){
							nextRowCurCol = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;
						}
					}
				}
				if( nextRowCurCol == HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT ){
					if( Map[ 0 ][ cell + 40 + 1 ] == HELL_WAFM_30_BEYOND ){
						nextRowCurCol = HELL_WAFM_29;
					}
				}
				if( curRowNextCol == HELL_WAFM_3 ){
					curRowNextCol = HELL_WAFM_4;
				}
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_16;
				}
				break;
			case HELL_WAFM_24:
				if( Map[ 0 ][ cell - 2 ] == HELL_WAFM_30_BEYOND ){
					if( curRowPrevCol == HELL_WAFM_6_FLOOR ){
						Map[ 0 ][ cell - 2 ] = HELL_WAFM_21;
					}
				}
				if( prevRowCurCol == HELL_WAFM_30_BEYOND ){
					prevRowCurCol = HELL_WAFM_19;
				}
				break;
			case HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT:
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_18;
				}
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_9 ){
					curRowNextCol = HELL_WAFM_15;
				}
				break;
			case HELL_WAFM_18:
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_18;
				}
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_9 ){
					curRowNextCol = HELL_WAFM_10;
				}
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				break;
			case HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT:
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_9 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( nextRowCurCol == HELL_WAFM_9 ){
					nextRowCurCol = HELL_WAFM_11;
				}
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_16;
				}
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_18;
				}
				if( nextRowCurCol == HELL_WAFM_18 ){
					if( curRowPrevCol == HELL_WAFM_6_FLOOR ){
						nextRowCurCol = HELL_WAFM_24;
					}
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_19;
				}
				break;
			case HELL_WAFM_25_BEYOND:
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_18;
				}
				break;
			case HELL_WAFM_11:
				if( nextRowCurCol == HELL_WAFM_15 ){
					nextRowCurCol = HELL_WAFM_14;
				}
				if( nextRowCurCol == HELL_WAFM_3 ){
					nextRowCurCol = HELL_WAFM_5;
				}
				break;
			case HELL_WAFM_26_BEYOND:
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_16;
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_19;
				}
				break;
			case HELL_WAFM_29:
				if( nextRowCurCol == HELL_WAFM_1 ){
					nextRowCurCol = HELL_WAFM_16;
				}
				if( curRowNextCol == HELL_WAFM_2 ){
					curRowNextCol = HELL_WAFM_15;
				}
				if( nextRowCurCol == HELL_WAFM_30_BEYOND ){
					nextRowCurCol = HELL_WAFM_19;
				}
				if( curRowNextCol == HELL_WAFM_30_BEYOND ){
					curRowNextCol = HELL_WAFM_18;
				}
				break;
			}
		}
	}
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){
			int cell = col + 40 * row;
			uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowPrevCol =	Map[ row + 0 ][ col - 1 ];
			uchar& prevRowCurCol =	Map[ row - 1 ][ col + 0 ];

			switch (curRowCurCol ){
			case HELL_WAFM_21:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_24 ){
					if( Map[ 0 ][ cell + 2 ] == HELL_WAFM_1 ){
						Map[ 0 ][ cell + 1 ] = HELL_WAFM_17;
					}
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_9 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_11;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_1 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_16;
				}
				break;
			case HELL_WAFM_15:
				if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_9 ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_1 ){
						if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_16 ){
							Map[ 0 ][ cell + 40 ] = HELL_WAFM_29;
						}
					}
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_4 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_5;
				}
				break;
			case HELL_WAFM_2:
				if( Map[ 0 ][ cell - 40 ] == HELL_WAFM_6_FLOOR ){
					Map[ 0 ][ cell - 40 ] = HELL_WAFM_8;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_5;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_5 ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_16 ){
						Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
					}
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_4 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_1:
				if( Map[ 0 ][ cell - 1 ] == HELL_WAFM_6_FLOOR ){
					Map[ 0 ][ cell - 1 ] = HELL_WAFM_7;
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_4;
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_6_FLOOR ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_4;
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_5 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_12;
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_16 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_13;
				}
				if( Map[ 0 ][ cell - 1 ] == HELL_WAFM_8 ){
					Map[ 0 ][ cell - 1 ] = HELL_WAFM_9;
				}
				break;
			case HELL_WAFM_6_FLOOR:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_15 ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_4 ){
						Map[ 0 ][ cell + 40 ] = HELL_WAFM_10;
					}
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_13 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_16;
				}
				break;
			case HELL_WAFM_9:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_4;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_5;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_4 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_10:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_4;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_4 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_13:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_4;
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_5 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_25_BEYOND:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_9 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_10;
				}
				break;
			case HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT:
				if( Map[ 0 ][ cell - 1 ] == HELL_WAFM_6_FLOOR ){
					if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_1 ){
						Map[ 0 ][ cell + 40 ] = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;
					}
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_3 ){
						Map[ 0 ][ cell + 40 ] = HELL_WAFM_16;
					}
				}
				break;
			case HELL_WAFM_19:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_10 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_17;
				}
				break;
			case HELL_WAFM_11:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_5;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_4 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_14:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_4 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_5;
				}
				break;
			case HELL_WAFM_27_BEYOND_WALL_CORNER_SEE_LEFT:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_9 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_11;
				}
				break;
			}
		}
	}
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){

			int cell = row * 40 + col;
			uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowPrevCol =	Map[ row + 0 ][ col - 1 ];
			uchar& prevRowCurCol =	Map[ row - 1 ][ col + 0 ];

			switch (curRowCurCol ){
			case HELL_WAFM_21:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_10 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_17;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_13 ){
					if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_10 ){
						Map[ 0 ][ cell + 41 ] = HELL_WAFM_12;
					}
				}
				break;
			case HELL_WAFM_17:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_4 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_5 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_10:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_4 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_16 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_13;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_3 ){
					if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_16 ){
						Map[ 0 ][ cell + 40 ] = HELL_WAFM_12;
					}
				}
				break;
			case HELL_WAFM_29:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_9 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_10;
				}
				break;
			case HELL_WAFM_13:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_5 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_9:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_16 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_13;
				}
				break;
			case HELL_WAFM_16:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_3 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_4;
				}
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_5 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_11:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_5 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_12;
				}
				break;
			case HELL_WAFM_1:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_6_FLOOR ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_4;
				}
				break;
			case HELL_WAFM_15:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_10 ){
					Map[ 0 ][ cell + 40 ] = HELL_WAFM_17;
				}
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT ){
					if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_16 ){
						Map[ 0 ][ cell + 40 ] = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;
					}
				}
				break;
			case HELL_WAFM_22_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_RIGHT:
				if( Map[ 0 ][ cell + 1 ] == HELL_WAFM_11 ){
					Map[ 0 ][ cell + 1 ] = HELL_WAFM_17;
				}
				break;
			case HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_1 ){
						if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_6_FLOOR ){
							Map[ 0 ][ cell + 40 ] = HELL_WAFM_16;
						}
					}
				}
				break;
			}
		}
	}
	for( int col = 0; col < 39; col++ ){
		for( int row = 0; row < 39; row++ ){

			int cell = row * 40 + col;
			uchar curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowPrevCol =	Map[ row + 0 ][ col - 1 ];
			uchar& prevRowCurCol =	Map[ row - 1 ][ col + 0 ];

			switch (curRowCurCol ){
			case HELL_WAFM_15:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_28_BEYOND_WALL_CORNER_SEE_RIGHT ){
					if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_16 ){
						Map[ 0 ][ cell + 40 ] = HELL_WAFM_23_BEYOND_RU_LU_CORNER_AND_WALL_CONTINUE_IN_LEFT;
					}
				}
				break;
			case HELL_WAFM_21:
				if( Map[ 0 ][ cell + 39 ] == HELL_WAFM_21 ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_13 ){
						if( Map[ 0 ][ cell + 80 ] == HELL_WAFM_2 ){
							Map[ 0 ][ cell + 40 ] = HELL_WAFM_17;
						}
					}
				}
				break;
			case HELL_WAFM_19:
				if( Map[ 0 ][ cell + 40 ] == HELL_WAFM_15 ){
					if( Map[ 0 ][ cell + 41 ] == HELL_WAFM_12 ){
						Map[ 0 ][ cell + 40 ] = HELL_WAFM_17;
					}
				}
				break;
			}
		}
	}
}

//----- (00416C76) --------------------------------------------------------
void HellTilesVariationsChange()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			int cell = row*40 + col;
			uchar& curWallAndFloorMap = Map[ 0 ][ cell ];

			if( RangeRND(0, 3) ){
				continue;
			}
			int tileGroupNumber = HellTilesVariationsTable[curWallAndFloorMap];
			if( !tileGroupNumber || FixedMap[ 0 ][ cell ] ){
				continue;
			}
			int randCounter = RangeRND(0, 16);
			int newTileIndex = -1;
			while( randCounter >= 0 ){
				if( ++newTileIndex == 140 ){
					newTileIndex = 0;
				}
				if( tileGroupNumber == HellTilesVariationsTable[newTileIndex] ){
					randCounter--;
				}
			}
			curWallAndFloorMap = newTileIndex;
		}
	}
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			int cell = row*40 + col;
			uchar& curWallAndFloorMap = Map[ 0 ][ cell ];
			if( RangeRND(0, 10) ){
				continue;
			}
			if( HellTilesVariationsTable[curWallAndFloorMap] == HELL_WAFM_6_FLOOR && !FixedMap[ 0 ][ cell ] ){
				int randCounter = RangeRND(0, 3);
				switch (randCounter ){
				case 0:		curWallAndFloorMap = HELL_WAFM_95_BONE_FROM_FLOOR_1;	break;
				case 1:		curWallAndFloorMap = HELL_WAFM_96_BONE_FROM_FLOOR_2;	break;
				case 2:		curWallAndFloorMap = HELL_WAFM_97_BONE_FROM_FLOOR_3;	break;
				}
			}
		}
	}
}

//----- (00416D3C) --------------------------------------------------------
void CopyHellInitalRoomsScheme()
{
	for( int col = 0; col < 20; col++ ){
		for( int row = 0; row < 20; row++ ){
			char wall = BinaryHellMap[ row ][ col ];
			InitalHellWallScheme[ row * 2 ][ col * 2 ] = wall;
			InitalHellWallScheme[ row * 2 ][ col * 2 + 1 ] = wall;
			InitalHellWallScheme[ row * 2 + 1 ][ col * 2 ] = wall;
			InitalHellWallScheme[ row * 2 + 1 ][ col * 2 + 1 ] = wall;
		}
	}

	for( int col = 0; col < 20; col++ ){
		for( int row = 0; row < 20; row++ ){
			char* initalHellWallScheme = &InitalHellWallScheme[ 0 ][ 40 ];
			char wall = BinaryHellMap[ row ][ 19 - col ];
			initalHellWallScheme[(row * 2) * 80 + (col * 2)] = wall;
			initalHellWallScheme[(row * 2) * 80 + (col * 2 + 1)] = wall;
			initalHellWallScheme[(row * 2 + 1) * 80 + (col * 2)] = wall;
			initalHellWallScheme[(row * 2 + 1) * 80 + (col * 2 + 1)] = wall;
		}
	}

	for( int col = 0; col < 20; col++ ){
		for( int row = 0; row < 20; row++ ){
			char* initalHellWallScheme = &InitalHellWallScheme[ 40 ][ 0 ];
			char wall = BinaryHellMap[ 19 - row ][ col ];
			initalHellWallScheme[(row * 2) * 80 + (col * 2)] = wall;
			initalHellWallScheme[(row * 2) * 80 + (col * 2 + 1)] = wall;
			initalHellWallScheme[(row * 2 + 1) * 80 + (col * 2)] = wall;
			initalHellWallScheme[(row * 2 + 1) * 80 + (col * 2 + 1)] = wall;

		}
	}

	for( int col = 0; col < 20; col++ ){
		for( int row = 0; row < 20; row++ ){
			char* initalHellWallScheme = &InitalHellWallScheme[ 40 ][ 40 ];
			char wall = BinaryHellMap[ 19 - row ][ 19 - col ];
			initalHellWallScheme[(row * 2) * 80 + (col * 2)] = wall;
			initalHellWallScheme[(row * 2) * 80 + (col * 2 + 1)] = wall;
			initalHellWallScheme[(row * 2 + 1) * 80 + (col * 2)] = wall;
			initalHellWallScheme[(row * 2 + 1) * 80 + (col * 2 + 1)] = wall;

		}
	}
}

//----- (00416E55) --------------------------------------------------------
void SomeStrangeHellBinaryMapChenges()
{
	int someBinHellMapColsChecksResultArray[20];// был глобальным массивом. Название не верно

	memset(someBinHellMapColsChecksResultArray, 0, sizeof someBinHellMapColsChecksResultArray);
	for( int colInv = 19; colInv >= 0; colInv-- ){
		for( int rowInv = 19; rowInv >= 0; rowInv-- ){
			uchar curRowCurCol =	BinaryHellMap[ rowInv + 0 ][ colInv + 0 ];
			uchar curRowNextCol =	BinaryHellMap[ rowInv + 0 ][ colInv + 1 ];
			uchar nextRowNextCol =	BinaryHellMap[ rowInv + 1 ][ colInv + 1 ];

			if( curRowCurCol == 1 ){
				someBinHellMapColsChecksResultArray[colInv] = curRowNextCol == 1 && nextRowNextCol == 0;
				break;
			}
		}
	}

	bool needBreak = false;
	int col = RangeRND(0, 19) + 1;
	do{
		if( !someBinHellMapColsChecksResultArray[col] ){
			// не прошёл col проверку, выбираем следующий
			if( ++col == 20 ){
				col = 1;
			}
			continue;
		}
		for( int rowInv = 19; rowInv >= 0 && !needBreak; rowInv-- ){
			uchar& curRowCurCol =	BinaryHellMap[ rowInv + 0 ][ col + 0 ];
			uchar& curRowNextCol =	BinaryHellMap[ rowInv + 0 ][ col + 1 ];
			if( curRowCurCol == 1 ){
				needBreak = true;
			}else{
				curRowCurCol = 1;
				curRowNextCol = 1;
			}
		}
	}while( !needBreak);

	memset(someBinHellMapColsChecksResultArray, 0, sizeof someBinHellMapColsChecksResultArray);
	for( int rowInv = 19; rowInv >= 0; rowInv-- ){
		for( int colInv = 19; colInv >= 0; colInv-- ){

			uchar curRowCurCol =	BinaryHellMap[ rowInv + 0 ][ colInv + 0 ];
			uchar nextRowcurCol =	BinaryHellMap[ rowInv + 1 ][ colInv + 0 ];
			uchar nextRowNextCol =	BinaryHellMap[ rowInv + 1 ][ colInv + 1 ];

			if( curRowCurCol == 1 ){
				someBinHellMapColsChecksResultArray[rowInv] = nextRowcurCol == 1 && nextRowNextCol == 0;
				break;
			}
		}
	}

	needBreak = false;
	int row = RangeRND(0, 19) + 1;
	do{
		if( !someBinHellMapColsChecksResultArray[row] ){
			if( ++row == 20 ){
				row = 1;
			}
			continue;
		}
		for( int colInv = 19; colInv >= 0 && !needBreak; colInv-- ){
			uchar& curRowCurCol =	BinaryHellMap[ row + 0 ][ colInv + 0 ];
			uchar& nextRowCurCol =	BinaryHellMap[ row + 1 ][ colInv + 0 ];
			if( curRowCurCol == 1 ){
				needBreak = true;
			}else{
				curRowCurCol = 1;
				nextRowCurCol = 1;
			}
		}
	}while( !needBreak );
}

//----- (00416F82) --------------------------------------------------------
int AreaOfLevelRoomsHell()
{
	int floorCellCount = 0;
	for( int i = 0, ie = fullcountof( BinaryHellMap ); i < ie; i++ ){
		if( BinaryHellMap[ 0 ][ i ] == 1 ){
			floorCellCount++;
		}
	}
	return floorCellCount;
}

//----- (00416FA4) --------------------------------------------------------
void ConstructHellRooms()
{
	int colSize, rowSize;
	if( DungeonLevel == 16 ){
		colSize = 14;
		rowSize = 14;
	}else if( DungeonLevel == Quests[Q_21_FLESHDOOM].dungeonLevel && Quests[Q_21_FLESHDOOM].status ){
		colSize = 9;
		rowSize = 9;
	}else if( DungeonLevel == Quests[Q_11_WARLORD_OF_BLOOD].dungeonLevel && Quests[Q_11_WARLORD_OF_BLOOD].status
		   || DungeonLevel == Quests[Q_15_ARCHBISHOP_LAZARUS].dungeonLevel && MaxCountOfPlayersInGame != 1 ){
		colSize = 11;
		rowSize = 11;
	}else{
		rowSize = RangeRND(0, 5) + 2;
		colSize = RangeRND(0, 5) + 2;
	}

	int startRow = ((20 - rowSize) >> 1) + RangeRND(0, 20 - rowSize - ((20 - rowSize) >> 1));
	LimitToMax(startRow, 20 - rowSize);


	int startCol = ((20 - colSize) >> 1) + RangeRND(0, 20 - ((20 - colSize) >> 1) - colSize);
	LimitToMax(startCol, 20 - colSize);

	if( DungeonLevel == 16 ){
		MapXOffset = startRow;
		MapYOffset = startCol;
	}
	if( IsQuestOnLevel(Q_11_WARLORD_OF_BLOOD) 
     || IsQuestOnLevel(Q_21_FLESHDOOM) 
	 || DungeonLevel == Quests[Q_15_ARCHBISHOP_LAZARUS].dungeonLevel && MaxCountOfPlayersInGame != 1 ){
		Map40x40gStartRow = startRow + 1;
		Map40x40gEndRow = rowSize + startRow + 1;
		Map40x40gStartCol = startCol + 1;
		Map40x40gEndCol = colSize + startCol + 1;
	}else{
		Map40x40gStartRow = 0;
		Map40x40gStartCol = 0;
		Map40x40gEndRow = 0;
		Map40x40gEndCol = 0;
	}
	BuildHellRectangleRoom(startRow, startCol, rowSize, colSize);
	RecursiveHellRoomsConstruct(startRow, startCol, rowSize, colSize, RangeRND(0, 2));
}

//----- (004170D5) --------------------------------------------------------
void __fastcall BuildHellRectangleRoom(int startRow, int startCol, int rowSize, int colSize)
{
	int endCol = startCol + colSize;
	int endRow = startRow + rowSize;
	for( int col = startCol; col < endCol; col++ ){
		for( int row = startRow; row < endRow; row++ ){
			BinaryHellMap[ row ][ col ] = 1;
		}
	}
}

//----- (0041710C) --------------------------------------------------------
void RecursiveHellRoomsConstruct_2(int startRow, int startCol, int rows, int cols, int quarterProbability)
{
	int col = startCol;
	int row = startRow;
	int solidWalls = 1, prevSolid, x, y, xSize, ySize;
	while( 1 ){
		if( !RangeRND(0, 4) != quarterProbability ){
			rows /= 2;
			int index = 0;
			do{
				ySize = (RangeRND(0, 5) + 2) & 0xFFFFFFFE;
				xSize = (RangeRND(0, 5) + 2) & 0xFFFFFFFE;
				y = rows + row - ySize / 2;
				x = startCol - xSize;
				solidWalls = ThereIsNoHellRoom(y - 1, startCol - xSize - 1, ySize + 2, xSize + 1);
				++index;
				prevSolid = solidWalls;
			}while( !solidWalls && index < 20 );
			if( solidWalls == 1 ){
				BuildHellRectangleRoom(y, x, ySize, xSize);
			}
			row = cols + startCol;
			solidWalls = ThereIsNoHellRoom(y - 1, cols + startCol, ySize + 2, xSize + 1);
			if( solidWalls == 1 ){
				BuildHellRectangleRoom(y, row, ySize, xSize);
			}
			if( prevSolid == 1 ){
				RecursiveHellRoomsConstruct(y, x, ySize, xSize, 0);
			}
			if( solidWalls != 1 ){
				return;
			}
			quarterProbability = 0;
			startCol = row;
			row = y;
		}else{
			int index = 0;
			cols /= 2;
			do{
				ySize = (RangeRND(0, 5) + 2) & 0xFFFFFFFE;
				xSize = (RangeRND(0, 5) + 2) & 0xFFFFFFFE;
				x = cols + startCol - xSize / 2;
				y = row - ySize;
				solidWalls = ThereIsNoHellRoom(row - ySize - 1, x - 1, xSize + 2, ySize + 1);
				++index;
				prevSolid = solidWalls;
			}while( !solidWalls && index < 20 );
			if( solidWalls == 1 ){
				BuildHellRectangleRoom(y, x, ySize, xSize);
			}
			row += rows;
			solidWalls = ThereIsNoHellRoom(startRow, x - 1, ySize + 1, xSize + 2);
			if( solidWalls == 1 ){
				BuildHellRectangleRoom(row, x, ySize, xSize);
			}
			if( prevSolid == 1 ){
				RecursiveHellRoomsConstruct(y, x, ySize, xSize, 1);
			}
			if( solidWalls != 1 ){
				return;
			}
			quarterProbability = 1;
			startCol = x;
		}
		cols = xSize;
		rows = ySize;

	}
}
// неразобранная функция (0041710C), зато в отличие от почти разобранной верхней, работает эквивалентно тх1
void __fastcall RecursiveHellRoomsConstruct(int startRow, int startCol, int rows, int cols, int quarterProbability)
{
	int v5; // eax@2
	int v6; // ecx@3
	int v7; // eax@5
	int v8; // ecx@5
	int v9; // eax@8
	int v10; // esi@8
	int v11; // edi@8
	int v12; // ebx@8
	int v13; // eax@8
	int v14; // eax@19
	int v15; // esi@19
	int v16; // eax@19
	int v17; // edi@19
	int v18; // ebx@19
	int v19; // eax@19
	int startRowa; // [sp+Ch] [bp-10h]@8
	int startRowb; // [sp+Ch] [bp-10h]@19
	int v22; // [sp+10h] [bp-Ch]@8
	int v23; // [sp+10h] [bp-Ch]@19
	int v24; // [sp+14h] [bp-8h]@1
	int v25; // [sp+14h] [bp-8h]@12
	int v26; // [sp+18h] [bp-4h]@1
	int v27; // [sp+24h] [bp+8h]@7
	int v28; // [sp+28h] [bp+Ch]@12
	int v29; // [sp+28h] [bp+Ch]@18
	int v30; // [sp+28h] [bp+Ch]@23
	int v31; // [sp+2Ch] [bp+10h]@7
	int v32; // [sp+2Ch] [bp+10h]@18

	v26 = startCol;
	v24 = startRow;
	while( 1 ){
		while( 1 ){
			v5 = RangeRND(0, 4);
			v6 = quarterProbability == 1 ? (unsigned __int8)(v5 != 0) : (unsigned __int8)(v5 == 0);
			v7 = v6;
			v8 = 0;
			if( !v7 )
				break;
			if( v7 != 1 )
				return;
			v31 = 0;
			v27 = rows / 2;
			do
			{
				v9 = RangeRND(0, 5);
				v10 = (v9 + 2) & 0xFFFFFFFE;
				v11 = (RangeRND(0, 5) + 2) & 0xFFFFFFFE;
				v12 = v27 + v24 - v10 / 2;
				startRowa = v26 - v11;
				v13 = ThereIsNoHellRoom(v12 - 1, v26 - v11 - 1, v10 + 2, v11 + 1);
				++v31;
				v22 = v13;
			}
			while( !v13 && v31 < 20 );
			if( v13 == 1 )
				BuildHellRectangleRoom(v12, startRowa, v10, v11);
			v25 = cols + v26;
			v28 = ThereIsNoHellRoom(v12 - 1, cols + v26, v10 + 2, v11 + 1);
			if( v28 == 1 )
				BuildHellRectangleRoom(v12, v25, v10, v11);
			if( v22 == 1 )
				RecursiveHellRoomsConstruct(v12, startRowa, v10, v11, 0);
			if( v28 != 1 )
				return;
			quarterProbability = 0;
			cols = v11;
			rows = v10;
			v26 = v25;
			v24 = v12;
		}
		v32 = 0;
		v29 = cols / 2;
		do
		{
			v14 = RangeRND(0, 5);
			v15 = (v14 + 2) & 0xFFFFFFFE;
			v16 = RangeRND(0, 5);
			v17 = (v16 + 2) & 0xFFFFFFFE;
			v18 = v29 + v26 - ((v16 + 2) & 0xFFFFFFFE) / 2;
			startRowb = v24 - v15;
			v19 = ThereIsNoHellRoom(v24 - v15 - 1, v18 - 1, v17 + 2, v15 + 1);
			++v32;
			v23 = v19;
		}
		while( !v19 && v32 < 20 );
		if( v19 == 1 )
			BuildHellRectangleRoom(startRowb, v18, v15, v17);
		v24 += rows;
		v30 = ThereIsNoHellRoom(v24, v18 - 1, v15 + 1, v17 + 2);
		if( v30 == 1 )
			BuildHellRectangleRoom(v24, v18, v15, v17);
		if( v23 == 1 )
			RecursiveHellRoomsConstruct(startRowb, v18, v15, v17, 1);
		if( v30 != 1 )
			break;
		quarterProbability = 1;
		cols = v17;
		rows = v15;
		v26 = v18;
	}
}

//----- (00417315) --------------------------------------------------------
bool __fastcall ThereIsNoHellRoom(int startRow, int startCol, int rowSize, int colSize)
{
	int endCol = startCol + colSize;
	int endRow = startRow + rowSize;

	if( startRow <= 0 || startCol <= 0 ){
		return false;
	}

	if( rowSize <= 0 || colSize <= 0 ){
		return true;
	}

	if( endCol > 20 || endRow > 20 ){
		return false;
	}

	for( int col = startCol; col < endCol; col++ ){
		for( int row = startRow; row < endRow; row++ ){
			if( BinaryHellMap[ row ][ col ] != 0 ){
				return false;
			}
		}
	}
	return true;
}

//----- (00417381) --------------------------------------------------------
bool __fastcall PlaceHellPatMap(int patternPtr, int minPatternsToPlace, int maxPatternsToPlace, int a4, int a5, int resetPlayerPosition, int a7)
{
	int patternRowSize = *(uchar*)patternPtr;
	int patternColSize = *(uchar*)(patternPtr + 1);

	char* beforePattern = ((char*)patternPtr + 2);
	char* afterPattern = beforePattern + patternRowSize * patternColSize;

	//здесь определяется сколько копий объекта понатыкать на карте
	int numberOfPatternsToPlace;
	if( maxPatternsToPlace - minPatternsToPlace ){
		numberOfPatternsToPlace = RangeRND(0, maxPatternsToPlace - minPatternsToPlace);
	}else{
		numberOfPatternsToPlace = 1;
	}

	int col;
	int row;
	int mapRowsLimit = 40 - patternRowSize;
	int mapColumnsLimit = 40 - patternColSize;
	int continueFlag;

	for( int patternsPlaced = 0; patternsPlaced < numberOfPatternsToPlace; patternsPlaced++ ){
		bool isPatternPlaced = false;
		row = RangeRND(0, mapRowsLimit);
		col = RangeRND(0, mapColumnsLimit);
		int tryesCounter = 0;

		do{
			continueFlag = 1;

			if( row >= Map40x40gStartRow && row <= Map40x40gEndRow ){
				if( col >= Map40x40gStartCol && col <= Map40x40gEndCol ){
					continueFlag = 0;
				}
			}

			if( a4 != -1 ){
				if( row >= a4 - patternRowSize && row <= a4 + 12 ){
					row = RangeRND(0, mapRowsLimit);
					col = RangeRND(0, mapColumnsLimit);
					continueFlag = 0;
				}
			}
			if( a5 != -1 ){
				if( col >= a5 - patternColSize && col <= a5 + 12 ){
					row = RangeRND(0, mapRowsLimit);
					col = RangeRND(0, mapColumnsLimit);
					continueFlag = 0;
				}
			}

			// проверка на соответствие паттерну
			for( int colOffset = 0; colOffset < patternColSize && continueFlag; colOffset++ ){
				for( int rowOffset = 0; rowOffset < patternRowSize && continueFlag; rowOffset++ ){
					uchar neededTile = beforePattern[colOffset*patternRowSize+rowOffset];
					int mapCell = (row+rowOffset)*40 + (col+colOffset);
					if( (neededTile && (Map[ 0 ][ mapCell ] != neededTile)) || FixedMap[ 0 ][ mapCell ] ){
						continueFlag = 0; //бида бида, паттерн не соблюдается, надо искать другое место
					}
				}
			}

			if( continueFlag ){
				//матерь божья, мы нашли подходящее место для установки объекта, копируем ка его паттерн быстренько на карту
				for( int colOffset = 0; colOffset < patternColSize; colOffset++ ){
					for( int rowOffset = 0; rowOffset < patternRowSize; rowOffset++ ){
						uchar newTile = afterPattern[colOffset*patternRowSize+rowOffset];
						int mapCell = (row+rowOffset)*40 + (col+colOffset);
						if( newTile ){
							FixedMap[ 0 ][ mapCell ] |= BIT(4);
							Map[ 0 ][ mapCell ] = newTile;
						}
					}
				}
				isPatternPlaced = true;
			}

			// следующая клетка
			if( !isPatternPlaced ){
				if( ++row == mapRowsLimit ){
					row = 0;
					if( ++col == mapColumnsLimit ){			
						col = 0;
					}
				}
				tryesCounter++;
				//после 4000 фэйлов в поиске подходящего места просто выходим, ну его нафиг
				if( tryesCounter >= 200 ){
					return false;
				}
			}

		}while( !isPatternPlaced);

	}

	if( DungeonLevel == 15 ){
		Quests[Q_15_ARCHBISHOP_LAZARUS].row = row + 1;
		Quests[Q_15_ARCHBISHOP_LAZARUS].col = col + 1;
	}
	if( resetPlayerPosition == 1 ){
		PlayerRowPos = 2 * row + 21;
		PlayerColPos = 2 * col + 22;
	}
	if( !a7 ){
		SomeXPos2 = 2 * row + 21;
		SomeYPos2 = 2 * col + 22;
	}
	return true;
}

//----- (004175E3) --------------------------------------------------------
void InitHellWallsTransparency()
{
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			if( Map[ row ][ col ] == HELL_WAFM_6_FLOOR && !HallMap[Convert40to112(row)][Convert40to112(col)] ){ // пол не отнесённый ни к одной из комнат относим к новой комнате
				SetHellCellTransparency(row, col, Convert40to112(row), Convert40to112(col), 0);
				HallIndex++;
			}
		}
	}
}

//----- (00417652) --------------------------------------------------------
void __fastcall SetHellCellTransparency( int row40, int col40, int row112, int col112, int orientation )
{
	uchar wallTransparentIndex = HallIndex;
	int curRow112 = row112;
	int curCol112 = col112;
	int curCol40 = col40;
	int curRow40 = row40;
	while( Map[ curRow40 ][ curCol40 ] == HELL_WAFM_6_FLOOR && !HallMap[curRow112][curCol112] ){
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		// row ->
		//5 4 6
		//2 0 1
		//7 3 8
		SetHellCellTransparency(curRow40 + 1,	curCol40,		curRow112 + 2,		curCol112,			1);
		SetHellCellTransparency(curRow40 - 1,	curCol40,		curRow112 - 2,		curCol112,			2);
		SetHellCellTransparency(curRow40,		curCol40 + 1,	curRow112,			curCol112 + 2,		3);
		SetHellCellTransparency(curRow40,		curCol40 - 1,	curRow112,			curCol112 - 2,		4);
		SetHellCellTransparency(curRow40 - 1,	curCol40 - 1,	curRow112 - 2,		curCol112 - 2,		5);
		SetHellCellTransparency(curRow40 + 1,	curCol40 - 1,	curRow112 + 2,		curCol112 - 2,		6);
		SetHellCellTransparency(curRow40 - 1,	curCol40 + 1,	curRow112 - 2,		curCol112 + 2,		7);
		orientation = 8;
		curCol40++;
		curRow40++;
		curRow112 = Convert40to112(curRow40);
		curCol112 = Convert40to112(curCol40);
	}

	switch (orientation ){
	case 1:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 2:
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 3:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	case 4:
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 5:
		HallMap[ curRow112 + 1 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 6:
		HallMap[ curRow112 + 0 ][ curCol112 + 1 ] = wallTransparentIndex;
		break;
	case 7:
		HallMap[ curRow112 + 1 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	case 8:
		HallMap[ curRow112 + 0 ][ curCol112 + 0 ] = wallTransparentIndex;
		break;
	}
}

//----- (00417846) --------------------------------------------------------
void HellSetAdditionalWallsTransparency()
{
	for( int col = 0; col < 40; col++ ){// опять не проверяется на выход за границы ничего
		for( int row = 0; row < 40; row++ ){

			uchar curRowCurColWafm   = Map[ row + 0 ][ col + 0 ];
			uchar nextRowCurColWafm  = Map[ row + 1 ][ col + 0 ];
			uchar curRowPrevColWafm  = Map[ row + 0 ][ col - 1 ];

			uchar& curRowCurColTwm   = HallMap[ 16+row*2 + 0 ][ 16+col*2 + 0 ];
			uchar& nextRowCurColTwm  = HallMap[ 16+row*2 + 1 ][ 16+col*2 + 0 ];
			uchar& curRowNextColTwm  = HallMap[ 16+row*2 + 0 ][ 16+col*2 + 1 ];
			uchar& nextRowNextColTwm = HallMap[ 16+row*2 + 1 ][ 16+col*2 + 1 ];
			uchar& prevRowCurColTwm  = HallMap[ 16+row*2 - 1 ][ 16+col*2 + 0 ];
			uchar& curRowPrevColTwm  = HallMap[ 16+row*2 + 0 ][ 16+col*2 - 1 ];

			if( IsHellBeyondTileWithWallsContinueInLuAndLd(curRowCurColWafm) ){
				if( curRowPrevColWafm == HELL_WAFM_18 ){
					nextRowCurColTwm = curRowCurColTwm;
					nextRowNextColTwm = curRowCurColTwm;
				}
			}
			if( IsHellBeyondTileWithWallsContinueInRuAndRd(curRowCurColWafm) ){
				if( nextRowCurColWafm == HELL_WAFM_19 ){
					curRowNextColTwm = curRowCurColTwm;
					nextRowNextColTwm = curRowCurColTwm;
				}
			}
			if( curRowCurColWafm == HELL_WAFM_18 ){
				nextRowCurColTwm = curRowCurColTwm;
				nextRowNextColTwm = curRowCurColTwm;
			}
			if( curRowCurColWafm == HELL_WAFM_19 ){
				curRowNextColTwm = curRowCurColTwm;
				nextRowNextColTwm = curRowCurColTwm;
			}
			if( curRowCurColWafm == HELL_WAFM_24 ){
				nextRowCurColTwm = curRowCurColTwm;
				curRowNextColTwm = curRowCurColTwm;
				nextRowNextColTwm = curRowCurColTwm;
			}
			if( curRowCurColWafm == HELL_WAFM_57 ){
				prevRowCurColTwm = curRowNextColTwm;
				curRowCurColTwm = curRowNextColTwm;
			}
			if( curRowCurColWafm == HELL_WAFM_53 ){
				curRowPrevColTwm = nextRowCurColTwm;
				curRowCurColTwm = nextRowCurColTwm;
			}


		}
	}
}

//----- (00417911) --------------------------------------------------------
void SomeHellBeyondTilesConvert()
{
	for( int col = 1; col < 39; col++ ){
		for( int row = 1; row < 39; row++ ){
			uchar& curRowCurCol =	Map[ row + 0 ][ col + 0 ];
			uchar& nextRowCurCol =	Map[ row + 1 ][ col + 0 ];
			uchar& curRowNextCol =	Map[ row + 0 ][ col + 1 ];

			if( curRowCurCol >= HELL_WAFM_18 && curRowCurCol <= HELL_WAFM_30_BEYOND ){
				if( nextRowCurCol < HELL_WAFM_18 || curRowNextCol < HELL_WAFM_18 ){
					curRowCurCol += 98;
				}
			}
		}
	}
}

//----- (00417946) --------------------------------------------------------
void InitHellLevelTiles()
{
	TileSquare* currentLevelTilesFile = (TileSquare*)CurrentLevelTilesFile;
	TileSquare& beyondTile = currentLevelTilesFile[ HELL_WAFM_30_BEYOND-1 ];

	// заполняем всю карту тайлами бейонда
	for( int col = 0; col < 112; col += 2 ){
		for( int row = 0; row < 112; row += 2 ){
			FineMap[ row + 0 ][ col + 0 ] = beyondTile.up + 1;
			FineMap[ row + 1 ][ col + 0 ] = beyondTile.left + 1;
			FineMap[ row + 0 ][ col + 1 ] = beyondTile.right + 1;
			FineMap[ row + 1 ][ col + 1 ] = beyondTile.down + 1;
		}
	}

	// проходим по всем клеткам и заполняем их значениями из загруженного TIL файла
	for( int col = 0; col < 40; col++ ){
		for( int row = 0; row < 40; row++ ){
			uchar wafm = Map[ row ][ col ];
			ushort up = 0;
			ushort left = 0;
			ushort right = 0;
			ushort down = 0;
			if( wafm ){
				TileSquare& currentTile = currentLevelTilesFile[ wafm-1 ];
				up = currentTile.up + 1;
				left = currentTile.left + 1;
				right = currentTile.right + 1;
				down = currentTile.down + 1;
			}
			FineMap[ 2*row + 0 + 16 ][ 2*col + 0 + 16 ] = up;
			FineMap[ 2*row + 1 + 16 ][ 2*col + 0 + 16 ] = left;
			FineMap[ 2*row + 0 + 16 ][ 2*col + 1 + 16 ] = right;
			FineMap[ 2*row + 1 + 16 ][ 2*col + 1 + 16 ] = down;
		}
	}
}